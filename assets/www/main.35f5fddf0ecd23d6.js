var Bi = Math.pow;
(self.webpackChunkapp = self.webpackChunkapp || []).push([[179], {
    9453: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {r: () => te});
        var r = R(655), D = R(3228), ie = R(6435), te = function (j) {
            function W() {
                var Q = null !== j && j.apply(this, arguments) || this;
                return Q.PERMISSION = {
                    ACCESS_CHECKIN_PROPERTIES: "android.permission.ACCESS_CHECKIN_PROPERTIES",
                    ACCESS_COARSE_LOCATION: "android.permission.ACCESS_COARSE_LOCATION",
                    ACCESS_FINE_LOCATION: "android.permission.ACCESS_FINE_LOCATION",
                    ACCESS_LOCATION_EXTRA_COMMANDS: "android.permission.ACCESS_LOCATION_EXTRA_COMMANDS",
                    ACCESS_MOCK_LOCATION: "android.permission.ACCESS_MOCK_LOCATION",
                    ACCESS_NETWORK_STATE: "android.permission.ACCESS_NETWORK_STATE",
                    ACCESS_SURFACE_FLINGER: "android.permission.ACCESS_SURFACE_FLINGER",
                    ACCESS_WIFI_STATE: "android.permission.ACCESS_WIFI_STATE",
                    ACCOUNT_MANAGER: "android.permission.ACCOUNT_MANAGER",
                    ADD_VOICEMAIL: "com.android.voicemail.permission.ADD_VOICEMAIL",
                    AUTHENTICATE_ACCOUNTS: "android.permission.AUTHENTICATE_ACCOUNTS",
                    BATTERY_STATS: "android.permission.BATTERY_STATS",
                    BIND_ACCESSIBILITY_SERVICE: "android.permission.BIND_ACCESSIBILITY_SERVICE",
                    BIND_APPWIDGET: "android.permission.BIND_APPWIDGET",
                    BIND_CARRIER_MESSAGING_SERVICE: "android.permission.BIND_CARRIER_MESSAGING_SERVICE",
                    BIND_DEVICE_ADMIN: "android.permission.BIND_DEVICE_ADMIN",
                    BIND_DREAM_SERVICE: "android.permission.BIND_DREAM_SERVICE",
                    BIND_INPUT_METHOD: "android.permission.BIND_INPUT_METHOD",
                    BIND_NFC_SERVICE: "android.permission.BIND_NFC_SERVICE",
                    BIND_NOTIFICATION_LISTENER_SERVICE: "android.permission.BIND_NOTIFICATION_LISTENER_SERVICE",
                    BIND_PRINT_SERVICE: "android.permission.BIND_PRINT_SERVICE",
                    BIND_REMOTEVIEWS: "android.permission.BIND_REMOTEVIEWS",
                    BIND_TEXT_SERVICE: "android.permission.BIND_TEXT_SERVICE",
                    BIND_TV_INPUT: "android.permission.BIND_TV_INPUT",
                    BIND_VOICE_INTERACTION: "android.permission.BIND_VOICE_INTERACTION",
                    BIND_VPN_SERVICE: "android.permission.BIND_VPN_SERVICE",
                    BIND_WALLPAPER: "android.permission.BIND_WALLPAPER",
                    BLUETOOTH: "android.permission.BLUETOOTH",
                    BLUETOOTH_ADMIN: "android.permission.BLUETOOTH_ADMIN",
                    BLUETOOTH_PRIVILEGED: "android.permission.BLUETOOTH_PRIVILEGED",
                    BODY_SENSORS: "android.permission.BODY_SENSORS",
                    BRICK: "android.permission.BRICK",
                    BROADCAST_PACKAGE_REMOVED: "android.permission.BROADCAST_PACKAGE_REMOVED",
                    BROADCAST_SMS: "android.permission.BROADCAST_SMS",
                    BROADCAST_STICKY: "android.permission.BROADCAST_STICKY",
                    BROADCAST_WAP_PUSH: "android.permission.BROADCAST_WAP_PUSH",
                    CALL_PHONE: "android.permission.CALL_PHONE",
                    CALL_PRIVILEGED: "android.permission.CALL_PRIVILEGED",
                    CAMERA: "android.permission.CAMERA",
                    CAPTURE_AUDIO_OUTPUT: "android.permission.CAPTURE_AUDIO_OUTPUT",
                    CAPTURE_SECURE_VIDEO_OUTPUT: "android.permission.CAPTURE_SECURE_VIDEO_OUTPUT",
                    CAPTURE_VIDEO_OUTPUT: "android.permission.CAPTURE_VIDEO_OUTPUT",
                    CHANGE_COMPONENT_ENABLED_STATE: "android.permission.CHANGE_COMPONENT_ENABLED_STATE",
                    CHANGE_CONFIGURATION: "android.permission.CHANGE_CONFIGURATION",
                    CHANGE_NETWORK_STATE: "android.permission.CHANGE_NETWORK_STATE",
                    CHANGE_WIFI_MULTICAST_STATE: "android.permission.CHANGE_WIFI_MULTICAST_STATE",
                    CHANGE_WIFI_STATE: "android.permission.CHANGE_WIFI_STATE",
                    CLEAR_APP_CACHE: "android.permission.CLEAR_APP_CACHE",
                    CLEAR_APP_USER_DATA: "android.permission.CLEAR_APP_USER_DATA",
                    CONTROL_LOCATION_UPDATES: "android.permission.CONTROL_LOCATION_UPDATES",
                    DELETE_CACHE_FILES: "android.permission.DELETE_CACHE_FILES",
                    DELETE_PACKAGES: "android.permission.DELETE_PACKAGES",
                    DEVICE_POWER: "android.permission.DEVICE_POWER",
                    DIAGNOSTIC: "android.permission.DIAGNOSTIC",
                    DISABLE_KEYGUARD: "android.permission.DISABLE_KEYGUARD",
                    DUMP: "android.permission.DUMP",
                    EXPAND_STATUS_BAR: "android.permission.EXPAND_STATUS_BAR",
                    FACTORY_TEST: "android.permission.FACTORY_TEST",
                    FLASHLIGHT: "android.permission.FLASHLIGHT",
                    FORCE_BACK: "android.permission.FORCE_BACK",
                    GET_ACCOUNTS: "android.permission.GET_ACCOUNTS",
                    GET_PACKAGE_SIZE: "android.permission.GET_PACKAGE_SIZE",
                    GET_TASKS: "android.permission.GET_TASKS",
                    GET_TOP_ACTIVITY_INFO: "android.permission.GET_TOP_ACTIVITY_INFO",
                    GLOBAL_SEARCH: "android.permission.GLOBAL_SEARCH",
                    HARDWARE_TEST: "android.permission.HARDWARE_TEST",
                    INJECT_EVENTS: "android.permission.INJECT_EVENTS",
                    INSTALL_LOCATION_PROVIDER: "android.permission.INSTALL_LOCATION_PROVIDER",
                    INSTALL_PACKAGES: "android.permission.INSTALL_PACKAGES",
                    INSTALL_SHORTCUT: "com.android.launcher.permission.INSTALL_SHORTCUT",
                    INTERNAL_SYSTEM_WINDOW: "android.permission.INTERNAL_SYSTEM_WINDOW",
                    INTERNET: "android.permission.INTERNET",
                    KILL_BACKGROUND_PROCESSES: "android.permission.KILL_BACKGROUND_PROCESSES",
                    LOCATION_HARDWARE: "android.permission.LOCATION_HARDWARE",
                    MANAGE_ACCOUNTS: "android.permission.MANAGE_ACCOUNTS",
                    MANAGE_APP_TOKENS: "android.permission.MANAGE_APP_TOKENS",
                    MANAGE_DOCUMENTS: "android.permission.MANAGE_DOCUMENTS",
                    MASTER_CLEAR: "android.permission.MASTER_CLEAR",
                    MEDIA_CONTENT_CONTROL: "android.permission.MEDIA_CONTENT_CONTROL",
                    MODIFY_AUDIO_SETTINGS: "android.permission.MODIFY_AUDIO_SETTINGS",
                    MODIFY_PHONE_STATE: "android.permission.MODIFY_PHONE_STATE",
                    MOUNT_FORMAT_FILESYSTEMS: "android.permission.MOUNT_FORMAT_FILESYSTEMS",
                    MOUNT_UNMOUNT_FILESYSTEMS: "android.permission.MOUNT_UNMOUNT_FILESYSTEMS",
                    NFC: "android.permission.NFC",
                    PERSISTENT_ACTIVITY: "android.permission.PERSISTENT_ACTIVITY",
                    PROCESS_OUTGOING_CALLS: "android.permission.PROCESS_OUTGOING_CALLS",
                    READ_CALENDAR: "android.permission.READ_CALENDAR",
                    READ_CALL_LOG: "android.permission.READ_CALL_LOG",
                    READ_CONTACTS: "android.permission.READ_CONTACTS",
                    READ_EXTERNAL_STORAGE: "android.permission.READ_EXTERNAL_STORAGE",
                    READ_FRAME_BUFFER: "android.permission.READ_FRAME_BUFFER",
                    READ_HISTORY_BOOKMARKS: "com.android.browser.permission.READ_HISTORY_BOOKMARKS",
                    READ_INPUT_STATE: "android.permission.READ_INPUT_STATE",
                    READ_LOGS: "android.permission.READ_LOGS",
                    READ_PHONE_STATE: "android.permission.READ_PHONE_STATE",
                    READ_PROFILE: "android.permission.READ_PROFILE",
                    READ_SMS: "android.permission.READ_SMS",
                    READ_SOCIAL_STREAM: "android.permission.READ_SOCIAL_STREAM",
                    READ_SYNC_SETTINGS: "android.permission.READ_SYNC_SETTINGS",
                    READ_SYNC_STATS: "android.permission.READ_SYNC_STATS",
                    READ_USER_DICTIONARY: "android.permission.READ_USER_DICTIONARY",
                    READ_VOICEMAIL: "com.android.voicemail.permission.READ_VOICEMAIL",
                    REBOOT: "android.permission.REBOOT",
                    RECEIVE_BOOT_COMPLETED: "android.permission.RECEIVE_BOOT_COMPLETED",
                    RECEIVE_MMS: "android.permission.RECEIVE_MMS",
                    RECEIVE_SMS: "android.permission.RECEIVE_SMS",
                    RECEIVE_WAP_PUSH: "android.permission.RECEIVE_WAP_PUSH",
                    RECORD_AUDIO: "android.permission.RECORD_AUDIO",
                    REORDER_TASKS: "android.permission.REORDER_TASKS",
                    RESTART_PACKAGES: "android.permission.RESTART_PACKAGES",
                    SEND_RESPOND_VIA_MESSAGE: "android.permission.SEND_RESPOND_VIA_MESSAGE",
                    SEND_SMS: "android.permission.SEND_SMS",
                    SET_ACTIVITY_WATCHER: "android.permission.SET_ACTIVITY_WATCHER",
                    SET_ALARM: "com.android.alarm.permission.SET_ALARM",
                    SET_ALWAYS_FINISH: "android.permission.SET_ALWAYS_FINISH",
                    SET_ANIMATION_SCALE: "android.permission.SET_ANIMATION_SCALE",
                    SET_DEBUG_APP: "android.permission.SET_DEBUG_APP",
                    SET_ORIENTATION: "android.permission.SET_ORIENTATION",
                    SET_POINTER_SPEED: "android.permission.SET_POINTER_SPEED",
                    SET_PREFERRED_APPLICATIONS: "android.permission.SET_PREFERRED_APPLICATIONS",
                    SET_PROCESS_LIMIT: "android.permission.SET_PROCESS_LIMIT",
                    SET_TIME: "android.permission.SET_TIME",
                    SET_TIME_ZONE: "android.permission.SET_TIME_ZONE",
                    SET_WALLPAPER: "android.permission.SET_WALLPAPER",
                    SET_WALLPAPER_HINTS: "android.permission.SET_WALLPAPER_HINTS",
                    SIGNAL_PERSISTENT_PROCESSES: "android.permission.SIGNAL_PERSISTENT_PROCESSES",
                    STATUS_BAR: "android.permission.STATUS_BAR",
                    SUBSCRIBED_FEEDS_READ: "android.permission.SUBSCRIBED_FEEDS_READ",
                    SUBSCRIBED_FEEDS_WRITE: "android.permission.SUBSCRIBED_FEEDS_WRITE",
                    SYSTEM_ALERT_WINDOW: "android.permission.SYSTEM_ALERT_WINDOW",
                    TRANSMIT_IR: "android.permission.TRANSMIT_IR",
                    UNINSTALL_SHORTCUT: "com.android.launcher.permission.UNINSTALL_SHORTCUT",
                    UPDATE_DEVICE_STATS: "android.permission.UPDATE_DEVICE_STATS",
                    USE_CREDENTIALS: "android.permission.USE_CREDENTIALS",
                    USE_SIP: "android.permission.USE_SIP",
                    VIBRATE: "android.permission.VIBRATE",
                    WAKE_LOCK: "android.permission.WAKE_LOCK",
                    WRITE_APN_SETTINGS: "android.permission.WRITE_APN_SETTINGS",
                    WRITE_CALENDAR: "android.permission.WRITE_CALENDAR",
                    WRITE_CALL_LOG: "android.permission.WRITE_CALL_LOG",
                    WRITE_CONTACTS: "android.permission.WRITE_CONTACTS",
                    WRITE_EXTERNAL_STORAGE: "android.permission.WRITE_EXTERNAL_STORAGE",
                    WRITE_GSERVICES: "android.permission.WRITE_GSERVICES",
                    WRITE_HISTORY_BOOKMARKS: "com.android.browser.permission.WRITE_HISTORY_BOOKMARKS",
                    WRITE_PROFILE: "android.permission.WRITE_PROFILE",
                    WRITE_SECURE_SETTINGS: "android.permission.WRITE_SECURE_SETTINGS",
                    WRITE_SETTINGS: "android.permission.WRITE_SETTINGS",
                    WRITE_SMS: "android.permission.WRITE_SMS",
                    WRITE_SOCIAL_STREAM: "android.permission.WRITE_SOCIAL_STREAM",
                    WRITE_SYNC_SETTINGS: "android.permission.WRITE_SYNC_SETTINGS",
                    WRITE_USER_DICTIONARY: "android.permission.WRITE_USER_DICTIONARY",
                    WRITE_VOICEMAIL: "com.android.voicemail.permission.WRITE_VOICEMAIL"
                }, Q
            }

            return (0, r.ZT)(W, j), W.prototype.checkPermission = function (Q) {
                return (0, D.DM)(this, "checkPermission", {}, arguments)
            }, W.prototype.requestPermission = function (Q) {
                return (0, D.DM)(this, "requestPermission", {}, arguments)
            }, W.prototype.requestPermissions = function (Q) {
                return (0, D.DM)(this, "requestPermissions", {}, arguments)
            }, W.prototype.hasPermission = function (Q) {
                return (0, D.DM)(this, "hasPermission", {}, arguments)
            }, W.pluginName = "AndroidPermissions", W.plugin = "cordova-plugin-android-permissions", W.pluginRef = "cordova.plugins.permissions", W.repo = "https://github.com/NeoLSN/cordova-plugin-android-permissions", W.platforms = ["Android"], W.\u0275fac = function () {
                var Q;
                return function (ve) {
                    return (Q || (Q = ie.n5z(W)))(ve || W)
                }
            }(), W.\u0275prov = ie.Yz7({
                token: W, factory: function (Q) {
                    return W.\u0275fac(Q)
                }
            }), W
        }(D.On)
    }, 4299: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {T: () => te});
        var r = R(655), D = R(3228), ie = R(6435), te = function (j) {
            function W() {
                return null !== j && j.apply(this, arguments) || this
            }

            return (0, r.ZT)(W, j), W.prototype.copy = function (Q) {
                return (0, D.DM)(this, "copy", {}, arguments)
            }, W.prototype.paste = function () {
                return (0, D.DM)(this, "paste", {}, arguments)
            }, W.prototype.clear = function () {
                return (0, D.DM)(this, "clear", {}, arguments)
            }, W.pluginName = "Clipboard", W.plugin = "cordova-clipboard", W.pluginRef = "cordova.plugins.clipboard", W.repo = "https://github.com/ihadeed/cordova-clipboard", W.platforms = ["Android", "iOS", "Windows Phone 8"], W.\u0275fac = function () {
                var Q;
                return function (ve) {
                    return (Q || (Q = ie.n5z(W)))(ve || W)
                }
            }(), W.\u0275prov = ie.Yz7({
                token: W, factory: function (Q) {
                    return W.\u0275fac(Q)
                }
            }), W
        }(D.On)
    }, 3228: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {On: () => Ce, gR: () => ae, DM: () => $e, J2: () => ce, Iq: () => I});
        var D = R(2916), ie = R(3753), te = {error: "cordova_not_available"}, j = {error: "plugin_not_installed"};

        function W(l) {
            if ("undefined" != typeof window && window.angular) {
                var g = window.document, v = window.angular.element(g.querySelector("[ng-app]") || g.body).injector();
                if (v) return v.get("$q")(function (P, B) {
                    l(P, B)
                });
                console.warn("Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.")
            }
            return function () {
                if (Promise) return new Promise(function (P, B) {
                    l(P, B)
                });
                console.error("No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.")
            }()
        }

        function Q(l, f, g, v) {
            void 0 === v && (v = {});
            var w, P, B = W(function (O, E) {
                w = v.destruct ? H(l, f, g, v, function () {
                    for (var Z = [], ze = 0; ze < arguments.length; ze++) Z[ze] = arguments[ze];
                    return O(Z)
                }, function () {
                    for (var Z = [], ze = 0; ze < arguments.length; ze++) Z[ze] = arguments[ze];
                    return E(Z)
                }) : H(l, f, g, v, O, E), P = E
            });
            return w && w.error && (B.catch(function () {
            }), "function" == typeof P && P(w.error)), B
        }

        function Ne(l, f, g, v) {
            return void 0 === v && (v = {}), W(function (w, P) {
                var B = H(l, f, g, v);
                B ? B.error ? P(B.error) : B.then && B.then(w).catch(P) : P({error: "unexpected_error"})
            })
        }

        function ve(l, f, g, v) {
            return void 0 === v && (v = {}), new D.y(function (w) {
                var P;
                return P = v.destruct ? H(l, f, g, v, function () {
                    for (var B = [], O = 0; O < arguments.length; O++) B[O] = arguments[O];
                    return w.next(B)
                }, function () {
                    for (var B = [], O = 0; O < arguments.length; O++) B[O] = arguments[O];
                    return w.error(B)
                }) : H(l, f, g, v, w.next.bind(w), w.error.bind(w)), P && P.error && (w.error(P.error), w.complete()), function () {
                    try {
                        if (v.clearFunction) return v.clearWithArgs ? H(l, v.clearFunction, g, v, w.next.bind(w), w.error.bind(w)) : H(l, v.clearFunction, [])
                    } catch (B) {
                        console.warn("Unable to clear the previous observable watch for", l.constructor.getPluginName(), f), console.warn(B)
                    }
                }
            })
        }

        function me(l, f) {
            return f = "undefined" != typeof window && f ? ge(window, f) : f || ("undefined" != typeof window ? window : {}), (0, ie.R)(f, l)
        }

        function ae(l, f, g) {
            var v, w;
            "string" == typeof l ? v = l : (v = l.constructor.getPluginRef(), g = l.constructor.getPluginName(), w = l.constructor.getPluginInstallName());
            var P = oe(v);
            return !(!P || f && void 0 === P[f]) || ("undefined" != typeof window && window.cordova ? (function Ie(l, f, g) {
                console.warn(g ? "Native: tried calling " + l + "." + g + ", but the " + l + " plugin is not installed." : "Native: tried accessing the " + l + " plugin but it's not installed."), f && console.warn("Install the " + l + " plugin: 'ionic cordova plugin add " + f + "'")
            }(g, w, f), j) : (function he(l, f) {
                "undefined" == typeof process && console.warn(f ? "Native: tried calling " + l + "." + f + ", but Cordova is not available. Make sure to include cordova.js or run in a device/simulator" : "Native: tried accessing the " + l + " plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator")
            }(g, f), te))
        }

        function H(l, f, g, v, w, P) {
            void 0 === v && (v = {}), g = function M(l, f, g, v) {
                if (void 0 === f && (f = {}), f.sync) return l;
                if ("reverse" === f.callbackOrder) l.unshift(v), l.unshift(g); else if ("node" === f.callbackStyle) l.push(function (O, E) {
                    O ? v(O) : g(E)
                }); else if ("object" === f.callbackStyle && f.successName && f.errorName) {
                    var w = {};
                    w[f.successName] = g, w[f.errorName] = v, l.push(w)
                } else if (void 0 !== f.successIndex || void 0 !== f.errorIndex) {
                    var P = function () {
                        f.successIndex > l.length ? l[f.successIndex] = g : l.splice(f.successIndex, 0, g)
                    }, B = function () {
                        f.errorIndex > l.length ? l[f.errorIndex] = v : l.splice(f.errorIndex, 0, v)
                    };
                    f.successIndex > f.errorIndex ? (B(), P()) : (P(), B())
                } else l.push(g), l.push(v);
                return l
            }(g, v, w, P);
            var B = ae(l, f);
            if (!0 === B) {
                var O = oe(l.constructor.getPluginRef());
                return O[f].apply(O, g)
            }
            return B
        }

        function oe(l) {
            return "undefined" != typeof window ? ge(window, l) : null
        }

        function ge(l, f) {
            for (var g = f.split("."), v = l, w = 0; w < g.length; w++) {
                if (!v) return null;
                v = v[g[w]]
            }
            return v
        }

        var Ce = function () {
            function l() {
            }

            return l.installed = function () {
                return !0 === ae(this.pluginRef)
            }, l.getPlugin = function () {
                return "undefined" != typeof window ? function it(l, f) {
                    for (var g = f.split("."), v = l, w = 0; w < g.length; w++) {
                        if (!v) return null;
                        v = v[g[w]]
                    }
                    return v
                }(window, this.pluginRef) : null
            }, l.getPluginName = function () {
                return this.pluginName
            }, l.getPluginRef = function () {
                return this.pluginRef
            }, l.getPluginInstallName = function () {
                return this.plugin
            }, l.getSupportedPlatforms = function () {
                return this.platforms
            }, l.pluginName = "", l.pluginRef = "", l.plugin = "", l.repo = "", l.platforms = [], l.install = "", l
        }();

        function $e(l, f, g, v) {
            return function (l, f, g) {
                return void 0 === g && (g = {}), function () {
                    for (var v = [], w = 0; w < arguments.length; w++) v[w] = arguments[w];
                    return g.sync ? H(l, f, v, g) : g.observable ? ve(l, f, v, g) : g.eventObservable && g.event ? me(g.event, g.element) : g.otherPromise ? Ne(l, f, v, g) : Q(l, f, v, g)
                }
            }(l, f, g).apply(this, v)
        }

        function ce(l, f) {
            return !0 === ae(l, f) ? oe(l.constructor.getPluginRef())[f] : null
        }

        function I(l, f, g) {
            !0 === ae(l, f) && (oe(l.constructor.getPluginRef())[f] = g)
        }

        !function r() {
            if ("undefined" == typeof process) {
                var l = "undefined" != typeof window ? window : {}, g = Date.now(), v = !1;
                l.document.addEventListener("deviceready", function () {
                    console.log("Ionic Native: deviceready event fired after " + (Date.now() - g) + " ms"), v = !0
                }), setTimeout(function () {
                    !v && l.cordova && console.warn("Ionic Native: deviceready did not fire within 5000ms. This can happen when plugins are in an inconsistent state. Try removing plugins from plugins/ and reinstalling them.")
                }, 5e3)
            }
        }()
    }, 5956: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {w: () => te});
        var r = R(655), D = R(3228), ie = R(6435), te = function (j) {
            function W() {
                return null !== j && j.apply(this, arguments) || this
            }

            return (0, r.ZT)(W, j), W.prototype.vibrate = function (Q) {
                return (0, D.DM)(this, "vibrate", {sync: !0}, arguments)
            }, W.pluginName = "Vibration", W.plugin = "cordova-plugin-vibration", W.pluginRef = "navigator", W.repo = "https://github.com/apache/cordova-plugin-vibration", W.platforms = ["Android", "iOS", "Windows"], W.\u0275fac = function () {
                var Q;
                return function (ve) {
                    return (Q || (Q = ie.n5z(W)))(ve || W)
                }
            }(), W.\u0275prov = ie.Yz7({
                token: W, factory: function (Q) {
                    return W.\u0275fac(Q)
                }
            }), W
        }(D.On)
    }, 8314: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Sg: () => Q, zt: () => ae});
        var r = R(2909), D = R(4325), ie = R(8666);
        const W = new ie.Yd("abstract-provider/5.6.1");

        class Q extends D.dk {
            static isForkEvent(M) {
                return !(!M || !M._isForkEvent)
            }
        }

        class ae {
            constructor() {
                W.checkAbstract(new.target, ae), (0, D.zG)(this, "_isProvider", !0)
            }

            getFeeData() {
                return X = this, M = void 0, F = function* () {
                    const {block: M, gasPrice: H} = yield(0, D.mE)({
                        block: this.getBlock("latest"),
                        gasPrice: this.getGasPrice().catch(ge => null)
                    });
                    let F = null, oe = null;
                    return M && M.baseFeePerGas && (oe = r.O$.from("1500000000"), F = M.baseFeePerGas.mul(2).add(oe)), {
                        maxFeePerGas: F,
                        maxPriorityFeePerGas: oe,
                        gasPrice: H
                    }
                }, new ((H = void 0) || (H = Promise))(function (ge, Ie) {
                    function he(it) {
                        try {
                            Ue(F.next(it))
                        } catch (yt) {
                            Ie(yt)
                        }
                    }

                    function xe(it) {
                        try {
                            Ue(F.throw(it))
                        } catch (yt) {
                            Ie(yt)
                        }
                    }

                    function Ue(it) {
                        it.done ? ge(it.value) : function oe(ge) {
                            return ge instanceof H ? ge : new H(function (Ie) {
                                Ie(ge)
                            })
                        }(it.value).then(he, xe)
                    }

                    Ue((F = F.apply(X, M || [])).next())
                });
                var X, M, H, F
            }

            addListener(M, H) {
                return this.on(M, H)
            }

            removeListener(M, H) {
                return this.off(M, H)
            }

            static isProvider(M) {
                return !(!M || !M._isProvider)
            }
        }
    }, 2748: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {E: () => Ne, b: () => ve});
        var r = R(4325), D = R(8666), te = function (me, ae, X, M) {
            return new (X || (X = Promise))(function (F, oe) {
                function ge(xe) {
                    try {
                        he(M.next(xe))
                    } catch (Ue) {
                        oe(Ue)
                    }
                }

                function Ie(xe) {
                    try {
                        he(M.throw(xe))
                    } catch (Ue) {
                        oe(Ue)
                    }
                }

                function he(xe) {
                    xe.done ? F(xe.value) : function H(F) {
                        return F instanceof X ? F : new X(function (oe) {
                            oe(F)
                        })
                    }(xe.value).then(ge, Ie)
                }

                he((M = M.apply(me, ae || [])).next())
            })
        };
        const j = new D.Yd("abstract-signer/5.6.2"),
            W = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
            Q = [D.Yd.errors.INSUFFICIENT_FUNDS, D.Yd.errors.NONCE_EXPIRED, D.Yd.errors.REPLACEMENT_UNDERPRICED];

        class Ne {
            constructor() {
                j.checkAbstract(new.target, Ne), (0, r.zG)(this, "_isSigner", !0)
            }

            getBalance(ae) {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), ae)
                })
            }

            getTransactionCount(ae) {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), ae)
                })
            }

            estimateGas(ae) {
                return te(this, void 0, void 0, function* () {
                    this._checkProvider("estimateGas");
                    const X = yield(0, r.mE)(this.checkTransaction(ae));
                    return yield this.provider.estimateGas(X)
                })
            }

            call(ae, X) {
                return te(this, void 0, void 0, function* () {
                    this._checkProvider("call");
                    const M = yield(0, r.mE)(this.checkTransaction(ae));
                    return yield this.provider.call(M, X)
                })
            }

            sendTransaction(ae) {
                return te(this, void 0, void 0, function* () {
                    this._checkProvider("sendTransaction");
                    const X = yield this.populateTransaction(ae), M = yield this.signTransaction(X);
                    return yield this.provider.sendTransaction(M)
                })
            }

            getChainId() {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
                })
            }

            getGasPrice() {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
                })
            }

            getFeeData() {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
                })
            }

            resolveName(ae) {
                return te(this, void 0, void 0, function* () {
                    return this._checkProvider("resolveName"), yield this.provider.resolveName(ae)
                })
            }

            checkTransaction(ae) {
                for (const M in ae) -1 === W.indexOf(M) && j.throwArgumentError("invalid transaction key: " + M, "transaction", ae);
                const X = (0, r.DC)(ae);
                return X.from = null == X.from ? this.getAddress() : Promise.all([Promise.resolve(X.from), this.getAddress()]).then(M => (M[0].toLowerCase() !== M[1].toLowerCase() && j.throwArgumentError("from address mismatch", "transaction", ae), M[0])), X
            }

            populateTransaction(ae) {
                return te(this, void 0, void 0, function* () {
                    const X = yield(0, r.mE)(this.checkTransaction(ae));
                    null != X.to && (X.to = Promise.resolve(X.to).then(H => te(this, void 0, void 0, function* () {
                        if (null == H) return null;
                        const F = yield this.resolveName(H);
                        return null == F && j.throwArgumentError("provided ENS name resolves to null", "tx.to", H), F
                    })), X.to.catch(H => {
                    }));
                    const M = null != X.maxFeePerGas || null != X.maxPriorityFeePerGas;
                    if (null == X.gasPrice || 2 !== X.type && !M ? (0 === X.type || 1 === X.type) && M && j.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", ae) : j.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", ae), 2 !== X.type && null != X.type || null == X.maxFeePerGas || null == X.maxPriorityFeePerGas) if (0 === X.type || 1 === X.type) null == X.gasPrice && (X.gasPrice = this.getGasPrice()); else {
                        const H = yield this.getFeeData();
                        if (null == X.type) if (null != H.maxFeePerGas && null != H.maxPriorityFeePerGas) if (X.type = 2, null != X.gasPrice) {
                            const F = X.gasPrice;
                            delete X.gasPrice, X.maxFeePerGas = F, X.maxPriorityFeePerGas = F
                        } else null == X.maxFeePerGas && (X.maxFeePerGas = H.maxFeePerGas), null == X.maxPriorityFeePerGas && (X.maxPriorityFeePerGas = H.maxPriorityFeePerGas); else null != H.gasPrice ? (M && j.throwError("network does not support EIP-1559", D.Yd.errors.UNSUPPORTED_OPERATION, {operation: "populateTransaction"}), null == X.gasPrice && (X.gasPrice = H.gasPrice), X.type = 0) : j.throwError("failed to get consistent fee data", D.Yd.errors.UNSUPPORTED_OPERATION, {operation: "signer.getFeeData"}); else 2 === X.type && (null == X.maxFeePerGas && (X.maxFeePerGas = H.maxFeePerGas), null == X.maxPriorityFeePerGas && (X.maxPriorityFeePerGas = H.maxPriorityFeePerGas))
                    } else X.type = 2;
                    return null == X.nonce && (X.nonce = this.getTransactionCount("pending")), null == X.gasLimit && (X.gasLimit = this.estimateGas(X).catch(H => {
                        if (Q.indexOf(H.code) >= 0) throw H;
                        return j.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", D.Yd.errors.UNPREDICTABLE_GAS_LIMIT, {
                            error: H,
                            tx: X
                        })
                    })), X.chainId = null == X.chainId ? this.getChainId() : Promise.all([Promise.resolve(X.chainId), this.getChainId()]).then(H => (0 !== H[1] && H[0] !== H[1] && j.throwArgumentError("chainId address mismatch", "transaction", ae), H[0])), yield(0, r.mE)(X)
                })
            }

            _checkProvider(ae) {
                this.provider || j.throwError("missing provider", D.Yd.errors.UNSUPPORTED_OPERATION, {operation: ae || "_checkProvider"})
            }

            static isSigner(ae) {
                return !(!ae || !ae._isSigner)
            }
        }

        class ve extends Ne {
            constructor(ae, X) {
                super(), (0, r.zG)(this, "address", ae), (0, r.zG)(this, "provider", X || null)
            }

            getAddress() {
                return Promise.resolve(this.address)
            }

            _fail(ae, X) {
                return Promise.resolve().then(() => {
                    j.throwError(ae, D.Yd.errors.UNSUPPORTED_OPERATION, {operation: X})
                })
            }

            signMessage(ae) {
                return this._fail("VoidSigner cannot sign messages", "signMessage")
            }

            signTransaction(ae) {
                return this._fail("VoidSigner cannot sign transactions", "signTransaction")
            }

            _signTypedData(ae, X, M) {
                return this._fail("VoidSigner cannot sign typed data", "signTypedData")
            }

            connect(ae) {
                return new ve(this.address, ae)
            }
        }
    }, 8016: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Kn: () => H, CR: () => ge, UJ: () => F});
        var r = R(499), D = R(2909), ie = R(2547), te = R(810);
        const Q = new (R(8666).Yd)("address/5.6.1");

        function Ne(he) {
            (0, r.A7)(he, 20) || Q.throwArgumentError("invalid address", "address", he);
            const xe = (he = he.toLowerCase()).substring(2).split(""), Ue = new Uint8Array(40);
            for (let yt = 0; yt < 40; yt++) Ue[yt] = xe[yt].charCodeAt(0);
            const it = (0, r.lE)((0, ie.w)(Ue));
            for (let yt = 0; yt < 40; yt += 2) it[yt >> 1] >> 4 >= 8 && (xe[yt] = xe[yt].toUpperCase()), (15 & it[yt >> 1]) >= 8 && (xe[yt + 1] = xe[yt + 1].toUpperCase());
            return "0x" + xe.join("")
        }

        const ae = {};
        for (let he = 0; he < 10; he++) ae[String(he)] = String(he);
        for (let he = 0; he < 26; he++) ae[String.fromCharCode(65 + he)] = String(10 + he);
        const X = Math.floor(function me(he) {
            return Math.log10 ? Math.log10(he) : Math.log(he) / Math.LN10
        }(9007199254740991));

        function H(he) {
            let xe = null;
            if ("string" != typeof he && Q.throwArgumentError("invalid address", "address", he), he.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== he.substring(0, 2) && (he = "0x" + he), xe = Ne(he), he.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && xe !== he && Q.throwArgumentError("bad address checksum", "address", he); else if (he.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                for (he.substring(2, 4) !== function M(he) {
                    let xe = (he = (he = he.toUpperCase()).substring(4) + he.substring(0, 2) + "00").split("").map(it => ae[it]).join("");
                    for (; xe.length >= X;) {
                        let it = xe.substring(0, X);
                        xe = parseInt(it, 10) % 97 + xe.substring(it.length)
                    }
                    let Ue = String(98 - parseInt(xe, 10) % 97);
                    for (; Ue.length < 2;) Ue = "0" + Ue;
                    return Ue
                }(he) && Q.throwArgumentError("bad icap checksum", "address", he), xe = (0, D.g$)(he.substring(4)); xe.length < 40;) xe = "0" + xe;
                xe = Ne("0x" + xe)
            } else Q.throwArgumentError("invalid address", "address", he);
            return xe
        }

        function F(he) {
            try {
                return H(he), !0
            } catch (xe) {
            }
            return !1
        }

        function ge(he) {
            let xe = null;
            try {
                xe = H(he.from)
            } catch (it) {
                Q.throwArgumentError("missing from address", "transaction", he)
            }
            const Ue = (0, r.G1)((0, r.lE)(D.O$.from(he.nonce).toHexString()));
            return H((0, r.p3)((0, ie.w)((0, te.c)([xe, Ue])), 12))
        }
    }, 5887: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {eU: () => j});
        var r = R(499), D = R(4325);

        class ie {
            constructor(Q) {
                (0, D.zG)(this, "alphabet", Q), (0, D.zG)(this, "base", Q.length), (0, D.zG)(this, "_alphabetMap", {}), (0, D.zG)(this, "_leader", Q.charAt(0));
                for (let Ne = 0; Ne < Q.length; Ne++) this._alphabetMap[Q.charAt(Ne)] = Ne
            }

            encode(Q) {
                let Ne = (0, r.lE)(Q);
                if (0 === Ne.length) return "";
                let ve = [0];
                for (let ae = 0; ae < Ne.length; ++ae) {
                    let X = Ne[ae];
                    for (let M = 0; M < ve.length; ++M) X += ve[M] << 8, ve[M] = X % this.base, X = X / this.base | 0;
                    for (; X > 0;) ve.push(X % this.base), X = X / this.base | 0
                }
                let me = "";
                for (let ae = 0; 0 === Ne[ae] && ae < Ne.length - 1; ++ae) me += this._leader;
                for (let ae = ve.length - 1; ae >= 0; --ae) me += this.alphabet[ve[ae]];
                return me
            }

            decode(Q) {
                if ("string" != typeof Q) throw new TypeError("Expected String");
                let Ne = [];
                if (0 === Q.length) return new Uint8Array(Ne);
                Ne.push(0);
                for (let ve = 0; ve < Q.length; ve++) {
                    let me = this._alphabetMap[Q[ve]];
                    if (void 0 === me) throw new Error("Non-base" + this.base + " character");
                    let ae = me;
                    for (let X = 0; X < Ne.length; ++X) ae += Ne[X] * this.base, Ne[X] = 255 & ae, ae >>= 8;
                    for (; ae > 0;) Ne.push(255 & ae), ae >>= 8
                }
                for (let ve = 0; Q[ve] === this._leader && ve < Q.length - 1; ++ve) Ne.push(0);
                return (0, r.lE)(new Uint8Array(Ne.reverse()))
            }
        }

        new ie("abcdefghijklmnopqrstuvwxyz234567");
        const j = new ie("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
    }, 7883: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {i: () => r});
        const r = "bignumber/5.6.2"
    }, 2909: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Zm: () => me, O$: () => X, g$: () => ge});
        var r = R(8538), D = R.n(r), ie = R(499), te = R(8666), j = R(7883), W = D().BN;
        const Q = new te.Yd(j.i), Ne = {}, ve = 9007199254740991;

        function me(he) {
            return null != he && (X.isBigNumber(he) || "number" == typeof he && he % 1 == 0 || "string" == typeof he && !!he.match(/^-?[0-9]+$/) || (0, ie.A7)(he) || "bigint" == typeof he || (0, ie._t)(he))
        }

        let ae = !1;

        class X {
            constructor(xe, Ue) {
                xe !== Ne && Q.throwError("cannot call constructor directly; use BigNumber.from", te.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new (BigNumber)"}), this._hex = Ue, this._isBigNumber = !0, Object.freeze(this)
            }

            fromTwos(xe) {
                return H(F(this).fromTwos(xe))
            }

            toTwos(xe) {
                return H(F(this).toTwos(xe))
            }

            abs() {
                return "-" === this._hex[0] ? X.from(this._hex.substring(1)) : this
            }

            add(xe) {
                return H(F(this).add(F(xe)))
            }

            sub(xe) {
                return H(F(this).sub(F(xe)))
            }

            div(xe) {
                return X.from(xe).isZero() && oe("division-by-zero", "div"), H(F(this).div(F(xe)))
            }

            mul(xe) {
                return H(F(this).mul(F(xe)))
            }

            mod(xe) {
                const Ue = F(xe);
                return Ue.isNeg() && oe("division-by-zero", "mod"), H(F(this).umod(Ue))
            }

            pow(xe) {
                const Ue = F(xe);
                return Ue.isNeg() && oe("negative-power", "pow"), H(F(this).pow(Ue))
            }

            and(xe) {
                const Ue = F(xe);
                return (this.isNegative() || Ue.isNeg()) && oe("unbound-bitwise-result", "and"), H(F(this).and(Ue))
            }

            or(xe) {
                const Ue = F(xe);
                return (this.isNegative() || Ue.isNeg()) && oe("unbound-bitwise-result", "or"), H(F(this).or(Ue))
            }

            xor(xe) {
                const Ue = F(xe);
                return (this.isNegative() || Ue.isNeg()) && oe("unbound-bitwise-result", "xor"), H(F(this).xor(Ue))
            }

            mask(xe) {
                return (this.isNegative() || xe < 0) && oe("negative-width", "mask"), H(F(this).maskn(xe))
            }

            shl(xe) {
                return (this.isNegative() || xe < 0) && oe("negative-width", "shl"), H(F(this).shln(xe))
            }

            shr(xe) {
                return (this.isNegative() || xe < 0) && oe("negative-width", "shr"), H(F(this).shrn(xe))
            }

            eq(xe) {
                return F(this).eq(F(xe))
            }

            lt(xe) {
                return F(this).lt(F(xe))
            }

            lte(xe) {
                return F(this).lte(F(xe))
            }

            gt(xe) {
                return F(this).gt(F(xe))
            }

            gte(xe) {
                return F(this).gte(F(xe))
            }

            isNegative() {
                return "-" === this._hex[0]
            }

            isZero() {
                return F(this).isZero()
            }

            toNumber() {
                try {
                    return F(this).toNumber()
                } catch (xe) {
                    oe("overflow", "toNumber", this.toString())
                }
                return null
            }

            toBigInt() {
                try {
                    return BigInt(this.toString())
                } catch (xe) {
                }
                return Q.throwError("this platform does not support BigInt", te.Yd.errors.UNSUPPORTED_OPERATION, {value: this.toString()})
            }

            toString() {
                return arguments.length > 0 && (10 === arguments[0] ? ae || (ae = !0, Q.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : Q.throwError(16 === arguments[0] ? "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()" : "BigNumber.toString does not accept parameters", te.Yd.errors.UNEXPECTED_ARGUMENT, {})), F(this).toString(10)
            }

            toHexString() {
                return this._hex
            }

            toJSON(xe) {
                return {type: "BigNumber", hex: this.toHexString()}
            }

            static from(xe) {
                if (xe instanceof X) return xe;
                if ("string" == typeof xe) return xe.match(/^-?0x[0-9a-f]+$/i) ? new X(Ne, M(xe)) : xe.match(/^-?[0-9]+$/) ? new X(Ne, M(new W(xe))) : Q.throwArgumentError("invalid BigNumber string", "value", xe);
                if ("number" == typeof xe) return xe % 1 && oe("underflow", "BigNumber.from", xe), (xe >= ve || xe <= -ve) && oe("overflow", "BigNumber.from", xe), X.from(String(xe));
                const Ue = xe;
                if ("bigint" == typeof Ue) return X.from(Ue.toString());
                if ((0, ie._t)(Ue)) return X.from((0, ie.Dv)(Ue));
                if (Ue) if (Ue.toHexString) {
                    const it = Ue.toHexString();
                    if ("string" == typeof it) return X.from(it)
                } else {
                    let it = Ue._hex;
                    if (null == it && "BigNumber" === Ue.type && (it = Ue.hex), "string" == typeof it && ((0, ie.A7)(it) || "-" === it[0] && (0, ie.A7)(it.substring(1)))) return X.from(it)
                }
                return Q.throwArgumentError("invalid BigNumber value", "value", xe)
            }

            static isBigNumber(xe) {
                return !(!xe || !xe._isBigNumber)
            }
        }

        function M(he) {
            if ("string" != typeof he) return M(he.toString(16));
            if ("-" === he[0]) return "-" === (he = he.substring(1))[0] && Q.throwArgumentError("invalid hex", "value", he), "0x00" === (he = M(he)) ? he : "-" + he;
            if ("0x" !== he.substring(0, 2) && (he = "0x" + he), "0x" === he) return "0x00";
            for (he.length % 2 && (he = "0x0" + he.substring(2)); he.length > 4 && "0x00" === he.substring(0, 4);) he = "0x" + he.substring(4);
            return he
        }

        function H(he) {
            return X.from(M(he))
        }

        function F(he) {
            const xe = X.from(he).toHexString();
            return new W("-" === xe[0] ? "-" + xe.substring(3) : xe.substring(2), 16)
        }

        function oe(he, xe, Ue) {
            const it = {fault: he, operation: xe};
            return null != Ue && (it.value = Ue), Q.throwError(he, te.Yd.errors.NUMERIC_FAULT, it)
        }

        function ge(he) {
            return new W(he, 36).toString(16)
        }
    }, 499: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            lE: () => ve,
            zo: () => me,
            xs: () => Ie,
            E1: () => oe,
            p3: () => ge,
            $P: () => he,
            $m: () => Ue,
            Dv: () => F,
            _t: () => Ne,
            Zq: () => W,
            A7: () => M,
            gV: () => yt,
            N: () => it,
            G1: () => ae
        });
        const ie = new (R(8666).Yd)("bytes/5.6.1");

        function te(Ce) {
            return !!Ce.toHexString
        }

        function j(Ce) {
            return Ce.slice || (Ce.slice = function () {
                const $e = Array.prototype.slice.call(arguments);
                return j(new Uint8Array(Array.prototype.slice.apply(Ce, $e)))
            }), Ce
        }

        function W(Ce) {
            return M(Ce) && !(Ce.length % 2) || Ne(Ce)
        }

        function Q(Ce) {
            return "number" == typeof Ce && Ce == Ce && Ce % 1 == 0
        }

        function Ne(Ce) {
            if (null == Ce) return !1;
            if (Ce.constructor === Uint8Array) return !0;
            if ("string" == typeof Ce || !Q(Ce.length) || Ce.length < 0) return !1;
            for (let $e = 0; $e < Ce.length; $e++) {
                const rt = Ce[$e];
                if (!Q(rt) || rt < 0 || rt >= 256) return !1
            }
            return !0
        }

        function ve(Ce, $e) {
            if ($e || ($e = {}), "number" == typeof Ce) {
                ie.checkSafeUint53(Ce, "invalid arrayify value");
                const rt = [];
                for (; Ce;) rt.unshift(255 & Ce), Ce = parseInt(String(Ce / 256));
                return 0 === rt.length && rt.push(0), j(new Uint8Array(rt))
            }
            if ($e.allowMissingPrefix && "string" == typeof Ce && "0x" !== Ce.substring(0, 2) && (Ce = "0x" + Ce), te(Ce) && (Ce = Ce.toHexString()), M(Ce)) {
                let rt = Ce.substring(2);
                rt.length % 2 && ("left" === $e.hexPad ? rt = "0" + rt : "right" === $e.hexPad ? rt += "0" : ie.throwArgumentError("hex data is odd-length", "value", Ce));
                const Xe = [];
                for (let Ee = 0; Ee < rt.length; Ee += 2) Xe.push(parseInt(rt.substring(Ee, Ee + 2), 16));
                return j(new Uint8Array(Xe))
            }
            return Ne(Ce) ? j(new Uint8Array(Ce)) : ie.throwArgumentError("invalid arrayify value", "value", Ce)
        }

        function me(Ce) {
            const $e = Ce.map(Ee => ve(Ee)), rt = $e.reduce((Ee, ce) => Ee + ce.length, 0), Xe = new Uint8Array(rt);
            return $e.reduce((Ee, ce) => (Xe.set(ce, Ee), Ee + ce.length), 0), j(Xe)
        }

        function ae(Ce) {
            let $e = ve(Ce);
            if (0 === $e.length) return $e;
            let rt = 0;
            for (; rt < $e.length && 0 === $e[rt];) rt++;
            return rt && ($e = $e.slice(rt)), $e
        }

        function M(Ce, $e) {
            return !("string" != typeof Ce || !Ce.match(/^0x[0-9A-Fa-f]*$/) || $e && Ce.length !== 2 + 2 * $e)
        }

        const H = "0123456789abcdef";

        function F(Ce, $e) {
            if ($e || ($e = {}), "number" == typeof Ce) {
                ie.checkSafeUint53(Ce, "invalid hexlify value");
                let rt = "";
                for (; Ce;) rt = H[15 & Ce] + rt, Ce = Math.floor(Ce / 16);
                return rt.length ? (rt.length % 2 && (rt = "0" + rt), "0x" + rt) : "0x00"
            }
            if ("bigint" == typeof Ce) return (Ce = Ce.toString(16)).length % 2 ? "0x0" + Ce : "0x" + Ce;
            if ($e.allowMissingPrefix && "string" == typeof Ce && "0x" !== Ce.substring(0, 2) && (Ce = "0x" + Ce), te(Ce)) return Ce.toHexString();
            if (M(Ce)) return Ce.length % 2 && ("left" === $e.hexPad ? Ce = "0x0" + Ce.substring(2) : "right" === $e.hexPad ? Ce += "0" : ie.throwArgumentError("hex data is odd-length", "value", Ce)), Ce.toLowerCase();
            if (Ne(Ce)) {
                let rt = "0x";
                for (let Xe = 0; Xe < Ce.length; Xe++) {
                    let Ee = Ce[Xe];
                    rt += H[(240 & Ee) >> 4] + H[15 & Ee]
                }
                return rt
            }
            return ie.throwArgumentError("invalid hexlify value", "value", Ce)
        }

        function oe(Ce) {
            if ("string" != typeof Ce) Ce = F(Ce); else if (!M(Ce) || Ce.length % 2) return null;
            return (Ce.length - 2) / 2
        }

        function ge(Ce, $e, rt) {
            return "string" != typeof Ce ? Ce = F(Ce) : (!M(Ce) || Ce.length % 2) && ie.throwArgumentError("invalid hexData", "value", Ce), $e = 2 + 2 * $e, null != rt ? "0x" + Ce.substring($e, 2 + 2 * rt) : "0x" + Ce.substring($e)
        }

        function Ie(Ce) {
            let $e = "0x";
            return Ce.forEach(rt => {
                $e += F(rt).substring(2)
            }), $e
        }

        function he(Ce) {
            const $e = function xe(Ce) {
                "string" != typeof Ce && (Ce = F(Ce)), M(Ce) || ie.throwArgumentError("invalid hex string", "value", Ce), Ce = Ce.substring(2);
                let $e = 0;
                for (; $e < Ce.length && "0" === Ce[$e];) $e++;
                return "0x" + Ce.substring($e)
            }(F(Ce, {hexPad: "left"}));
            return "0x" === $e ? "0x0" : $e
        }

        function Ue(Ce, $e) {
            for ("string" != typeof Ce ? Ce = F(Ce) : M(Ce) || ie.throwArgumentError("invalid hex string", "value", Ce), Ce.length > 2 * $e + 2 && ie.throwArgumentError("value out of range", "value", arguments[1]); Ce.length < 2 * $e + 2;) Ce = "0x0" + Ce.substring(2);
            return Ce
        }

        function it(Ce) {
            const $e = {r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0, yParityAndS: "0x", compact: "0x"};
            if (W(Ce)) {
                let rt = ve(Ce);
                64 === rt.length ? ($e.v = 27 + (rt[32] >> 7), rt[32] &= 127, $e.r = F(rt.slice(0, 32)), $e.s = F(rt.slice(32, 64))) : 65 === rt.length ? ($e.r = F(rt.slice(0, 32)), $e.s = F(rt.slice(32, 64)), $e.v = rt[64]) : ie.throwArgumentError("invalid signature string", "signature", Ce), $e.v < 27 && (0 === $e.v || 1 === $e.v ? $e.v += 27 : ie.throwArgumentError("signature invalid v byte", "signature", Ce)), $e.recoveryParam = 1 - $e.v % 2, $e.recoveryParam && (rt[32] |= 128), $e._vs = F(rt.slice(32, 64))
            } else {
                if ($e.r = Ce.r, $e.s = Ce.s, $e.v = Ce.v, $e.recoveryParam = Ce.recoveryParam, $e._vs = Ce._vs, null != $e._vs) {
                    const Ee = function X(Ce, $e) {
                        (Ce = ve(Ce)).length > $e && ie.throwArgumentError("value out of range", "value", arguments[0]);
                        const rt = new Uint8Array($e);
                        return rt.set(Ce, $e - Ce.length), j(rt)
                    }(ve($e._vs), 32);
                    $e._vs = F(Ee);
                    const ce = Ee[0] >= 128 ? 1 : 0;
                    null == $e.recoveryParam ? $e.recoveryParam = ce : $e.recoveryParam !== ce && ie.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Ce), Ee[0] &= 127;
                    const I = F(Ee);
                    null == $e.s ? $e.s = I : $e.s !== I && ie.throwArgumentError("signature v mismatch _vs", "signature", Ce)
                }
                null == $e.recoveryParam ? null == $e.v ? ie.throwArgumentError("signature missing v and recoveryParam", "signature", Ce) : $e.recoveryParam = 0 === $e.v || 1 === $e.v ? $e.v : 1 - $e.v % 2 : null == $e.v ? $e.v = 27 + $e.recoveryParam : $e.recoveryParam !== (0 === $e.v || 1 === $e.v ? $e.v : 1 - $e.v % 2) && ie.throwArgumentError("signature recoveryParam mismatch v", "signature", Ce), null != $e.r && M($e.r) ? $e.r = Ue($e.r, 32) : ie.throwArgumentError("signature missing or invalid r", "signature", Ce), null != $e.s && M($e.s) ? $e.s = Ue($e.s, 32) : ie.throwArgumentError("signature missing or invalid s", "signature", Ce);
                const rt = ve($e.s);
                rt[0] >= 128 && ie.throwArgumentError("signature s out of range", "signature", Ce), $e.recoveryParam && (rt[0] |= 128);
                const Xe = F(rt);
                $e._vs && (M($e._vs) || ie.throwArgumentError("signature invalid _vs", "signature", Ce), $e._vs = Ue($e._vs, 32)), null == $e._vs ? $e._vs = Xe : $e._vs !== Xe && ie.throwArgumentError("signature _vs mismatch v and s", "signature", Ce)
            }
            return $e.yParityAndS = $e._vs, $e.compact = $e.r + $e.yParityAndS.substring(2), $e
        }

        function yt(Ce) {
            return F(me([(Ce = it(Ce)).r, Ce.s, Ce.recoveryParam ? "0x1c" : "0x1b"]))
        }
    }, 3037: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {tL: () => D, _Y: () => ie, fh: () => te, Bz: () => Q});
        var r = R(2909);
        const D = r.O$.from(-1), ie = r.O$.from(0), te = r.O$.from(1),
            Q = r.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
    }, 3198: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {i: () => r});
        const r = "hash/5.6.1"
    }, 6171: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {id: () => ie});
        var r = R(2547), D = R(3544);

        function ie(te) {
            return (0, r.w)((0, D.Y0)(te))
        }
    }, 687: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {E: () => $e});
        var r = R(8016), D = R(2909), ie = R(499), te = R(2547), j = R(4325), W = R(8666), Q = R(3198), Ne = R(6171);
        const me = new W.Yd(Q.i), ae = new Uint8Array(32);
        ae.fill(0);
        const X = D.O$.from(-1), M = D.O$.from(0), H = D.O$.from(1),
            F = D.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
            ge = (0, ie.$m)(H.toHexString(), 32), Ie = (0, ie.$m)(M.toHexString(), 32),
            he = {name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32"},
            xe = ["name", "version", "chainId", "verifyingContract", "salt"];

        function Ue(rt) {
            return function (Xe) {
                return "string" != typeof Xe && me.throwArgumentError(`invalid domain value for ${JSON.stringify(rt)}`, `domain.${rt}`, Xe), Xe
            }
        }

        const it = {
            name: Ue("name"), version: Ue("version"), chainId: function (rt) {
                try {
                    return D.O$.from(rt).toString()
                } catch (Xe) {
                }
                return me.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", rt)
            }, verifyingContract: function (rt) {
                try {
                    return (0, r.Kn)(rt).toLowerCase()
                } catch (Xe) {
                }
                return me.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", rt)
            }, salt: function (rt) {
                try {
                    const Xe = (0, ie.lE)(rt);
                    if (32 !== Xe.length) throw new Error("bad length");
                    return (0, ie.Dv)(Xe)
                } catch (Xe) {
                }
                return me.throwArgumentError('invalid domain value "salt"', "domain.salt", rt)
            }
        };

        function yt(rt) {
            {
                const Xe = rt.match(/^(u?)int(\d*)$/);
                if (Xe) {
                    const Ee = "" === Xe[1], ce = parseInt(Xe[2] || "256");
                    (ce % 8 != 0 || ce > 256 || Xe[2] && Xe[2] !== String(ce)) && me.throwArgumentError("invalid numeric width", "type", rt);
                    const I = F.mask(Ee ? ce - 1 : ce), l = Ee ? I.add(H).mul(X) : M;
                    return function (f) {
                        const g = D.O$.from(f);
                        return (g.lt(l) || g.gt(I)) && me.throwArgumentError(`value out-of-bounds for ${rt}`, "value", f), (0, ie.$m)(g.toTwos(256).toHexString(), 32)
                    }
                }
            }
            {
                const Xe = rt.match(/^bytes(\d+)$/);
                if (Xe) {
                    const Ee = parseInt(Xe[1]);
                    return (0 === Ee || Ee > 32 || Xe[1] !== String(Ee)) && me.throwArgumentError("invalid bytes width", "type", rt), function (ce) {
                        return (0, ie.lE)(ce).length !== Ee && me.throwArgumentError(`invalid length for ${rt}`, "value", ce), function oe(rt) {
                            const Xe = (0, ie.lE)(rt), Ee = Xe.length % 32;
                            return Ee ? (0, ie.xs)([Xe, ae.slice(Ee)]) : (0, ie.Dv)(Xe)
                        }(ce)
                    }
                }
            }
            switch (rt) {
                case"address":
                    return function (Xe) {
                        return (0, ie.$m)((0, r.Kn)(Xe), 32)
                    };
                case"bool":
                    return function (Xe) {
                        return Xe ? ge : Ie
                    };
                case"bytes":
                    return function (Xe) {
                        return (0, te.w)(Xe)
                    };
                case"string":
                    return function (Xe) {
                        return (0, Ne.id)(Xe)
                    }
            }
            return null
        }

        function Ce(rt, Xe) {
            return `${rt}(${Xe.map(({name: Ee, type: ce}) => ce + " " + Ee).join(",")})`
        }

        class $e {
            constructor(Xe) {
                (0, j.zG)(this, "types", Object.freeze((0, j.p$)(Xe))), (0, j.zG)(this, "_encoderCache", {}), (0, j.zG)(this, "_types", {});
                const Ee = {}, ce = {}, I = {};
                Object.keys(Xe).forEach(g => {
                    Ee[g] = {}, ce[g] = [], I[g] = {}
                });
                for (const g in Xe) {
                    const v = {};
                    Xe[g].forEach(w => {
                        v[w.name] && me.throwArgumentError(`duplicate variable name ${JSON.stringify(w.name)} in ${JSON.stringify(g)}`, "types", Xe), v[w.name] = !0;
                        const P = w.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                        P === g && me.throwArgumentError(`circular type reference to ${JSON.stringify(P)}`, "types", Xe), !yt(P) && (ce[P] || me.throwArgumentError(`unknown type ${JSON.stringify(P)}`, "types", Xe), ce[P].push(g), Ee[g][P] = !0)
                    })
                }
                const l = Object.keys(ce).filter(g => 0 === ce[g].length);
                0 === l.length ? me.throwArgumentError("missing primary type", "types", Xe) : l.length > 1 && me.throwArgumentError(`ambiguous primary types or unused types: ${l.map(g => JSON.stringify(g)).join(", ")}`, "types", Xe), (0, j.zG)(this, "primaryType", l[0]), function f(g, v) {
                    v[g] && me.throwArgumentError(`circular type reference to ${JSON.stringify(g)}`, "types", Xe), v[g] = !0, Object.keys(Ee[g]).forEach(w => {
                        !ce[w] || (f(w, v), Object.keys(v).forEach(P => {
                            I[P][w] = !0
                        }))
                    }), delete v[g]
                }(this.primaryType, {});
                for (const g in I) {
                    const v = Object.keys(I[g]);
                    v.sort(), this._types[g] = Ce(g, Xe[g]) + v.map(w => Ce(w, Xe[w])).join("")
                }
            }

            getEncoder(Xe) {
                let Ee = this._encoderCache[Xe];
                return Ee || (Ee = this._encoderCache[Xe] = this._getEncoder(Xe)), Ee
            }

            _getEncoder(Xe) {
                {
                    const I = yt(Xe);
                    if (I) return I
                }
                const Ee = Xe.match(/^(.*)(\x5b(\d*)\x5d)$/);
                if (Ee) {
                    const I = Ee[1], l = this.getEncoder(I), f = parseInt(Ee[3]);
                    return g => {
                        f >= 0 && g.length !== f && me.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", g);
                        let v = g.map(l);
                        return this._types[I] && (v = v.map(te.w)), (0, te.w)((0, ie.xs)(v))
                    }
                }
                const ce = this.types[Xe];
                if (ce) {
                    const I = (0, Ne.id)(this._types[Xe]);
                    return l => {
                        const f = ce.map(({name: g, type: v}) => {
                            const w = this.getEncoder(v)(l[g]);
                            return this._types[v] ? (0, te.w)(w) : w
                        });
                        return f.unshift(I), (0, ie.xs)(f)
                    }
                }
                return me.throwArgumentError(`unknown type: ${Xe}`, "type", Xe)
            }

            encodeType(Xe) {
                const Ee = this._types[Xe];
                return Ee || me.throwArgumentError(`unknown type: ${JSON.stringify(Xe)}`, "name", Xe), Ee
            }

            encodeData(Xe, Ee) {
                return this.getEncoder(Xe)(Ee)
            }

            hashStruct(Xe, Ee) {
                return (0, te.w)(this.encodeData(Xe, Ee))
            }

            encode(Xe) {
                return this.encodeData(this.primaryType, Xe)
            }

            hash(Xe) {
                return this.hashStruct(this.primaryType, Xe)
            }

            _visit(Xe, Ee, ce) {
                if (yt(Xe)) return ce(Xe, Ee);
                const I = Xe.match(/^(.*)(\x5b(\d*)\x5d)$/);
                if (I) {
                    const f = I[1], g = parseInt(I[3]);
                    return g >= 0 && Ee.length !== g && me.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", Ee), Ee.map(v => this._visit(f, v, ce))
                }
                const l = this.types[Xe];
                return l ? l.reduce((f, {
                    name: g,
                    type: v
                }) => (f[g] = this._visit(v, Ee[g], ce), f), {}) : me.throwArgumentError(`unknown type: ${Xe}`, "type", Xe)
            }

            visit(Xe, Ee) {
                return this._visit(this.primaryType, Xe, Ee)
            }

            static from(Xe) {
                return new $e(Xe)
            }

            static getPrimaryType(Xe) {
                return $e.from(Xe).primaryType
            }

            static hashStruct(Xe, Ee, ce) {
                return $e.from(Ee).hashStruct(Xe, ce)
            }

            static hashDomain(Xe) {
                const Ee = [];
                for (const ce in Xe) {
                    const I = he[ce];
                    I || me.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(ce)}`, "domain", Xe), Ee.push({
                        name: ce,
                        type: I
                    })
                }
                return Ee.sort((ce, I) => xe.indexOf(ce.name) - xe.indexOf(I.name)), $e.hashStruct("EIP712Domain", {EIP712Domain: Ee}, Xe)
            }

            static encode(Xe, Ee, ce) {
                return (0, ie.xs)(["0x1901", $e.hashDomain(Xe), $e.from(Ee).hash(ce)])
            }

            static hash(Xe, Ee, ce) {
                return (0, te.w)($e.encode(Xe, Ee, ce))
            }

            static resolveNames(Xe, Ee, ce, I) {
                return function (rt, Xe, Ee, ce) {
                    return new (Ee || (Ee = Promise))(function (l, f) {
                        function g(P) {
                            try {
                                w(ce.next(P))
                            } catch (B) {
                                f(B)
                            }
                        }

                        function v(P) {
                            try {
                                w(ce.throw(P))
                            } catch (B) {
                                f(B)
                            }
                        }

                        function w(P) {
                            P.done ? l(P.value) : function I(l) {
                                return l instanceof Ee ? l : new Ee(function (f) {
                                    f(l)
                                })
                            }(P.value).then(g, v)
                        }

                        w((ce = ce.apply(rt, Xe || [])).next())
                    })
                }(this, void 0, void 0, function* () {
                    Xe = (0, j.DC)(Xe);
                    const l = {};
                    Xe.verifyingContract && !(0, ie.A7)(Xe.verifyingContract, 20) && (l[Xe.verifyingContract] = "0x");
                    const f = $e.from(Ee);
                    f.visit(ce, (g, v) => ("address" === g && !(0, ie.A7)(v, 20) && (l[v] = "0x"), v));
                    for (const g in l) l[g] = yield I(g);
                    return Xe.verifyingContract && l[Xe.verifyingContract] && (Xe.verifyingContract = l[Xe.verifyingContract]), ce = f.visit(ce, (g, v) => "address" === g && l[v] ? l[v] : v), {
                        domain: Xe,
                        value: ce
                    }
                })
            }

            static getPayload(Xe, Ee, ce) {
                $e.hashDomain(Xe);
                const I = {}, l = [];
                xe.forEach(v => {
                    const w = Xe[v];
                    null != w && (I[v] = it[v](w), l.push({name: v, type: he[v]}))
                });
                const f = $e.from(Ee), g = (0, j.DC)(Ee);
                return g.EIP712Domain ? me.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", Ee) : g.EIP712Domain = l, f.encode(ce), {
                    types: g,
                    domain: I,
                    primaryType: f.primaryType,
                    message: f.visit(ce, (v, w) => {
                        if (v.match(/^bytes(\d*)/)) return (0, ie.Dv)((0, ie.lE)(w));
                        if (v.match(/^u?int/)) return D.O$.from(w).toString();
                        switch (v) {
                            case"address":
                                return w.toLowerCase();
                            case"bool":
                                return !!w;
                            case"string":
                                return "string" != typeof w && me.throwArgumentError("invalid string", "value", w), w
                        }
                        return me.throwArgumentError("unsupported type", "type", v)
                    })
                }
            }
        }
    }, 2547: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {w: () => te});
        var r = R(4237), D = R.n(r), ie = R(499);

        function te(j) {
            return "0x" + D().keccak_256((0, ie.lE)(j))
        }
    }, 8666: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Yd: () => X});
        let D = !1, ie = !1;
        const te = {debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5};
        let j = te.default, W = null;
        const Ne = function Q() {
            try {
                const M = [];
                if (["NFD", "NFC", "NFKD", "NFKC"].forEach(H => {
                    try {
                        if ("test" !== "test".normalize(H)) throw new Error("bad normalize")
                    } catch (F) {
                        M.push(H)
                    }
                }), M.length) throw new Error("missing " + M.join(", "));
                if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
            } catch (M) {
                return M.message
            }
            return null
        }();
        var ve = (() => {
            return (M = ve || (ve = {})).DEBUG = "DEBUG", M.INFO = "INFO", M.WARNING = "WARNING", M.ERROR = "ERROR", M.OFF = "OFF", ve;
            var M
        })(), me = (() => {
            return (M = me || (me = {})).UNKNOWN_ERROR = "UNKNOWN_ERROR", M.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", M.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", M.NETWORK_ERROR = "NETWORK_ERROR", M.SERVER_ERROR = "SERVER_ERROR", M.TIMEOUT = "TIMEOUT", M.BUFFER_OVERRUN = "BUFFER_OVERRUN", M.NUMERIC_FAULT = "NUMERIC_FAULT", M.MISSING_NEW = "MISSING_NEW", M.INVALID_ARGUMENT = "INVALID_ARGUMENT", M.MISSING_ARGUMENT = "MISSING_ARGUMENT", M.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", M.CALL_EXCEPTION = "CALL_EXCEPTION", M.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", M.NONCE_EXPIRED = "NONCE_EXPIRED", M.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", M.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", M.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", me;
            var M
        })();
        const ae = "0123456789abcdef";
        let X = (() => {
            class M {
                constructor(F) {
                    Object.defineProperty(this, "version", {enumerable: !0, value: F, writable: !1})
                }

                _log(F, oe) {
                    const ge = F.toLowerCase();
                    null == te[ge] && this.throwArgumentError("invalid log level name", "logLevel", F), !(j > te[ge]) && console.log.apply(console, oe)
                }

                debug(...F) {
                    this._log(M.levels.DEBUG, F)
                }

                info(...F) {
                    this._log(M.levels.INFO, F)
                }

                warn(...F) {
                    this._log(M.levels.WARNING, F)
                }

                makeError(F, oe, ge) {
                    if (ie) return this.makeError("censored error", oe, {});
                    oe || (oe = M.errors.UNKNOWN_ERROR), ge || (ge = {});
                    const Ie = [];
                    Object.keys(ge).forEach(it => {
                        const yt = ge[it];
                        try {
                            if (yt instanceof Uint8Array) {
                                let Ce = "";
                                for (let $e = 0; $e < yt.length; $e++) Ce += ae[yt[$e] >> 4], Ce += ae[15 & yt[$e]];
                                Ie.push(it + "=Uint8Array(0x" + Ce + ")")
                            } else Ie.push(it + "=" + JSON.stringify(yt))
                        } catch (Ce) {
                            Ie.push(it + "=" + JSON.stringify(ge[it].toString()))
                        }
                    }), Ie.push(`code=${oe}`), Ie.push(`version=${this.version}`);
                    const he = F;
                    let xe = "";
                    switch (oe) {
                        case me.NUMERIC_FAULT: {
                            xe = "NUMERIC_FAULT";
                            const it = F;
                            switch (it) {
                                case"overflow":
                                case"underflow":
                                case"division-by-zero":
                                    xe += "-" + it;
                                    break;
                                case"negative-power":
                                case"negative-width":
                                    xe += "-unsupported";
                                    break;
                                case"unbound-bitwise-result":
                                    xe += "-unbound-result"
                            }
                            break
                        }
                        case me.CALL_EXCEPTION:
                        case me.INSUFFICIENT_FUNDS:
                        case me.MISSING_NEW:
                        case me.NONCE_EXPIRED:
                        case me.REPLACEMENT_UNDERPRICED:
                        case me.TRANSACTION_REPLACED:
                        case me.UNPREDICTABLE_GAS_LIMIT:
                            xe = oe
                    }
                    xe && (F += " [ See: https://links.ethers.org/v5-errors-" + xe + " ]"), Ie.length && (F += " (" + Ie.join(", ") + ")");
                    const Ue = new Error(F);
                    return Ue.reason = he, Ue.code = oe, Object.keys(ge).forEach(function (it) {
                        Ue[it] = ge[it]
                    }), Ue
                }

                throwError(F, oe, ge) {
                    throw this.makeError(F, oe, ge)
                }

                throwArgumentError(F, oe, ge) {
                    return this.throwError(F, M.errors.INVALID_ARGUMENT, {argument: oe, value: ge})
                }

                assert(F, oe, ge, Ie) {
                    F || this.throwError(oe, ge, Ie)
                }

                assertArgument(F, oe, ge, Ie) {
                    F || this.throwArgumentError(oe, ge, Ie)
                }

                checkNormalize(F) {
                    null == F && (F = "platform missing String.prototype.normalize"), Ne && this.throwError("platform missing String.prototype.normalize", M.errors.UNSUPPORTED_OPERATION, {
                        operation: "String.prototype.normalize",
                        form: Ne
                    })
                }

                checkSafeUint53(F, oe) {
                    "number" == typeof F && (null == oe && (oe = "value not safe"), (F < 0 || F >= 9007199254740991) && this.throwError(oe, M.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "out-of-safe-range",
                        value: F
                    }), F % 1 && this.throwError(oe, M.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "non-integer",
                        value: F
                    }))
                }

                checkArgumentCount(F, oe, ge) {
                    ge = ge ? ": " + ge : "", F < oe && this.throwError("missing argument" + ge, M.errors.MISSING_ARGUMENT, {
                        count: F,
                        expectedCount: oe
                    }), F > oe && this.throwError("too many arguments" + ge, M.errors.UNEXPECTED_ARGUMENT, {
                        count: F,
                        expectedCount: oe
                    })
                }

                checkNew(F, oe) {
                    (F === Object || null == F) && this.throwError("missing new", M.errors.MISSING_NEW, {name: oe.name})
                }

                checkAbstract(F, oe) {
                    F === oe ? this.throwError("cannot instantiate abstract class " + JSON.stringify(oe.name) + " directly; use a sub-class", M.errors.UNSUPPORTED_OPERATION, {
                        name: F.name,
                        operation: "new"
                    }) : (F === Object || null == F) && this.throwError("missing new", M.errors.MISSING_NEW, {name: oe.name})
                }

                static globalLogger() {
                    return W || (W = new M("logger/5.6.0")), W
                }

                static setCensorship(F, oe) {
                    if (!F && oe && this.globalLogger().throwError("cannot permanently disable censorship", M.errors.UNSUPPORTED_OPERATION, {operation: "setCensorship"}), D) {
                        if (!F) return;
                        this.globalLogger().throwError("error censorship permanent", M.errors.UNSUPPORTED_OPERATION, {operation: "setCensorship"})
                    }
                    ie = !!F, D = !!oe
                }

                static setLogLevel(F) {
                    const oe = te[F.toLowerCase()];
                    null != oe ? j = oe : M.globalLogger().warn("invalid log level - " + F)
                }

                static from(F) {
                    return new M(F)
                }
            }

            return M.errors = me, M.levels = ve, M
        })()
    }, 4325: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {dk: () => H, uj: () => Ne, p$: () => M, zG: () => j, tu: () => W, mE: () => Q, DC: () => ve});
        var r = R(8666);
        const te = new r.Yd("properties/5.6.0");

        function j(F, oe, ge) {
            Object.defineProperty(F, oe, {enumerable: !0, value: ge, writable: !1})
        }

        function W(F, oe) {
            for (let ge = 0; ge < 32; ge++) {
                if (F[oe]) return F[oe];
                if (!F.prototype || "object" != typeof F.prototype) break;
                F = Object.getPrototypeOf(F.prototype).constructor
            }
            return null
        }

        function Q(F) {
            return function (F, oe, ge, Ie) {
                return new (ge || (ge = Promise))(function (xe, Ue) {
                    function it($e) {
                        try {
                            Ce(Ie.next($e))
                        } catch (rt) {
                            Ue(rt)
                        }
                    }

                    function yt($e) {
                        try {
                            Ce(Ie.throw($e))
                        } catch (rt) {
                            Ue(rt)
                        }
                    }

                    function Ce($e) {
                        $e.done ? xe($e.value) : function he(xe) {
                            return xe instanceof ge ? xe : new ge(function (Ue) {
                                Ue(xe)
                            })
                        }($e.value).then(it, yt)
                    }

                    Ce((Ie = Ie.apply(F, oe || [])).next())
                })
            }(this, void 0, void 0, function* () {
                const oe = Object.keys(F).map(Ie => Promise.resolve(F[Ie]).then(xe => ({key: Ie, value: xe})));
                return (yield Promise.all(oe)).reduce((Ie, he) => (Ie[he.key] = he.value, Ie), {})
            })
        }

        function Ne(F, oe) {
            (!F || "object" != typeof F) && te.throwArgumentError("invalid object", "object", F), Object.keys(F).forEach(ge => {
                oe[ge] || te.throwArgumentError("invalid object key - " + ge, "transaction:" + ge, F)
            })
        }

        function ve(F) {
            const oe = {};
            for (const ge in F) oe[ge] = F[ge];
            return oe
        }

        const me = {bigint: !0, boolean: !0, function: !0, number: !0, string: !0};

        function ae(F) {
            if (null == F || me[typeof F]) return !0;
            if (Array.isArray(F) || "object" == typeof F) {
                if (!Object.isFrozen(F)) return !1;
                const oe = Object.keys(F);
                for (let ge = 0; ge < oe.length; ge++) {
                    let Ie = null;
                    try {
                        Ie = F[oe[ge]]
                    } catch (he) {
                        continue
                    }
                    if (!ae(Ie)) return !1
                }
                return !0
            }
            return te.throwArgumentError("Cannot deepCopy " + typeof F, "object", F)
        }

        function X(F) {
            if (ae(F)) return F;
            if (Array.isArray(F)) return Object.freeze(F.map(oe => M(oe)));
            if ("object" == typeof F) {
                const oe = {};
                for (const ge in F) {
                    const Ie = F[ge];
                    void 0 !== Ie && j(oe, ge, M(Ie))
                }
                return oe
            }
            return te.throwArgumentError("Cannot deepCopy " + typeof F, "object", F)
        }

        function M(F) {
            return X(F)
        }

        class H {
            constructor(oe) {
                for (const ge in oe) this[ge] = M(oe[ge])
            }
        }
    }, 810: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {J: () => ae, c: () => Ne});
        var r = R(499), D = R(8666);
        const te = new D.Yd("rlp/5.6.1");

        function j(X) {
            const M = [];
            for (; X;) M.unshift(255 & X), X >>= 8;
            return M
        }

        function W(X, M, H) {
            let F = 0;
            for (let oe = 0; oe < H; oe++) F = 256 * F + X[M + oe];
            return F
        }

        function Q(X) {
            if (Array.isArray(X)) {
                let F = [];
                if (X.forEach(function (ge) {
                    F = F.concat(Q(ge))
                }), F.length <= 55) return F.unshift(192 + F.length), F;
                const oe = j(F.length);
                return oe.unshift(247 + oe.length), oe.concat(F)
            }
            (0, r.Zq)(X) || te.throwArgumentError("RLP object must be BytesLike", "object", X);
            const M = Array.prototype.slice.call((0, r.lE)(X));
            if (1 === M.length && M[0] <= 127) return M;
            if (M.length <= 55) return M.unshift(128 + M.length), M;
            const H = j(M.length);
            return H.unshift(183 + H.length), H.concat(M)
        }

        function Ne(X) {
            return (0, r.Dv)(Q(X))
        }

        function ve(X, M, H, F) {
            const oe = [];
            for (; H < M + 1 + F;) {
                const ge = me(X, H);
                oe.push(ge.result), (H += ge.consumed) > M + 1 + F && te.throwError("child data too short", D.Yd.errors.BUFFER_OVERRUN, {})
            }
            return {consumed: 1 + F, result: oe}
        }

        function me(X, M) {
            if (0 === X.length && te.throwError("data too short", D.Yd.errors.BUFFER_OVERRUN, {}), X[M] >= 248) {
                const H = X[M] - 247;
                M + 1 + H > X.length && te.throwError("data short segment too short", D.Yd.errors.BUFFER_OVERRUN, {});
                const F = W(X, M + 1, H);
                return M + 1 + H + F > X.length && te.throwError("data long segment too short", D.Yd.errors.BUFFER_OVERRUN, {}), ve(X, M, M + 1 + H, H + F)
            }
            if (X[M] >= 192) {
                const H = X[M] - 192;
                return M + 1 + H > X.length && te.throwError("data array too short", D.Yd.errors.BUFFER_OVERRUN, {}), ve(X, M, M + 1, H)
            }
            if (X[M] >= 184) {
                const H = X[M] - 183;
                M + 1 + H > X.length && te.throwError("data array too short", D.Yd.errors.BUFFER_OVERRUN, {});
                const F = W(X, M + 1, H);
                return M + 1 + H + F > X.length && te.throwError("data array too short", D.Yd.errors.BUFFER_OVERRUN, {}), {
                    consumed: 1 + H + F,
                    result: (0, r.Dv)(X.slice(M + 1 + H, M + 1 + H + F))
                }
            }
            if (X[M] >= 128) {
                const H = X[M] - 128;
                return M + 1 + H > X.length && te.throwError("data too short", D.Yd.errors.BUFFER_OVERRUN, {}), {
                    consumed: 1 + H,
                    result: (0, r.Dv)(X.slice(M + 1, M + 1 + H))
                }
            }
            return {consumed: 1, result: (0, r.Dv)(X[M])}
        }

        function ae(X) {
            const M = (0, r.lE)(X), H = me(M, 0);
            return H.consumed !== M.length && te.throwArgumentError("invalid rlp data", "data", X), H.result
        }
    }, 1871: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Gy: () => ae, bP: () => Ne, JQ: () => ve});
        var r = R(7084), D = R.n(r), ie = R(499), te = R(5587), j = R(8666);
        const Q = new j.Yd("sha2/5.6.1");

        function Ne(X) {
            return "0x" + D().ripemd160().update((0, ie.lE)(X)).digest("hex")
        }

        function ve(X) {
            return "0x" + D().sha256().update((0, ie.lE)(X)).digest("hex")
        }

        function ae(X, M, H) {
            return te.p[X] || Q.throwError("unsupported algorithm " + X, j.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "hmac",
                algorithm: X
            }), "0x" + D().hmac(D()[X], (0, ie.lE)(M)).update((0, ie.lE)(H)).digest("hex")
        }
    }, 5587: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {p: () => r});
        var r = (() => {
            return (D = r || (r = {})).sha256 = "sha256", D.sha512 = "sha512", r;
            var D
        })()
    }, 3126: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Et: () => wn, VW: () => On, LO: () => Nn});
        var r = R(8538), D = R.n(r), ie = R(7084), te = R.n(ie);

        function Q(Me, ne, U) {
            return Me(U = {
                path: ne, exports: {}, require: function (de, Ze) {
                    return function ae() {
                        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
                    }()
                }
            }, U.exports), U.exports
        }

        "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
        var X = M;

        function M(Me, ne) {
            if (!Me) throw new Error(ne || "Assertion failed")
        }

        M.equal = function (ne, U, de) {
            if (ne != U) throw new Error(de || "Assertion failed: " + ne + " != " + U)
        };
        var H = Q(function (Me, ne) {
            var U = ne;

            function Ze(ye) {
                return 1 === ye.length ? "0" + ye : ye
            }

            function Ge(ye) {
                for (var Te = "", Be = 0; Be < ye.length; Be++) Te += Ze(ye[Be].toString(16));
                return Te
            }

            U.toArray = function de(ye, Te) {
                if (Array.isArray(ye)) return ye.slice();
                if (!ye) return [];
                var Be = [];
                if ("string" != typeof ye) {
                    for (var tt = 0; tt < ye.length; tt++) Be[tt] = 0 | ye[tt];
                    return Be
                }
                if ("hex" === Te) for ((ye = ye.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (ye = "0" + ye), tt = 0; tt < ye.length; tt += 2) Be.push(parseInt(ye[tt] + ye[tt + 1], 16)); else for (tt = 0; tt < ye.length; tt++) {
                    var Dt = ye.charCodeAt(tt), Ft = Dt >> 8, zt = 255 & Dt;
                    Ft ? Be.push(Ft, zt) : Be.push(zt)
                }
                return Be
            }, U.zero2 = Ze, U.toHex = Ge, U.encode = function (Te, Be) {
                return "hex" === Be ? Ge(Te) : Te
            }
        }), F = Q(function (Me, ne) {
            var U = ne;
            U.assert = X, U.toArray = H.toArray, U.zero2 = H.zero2, U.toHex = H.toHex, U.encode = H.encode, U.getNAF = function de(Be, tt, Dt) {
                var Ft = new Array(Math.max(Be.bitLength(), Dt) + 1);
                Ft.fill(0);
                for (var zt = 1 << tt + 1, dn = Be.clone(), Bt = 0; Bt < Ft.length; Bt++) {
                    var Ht, bn = dn.andln(zt - 1);
                    dn.isOdd() ? dn.isubn(Ht = bn > (zt >> 1) - 1 ? (zt >> 1) - bn : bn) : Ht = 0, Ft[Bt] = Ht, dn.iushrn(1)
                }
                return Ft
            }, U.getJSF = function Ze(Be, tt) {
                var Dt = [[], []];
                Be = Be.clone(), tt = tt.clone();
                for (var dn, Ft = 0, zt = 0; Be.cmpn(-Ft) > 0 || tt.cmpn(-zt) > 0;) {
                    var bn, fn, Bt = Be.andln(3) + Ft & 3, Ht = tt.andln(3) + zt & 3;
                    3 === Bt && (Bt = -1), 3 === Ht && (Ht = -1), bn = 0 == (1 & Bt) ? 0 : 3 != (dn = Be.andln(7) + Ft & 7) && 5 !== dn || 2 !== Ht ? Bt : -Bt, Dt[0].push(bn), fn = 0 == (1 & Ht) ? 0 : 3 != (dn = tt.andln(7) + zt & 7) && 5 !== dn || 2 !== Bt ? Ht : -Ht, Dt[1].push(fn), 2 * Ft === bn + 1 && (Ft = 1 - Ft), 2 * zt === fn + 1 && (zt = 1 - zt), Be.iushrn(1), tt.iushrn(1)
                }
                return Dt
            }, U.cachedProperty = function Ge(Be, tt, Dt) {
                var Ft = "_" + tt;
                Be.prototype[tt] = function () {
                    return void 0 !== this[Ft] ? this[Ft] : this[Ft] = Dt.call(this)
                }
            }, U.parseBytes = function ye(Be) {
                return "string" == typeof Be ? U.toArray(Be, "hex") : Be
            }, U.intFromLE = function Te(Be) {
                return new (D())(Be, "hex", "le")
            }
        }), oe = F.getNAF, ge = F.getJSF, Ie = F.assert;

        function he(Me, ne) {
            this.type = Me, this.p = new (D())(ne.p, 16), this.red = ne.prime ? D().red(ne.prime) : D().mont(this.p), this.zero = new (D())(0).toRed(this.red), this.one = new (D())(1).toRed(this.red), this.two = new (D())(2).toRed(this.red), this.n = ne.n && new (D())(ne.n, 16), this.g = ne.g && this.pointFromJSON(ne.g, ne.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
            var U = this.n && this.p.div(this.n);
            !U || U.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
        }

        var xe = he;

        function Ue(Me, ne) {
            this.curve = Me, this.type = ne, this.precomputed = null
        }

        he.prototype.point = function () {
            throw new Error("Not implemented")
        }, he.prototype.validate = function () {
            throw new Error("Not implemented")
        }, he.prototype._fixedNafMul = function (ne, U) {
            Ie(ne.precomputed);
            var de = ne._getDoubles(), Ze = oe(U, 1, this._bitLength),
                Ge = (1 << de.step + 1) - (de.step % 2 == 0 ? 2 : 1);
            Ge /= 3;
            var Te, Be, ye = [];
            for (Te = 0; Te < Ze.length; Te += de.step) {
                Be = 0;
                for (var tt = Te + de.step - 1; tt >= Te; tt--) Be = (Be << 1) + Ze[tt];
                ye.push(Be)
            }
            for (var Dt = this.jpoint(null, null, null), Ft = this.jpoint(null, null, null), zt = Ge; zt > 0; zt--) {
                for (Te = 0; Te < ye.length; Te++) (Be = ye[Te]) === zt ? Ft = Ft.mixedAdd(de.points[Te]) : Be === -zt && (Ft = Ft.mixedAdd(de.points[Te].neg()));
                Dt = Dt.add(Ft)
            }
            return Dt.toP()
        }, he.prototype._wnafMul = function (ne, U) {
            for (var de = 4, Ze = ne._getNAFPoints(de), Ge = Ze.points, ye = oe(U, de = Ze.wnd, this._bitLength), Te = this.jpoint(null, null, null), Be = ye.length - 1; Be >= 0; Be--) {
                for (var tt = 0; Be >= 0 && 0 === ye[Be]; Be--) tt++;
                if (Be >= 0 && tt++, Te = Te.dblp(tt), Be < 0) break;
                var Dt = ye[Be];
                Ie(0 !== Dt), Te = "affine" === ne.type ? Te.mixedAdd(Dt > 0 ? Ge[Dt - 1 >> 1] : Ge[-Dt - 1 >> 1].neg()) : Te.add(Dt > 0 ? Ge[Dt - 1 >> 1] : Ge[-Dt - 1 >> 1].neg())
            }
            return "affine" === ne.type ? Te.toP() : Te
        }, he.prototype._wnafMulAdd = function (ne, U, de, Ze, Ge) {
            var Dt, Ft, zt, ye = this._wnafT1, Te = this._wnafT2, Be = this._wnafT3, tt = 0;
            for (Dt = 0; Dt < Ze; Dt++) {
                var dn = (zt = U[Dt])._getNAFPoints(ne);
                ye[Dt] = dn.wnd, Te[Dt] = dn.points
            }
            for (Dt = Ze - 1; Dt >= 1; Dt -= 2) {
                var Bt = Dt - 1, Ht = Dt;
                if (1 === ye[Bt] && 1 === ye[Ht]) {
                    var bn = [U[Bt], null, null, U[Ht]];
                    0 === U[Bt].y.cmp(U[Ht].y) ? (bn[1] = U[Bt].add(U[Ht]), bn[2] = U[Bt].toJ().mixedAdd(U[Ht].neg())) : 0 === U[Bt].y.cmp(U[Ht].y.redNeg()) ? (bn[1] = U[Bt].toJ().mixedAdd(U[Ht]), bn[2] = U[Bt].add(U[Ht].neg())) : (bn[1] = U[Bt].toJ().mixedAdd(U[Ht]), bn[2] = U[Bt].toJ().mixedAdd(U[Ht].neg()));
                    var fn = [-3, -1, -5, -7, 0, 7, 5, 1, 3], rn = ge(de[Bt], de[Ht]);
                    for (tt = Math.max(rn[0].length, tt), Be[Bt] = new Array(tt), Be[Ht] = new Array(tt), Ft = 0; Ft < tt; Ft++) Be[Bt][Ft] = fn[3 * (1 + (0 | rn[0][Ft])) + (1 + (0 | rn[1][Ft]))], Be[Ht][Ft] = 0, Te[Bt] = bn
                } else Be[Bt] = oe(de[Bt], ye[Bt], this._bitLength), Be[Ht] = oe(de[Ht], ye[Ht], this._bitLength), tt = Math.max(Be[Bt].length, tt), tt = Math.max(Be[Ht].length, tt)
            }
            var jn = this.jpoint(null, null, null), fr = this._wnafT4;
            for (Dt = tt; Dt >= 0; Dt--) {
                for (var qn = 0; Dt >= 0;) {
                    var Yn = !0;
                    for (Ft = 0; Ft < Ze; Ft++) fr[Ft] = 0 | Be[Ft][Dt], 0 !== fr[Ft] && (Yn = !1);
                    if (!Yn) break;
                    qn++, Dt--
                }
                if (Dt >= 0 && qn++, jn = jn.dblp(qn), Dt < 0) break;
                for (Ft = 0; Ft < Ze; Ft++) {
                    var Qn = fr[Ft];
                    0 !== Qn && (Qn > 0 ? zt = Te[Ft][Qn - 1 >> 1] : Qn < 0 && (zt = Te[Ft][-Qn - 1 >> 1].neg()), jn = "affine" === zt.type ? jn.mixedAdd(zt) : jn.add(zt))
                }
            }
            for (Dt = 0; Dt < Ze; Dt++) Te[Dt] = null;
            return Ge ? jn : jn.toP()
        }, he.BasePoint = Ue, Ue.prototype.eq = function () {
            throw new Error("Not implemented")
        }, Ue.prototype.validate = function () {
            return this.curve.validate(this)
        }, he.prototype.decodePoint = function (ne, U) {
            ne = F.toArray(ne, U);
            var de = this.p.byteLength();
            if ((4 === ne[0] || 6 === ne[0] || 7 === ne[0]) && ne.length - 1 == 2 * de) return 6 === ne[0] ? Ie(ne[ne.length - 1] % 2 == 0) : 7 === ne[0] && Ie(ne[ne.length - 1] % 2 == 1), this.point(ne.slice(1, 1 + de), ne.slice(1 + de, 1 + 2 * de));
            if ((2 === ne[0] || 3 === ne[0]) && ne.length - 1 === de) return this.pointFromX(ne.slice(1, 1 + de), 3 === ne[0]);
            throw new Error("Unknown point format")
        }, Ue.prototype.encodeCompressed = function (ne) {
            return this.encode(ne, !0)
        }, Ue.prototype._encode = function (ne) {
            var U = this.curve.p.byteLength(), de = this.getX().toArray("be", U);
            return ne ? [this.getY().isEven() ? 2 : 3].concat(de) : [4].concat(de, this.getY().toArray("be", U))
        }, Ue.prototype.encode = function (ne, U) {
            return F.encode(this._encode(U), ne)
        }, Ue.prototype.precompute = function (ne) {
            if (this.precomputed) return this;
            var U = {doubles: null, naf: null, beta: null};
            return U.naf = this._getNAFPoints(8), U.doubles = this._getDoubles(4, ne), U.beta = this._getBeta(), this.precomputed = U, this
        }, Ue.prototype._hasDoubles = function (ne) {
            if (!this.precomputed) return !1;
            var U = this.precomputed.doubles;
            return !!U && U.points.length >= Math.ceil((ne.bitLength() + 1) / U.step)
        }, Ue.prototype._getDoubles = function (ne, U) {
            if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
            for (var de = [this], Ze = this, Ge = 0; Ge < U; Ge += ne) {
                for (var ye = 0; ye < ne; ye++) Ze = Ze.dbl();
                de.push(Ze)
            }
            return {step: ne, points: de}
        }, Ue.prototype._getNAFPoints = function (ne) {
            if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
            for (var U = [this], de = (1 << ne) - 1, Ze = 1 === de ? null : this.dbl(), Ge = 1; Ge < de; Ge++) U[Ge] = U[Ge - 1].add(Ze);
            return {wnd: ne, points: U}
        }, Ue.prototype._getBeta = function () {
            return null
        }, Ue.prototype.dblp = function (ne) {
            for (var U = this, de = 0; de < ne; de++) U = U.dbl();
            return U
        };
        var it = Q(function (Me) {
            Me.exports = "function" == typeof Object.create ? function (U, de) {
                de && (U.super_ = de, U.prototype = Object.create(de.prototype, {
                    constructor: {
                        value: U,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }))
            } : function (U, de) {
                if (de) {
                    U.super_ = de;
                    var Ze = function () {
                    };
                    Ze.prototype = de.prototype, U.prototype = new Ze, U.prototype.constructor = U
                }
            }
        }), yt = F.assert;

        function Ce(Me) {
            xe.call(this, "short", Me), this.a = new (D())(Me.a, 16).toRed(this.red), this.b = new (D())(Me.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(Me), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
        }

        it(Ce, xe);
        var $e = Ce;

        function rt(Me, ne, U, de) {
            xe.BasePoint.call(this, Me, "affine"), null === ne && null === U ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new (D())(ne, 16), this.y = new (D())(U, 16), de && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
        }

        function Xe(Me, ne, U, de) {
            xe.BasePoint.call(this, Me, "jacobian"), null === ne && null === U && null === de ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new (D())(0)) : (this.x = new (D())(ne, 16), this.y = new (D())(U, 16), this.z = new (D())(de, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
        }

        Ce.prototype._getEndomorphism = function (ne) {
            if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                var U, de;
                if (ne.beta) U = new (D())(ne.beta, 16).toRed(this.red); else {
                    var Ze = this._getEndoRoots(this.p);
                    U = (U = Ze[0].cmp(Ze[1]) < 0 ? Ze[0] : Ze[1]).toRed(this.red)
                }
                if (ne.lambda) de = new (D())(ne.lambda, 16); else {
                    var Ge = this._getEndoRoots(this.n);
                    0 === this.g.mul(Ge[0]).x.cmp(this.g.x.redMul(U)) ? de = Ge[0] : yt(0 === this.g.mul(de = Ge[1]).x.cmp(this.g.x.redMul(U)))
                }
                return {
                    beta: U, lambda: de, basis: ne.basis ? ne.basis.map(function (Te) {
                        return {a: new (D())(Te.a, 16), b: new (D())(Te.b, 16)}
                    }) : this._getEndoBasis(de)
                }
            }
        }, Ce.prototype._getEndoRoots = function (ne) {
            var U = ne === this.p ? this.red : D().mont(ne), de = new (D())(2).toRed(U).redInvm(), Ze = de.redNeg(),
                Ge = new (D())(3).toRed(U).redNeg().redSqrt().redMul(de);
            return [Ze.redAdd(Ge).fromRed(), Ze.redSub(Ge).fromRed()]
        }, Ce.prototype._getEndoBasis = function (ne) {
            for (var tt, Dt, Ft, zt, dn, Bt, Ht, fn, rn, U = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), de = ne, Ze = this.n.clone(), Ge = new (D())(1), ye = new (D())(0), Te = new (D())(0), Be = new (D())(1), bn = 0; 0 !== de.cmpn(0);) {
                var gn = Ze.div(de);
                fn = Ze.sub(gn.mul(de)), rn = Te.sub(gn.mul(Ge));
                var Hn = Be.sub(gn.mul(ye));
                if (!Ft && fn.cmp(U) < 0) tt = Ht.neg(), Dt = Ge, Ft = fn.neg(), zt = rn; else if (Ft && 2 == ++bn) break;
                Ht = fn, Ze = de, de = fn, Te = Ge, Ge = rn, Be = ye, ye = Hn
            }
            dn = fn.neg(), Bt = rn;
            var jn = Ft.sqr().add(zt.sqr());
            return dn.sqr().add(Bt.sqr()).cmp(jn) >= 0 && (dn = tt, Bt = Dt), Ft.negative && (Ft = Ft.neg(), zt = zt.neg()), dn.negative && (dn = dn.neg(), Bt = Bt.neg()), [{
                a: Ft,
                b: zt
            }, {a: dn, b: Bt}]
        }, Ce.prototype._endoSplit = function (ne) {
            var U = this.endo.basis, de = U[0], Ze = U[1], Ge = Ze.b.mul(ne).divRound(this.n),
                ye = de.b.neg().mul(ne).divRound(this.n), Te = Ge.mul(de.a), Be = ye.mul(Ze.a), tt = Ge.mul(de.b),
                Dt = ye.mul(Ze.b);
            return {k1: ne.sub(Te).sub(Be), k2: tt.add(Dt).neg()}
        }, Ce.prototype.pointFromX = function (ne, U) {
            (ne = new (D())(ne, 16)).red || (ne = ne.toRed(this.red));
            var de = ne.redSqr().redMul(ne).redIAdd(ne.redMul(this.a)).redIAdd(this.b), Ze = de.redSqrt();
            if (0 !== Ze.redSqr().redSub(de).cmp(this.zero)) throw new Error("invalid point");
            var Ge = Ze.fromRed().isOdd();
            return (U && !Ge || !U && Ge) && (Ze = Ze.redNeg()), this.point(ne, Ze)
        }, Ce.prototype.validate = function (ne) {
            if (ne.inf) return !0;
            var U = ne.x, de = ne.y, Ze = this.a.redMul(U), Ge = U.redSqr().redMul(U).redIAdd(Ze).redIAdd(this.b);
            return 0 === de.redSqr().redISub(Ge).cmpn(0)
        }, Ce.prototype._endoWnafMulAdd = function (ne, U, de) {
            for (var Ze = this._endoWnafT1, Ge = this._endoWnafT2, ye = 0; ye < ne.length; ye++) {
                var Te = this._endoSplit(U[ye]), Be = ne[ye], tt = Be._getBeta();
                Te.k1.negative && (Te.k1.ineg(), Be = Be.neg(!0)), Te.k2.negative && (Te.k2.ineg(), tt = tt.neg(!0)), Ze[2 * ye] = Be, Ze[2 * ye + 1] = tt, Ge[2 * ye] = Te.k1, Ge[2 * ye + 1] = Te.k2
            }
            for (var Dt = this._wnafMulAdd(1, Ze, Ge, 2 * ye, de), Ft = 0; Ft < 2 * ye; Ft++) Ze[Ft] = null, Ge[Ft] = null;
            return Dt
        }, it(rt, xe.BasePoint), Ce.prototype.point = function (ne, U, de) {
            return new rt(this, ne, U, de)
        }, Ce.prototype.pointFromJSON = function (ne, U) {
            return rt.fromJSON(this, ne, U)
        }, rt.prototype._getBeta = function () {
            if (this.curve.endo) {
                var ne = this.precomputed;
                if (ne && ne.beta) return ne.beta;
                var U = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (ne) {
                    var de = this.curve, Ze = function (Ge) {
                        return de.point(Ge.x.redMul(de.endo.beta), Ge.y)
                    };
                    ne.beta = U, U.precomputed = {
                        beta: null,
                        naf: ne.naf && {wnd: ne.naf.wnd, points: ne.naf.points.map(Ze)},
                        doubles: ne.doubles && {step: ne.doubles.step, points: ne.doubles.points.map(Ze)}
                    }
                }
                return U
            }
        }, rt.prototype.toJSON = function () {
            return this.precomputed ? [this.x, this.y, this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }] : [this.x, this.y]
        }, rt.fromJSON = function (ne, U, de) {
            "string" == typeof U && (U = JSON.parse(U));
            var Ze = ne.point(U[0], U[1], de);
            if (!U[2]) return Ze;

            function Ge(Te) {
                return ne.point(Te[0], Te[1], de)
            }

            var ye = U[2];
            return Ze.precomputed = {
                beta: null,
                doubles: ye.doubles && {step: ye.doubles.step, points: [Ze].concat(ye.doubles.points.map(Ge))},
                naf: ye.naf && {wnd: ye.naf.wnd, points: [Ze].concat(ye.naf.points.map(Ge))}
            }, Ze
        }, rt.prototype.inspect = function () {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
        }, rt.prototype.isInfinity = function () {
            return this.inf
        }, rt.prototype.add = function (ne) {
            if (this.inf) return ne;
            if (ne.inf) return this;
            if (this.eq(ne)) return this.dbl();
            if (this.neg().eq(ne)) return this.curve.point(null, null);
            if (0 === this.x.cmp(ne.x)) return this.curve.point(null, null);
            var U = this.y.redSub(ne.y);
            0 !== U.cmpn(0) && (U = U.redMul(this.x.redSub(ne.x).redInvm()));
            var de = U.redSqr().redISub(this.x).redISub(ne.x), Ze = U.redMul(this.x.redSub(de)).redISub(this.y);
            return this.curve.point(de, Ze)
        }, rt.prototype.dbl = function () {
            if (this.inf) return this;
            var ne = this.y.redAdd(this.y);
            if (0 === ne.cmpn(0)) return this.curve.point(null, null);
            var U = this.curve.a, de = this.x.redSqr(), Ze = ne.redInvm(),
                Ge = de.redAdd(de).redIAdd(de).redIAdd(U).redMul(Ze), ye = Ge.redSqr().redISub(this.x.redAdd(this.x)),
                Te = Ge.redMul(this.x.redSub(ye)).redISub(this.y);
            return this.curve.point(ye, Te)
        }, rt.prototype.getX = function () {
            return this.x.fromRed()
        }, rt.prototype.getY = function () {
            return this.y.fromRed()
        }, rt.prototype.mul = function (ne) {
            return ne = new (D())(ne, 16), this.isInfinity() ? this : this._hasDoubles(ne) ? this.curve._fixedNafMul(this, ne) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ne]) : this.curve._wnafMul(this, ne)
        }, rt.prototype.mulAdd = function (ne, U, de) {
            var Ze = [this, U], Ge = [ne, de];
            return this.curve.endo ? this.curve._endoWnafMulAdd(Ze, Ge) : this.curve._wnafMulAdd(1, Ze, Ge, 2)
        }, rt.prototype.jmulAdd = function (ne, U, de) {
            var Ze = [this, U], Ge = [ne, de];
            return this.curve.endo ? this.curve._endoWnafMulAdd(Ze, Ge, !0) : this.curve._wnafMulAdd(1, Ze, Ge, 2, !0)
        }, rt.prototype.eq = function (ne) {
            return this === ne || this.inf === ne.inf && (this.inf || 0 === this.x.cmp(ne.x) && 0 === this.y.cmp(ne.y))
        }, rt.prototype.neg = function (ne) {
            if (this.inf) return this;
            var U = this.curve.point(this.x, this.y.redNeg());
            if (ne && this.precomputed) {
                var de = this.precomputed, Ze = function (Ge) {
                    return Ge.neg()
                };
                U.precomputed = {
                    naf: de.naf && {wnd: de.naf.wnd, points: de.naf.points.map(Ze)},
                    doubles: de.doubles && {step: de.doubles.step, points: de.doubles.points.map(Ze)}
                }
            }
            return U
        }, rt.prototype.toJ = function () {
            return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
        }, it(Xe, xe.BasePoint), Ce.prototype.jpoint = function (ne, U, de) {
            return new Xe(this, ne, U, de)
        }, Xe.prototype.toP = function () {
            if (this.isInfinity()) return this.curve.point(null, null);
            var ne = this.z.redInvm(), U = ne.redSqr(), de = this.x.redMul(U), Ze = this.y.redMul(U).redMul(ne);
            return this.curve.point(de, Ze)
        }, Xe.prototype.neg = function () {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
        }, Xe.prototype.add = function (ne) {
            if (this.isInfinity()) return ne;
            if (ne.isInfinity()) return this;
            var U = ne.z.redSqr(), de = this.z.redSqr(), Ze = this.x.redMul(U), Ge = ne.x.redMul(de),
                ye = this.y.redMul(U.redMul(ne.z)), Te = ne.y.redMul(de.redMul(this.z)), Be = Ze.redSub(Ge),
                tt = ye.redSub(Te);
            if (0 === Be.cmpn(0)) return 0 !== tt.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var Dt = Be.redSqr(), Ft = Dt.redMul(Be), zt = Ze.redMul(Dt),
                dn = tt.redSqr().redIAdd(Ft).redISub(zt).redISub(zt),
                Bt = tt.redMul(zt.redISub(dn)).redISub(ye.redMul(Ft)), Ht = this.z.redMul(ne.z).redMul(Be);
            return this.curve.jpoint(dn, Bt, Ht)
        }, Xe.prototype.mixedAdd = function (ne) {
            if (this.isInfinity()) return ne.toJ();
            if (ne.isInfinity()) return this;
            var U = this.z.redSqr(), de = this.x, Ze = ne.x.redMul(U), Ge = this.y, ye = ne.y.redMul(U).redMul(this.z),
                Te = de.redSub(Ze), Be = Ge.redSub(ye);
            if (0 === Te.cmpn(0)) return 0 !== Be.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var tt = Te.redSqr(), Dt = tt.redMul(Te), Ft = de.redMul(tt),
                zt = Be.redSqr().redIAdd(Dt).redISub(Ft).redISub(Ft),
                dn = Be.redMul(Ft.redISub(zt)).redISub(Ge.redMul(Dt)), Bt = this.z.redMul(Te);
            return this.curve.jpoint(zt, dn, Bt)
        }, Xe.prototype.dblp = function (ne) {
            if (0 === ne) return this;
            if (this.isInfinity()) return this;
            if (!ne) return this.dbl();
            var U;
            if (this.curve.zeroA || this.curve.threeA) {
                var de = this;
                for (U = 0; U < ne; U++) de = de.dbl();
                return de
            }
            var Ze = this.curve.a, Ge = this.curve.tinv, ye = this.x, Te = this.y, Be = this.z,
                tt = Be.redSqr().redSqr(), Dt = Te.redAdd(Te);
            for (U = 0; U < ne; U++) {
                var Ft = ye.redSqr(), zt = Dt.redSqr(), dn = zt.redSqr(),
                    Bt = Ft.redAdd(Ft).redIAdd(Ft).redIAdd(Ze.redMul(tt)), Ht = ye.redMul(zt),
                    bn = Bt.redSqr().redISub(Ht.redAdd(Ht)), fn = Ht.redISub(bn), rn = Bt.redMul(fn);
                rn = rn.redIAdd(rn).redISub(dn);
                var gn = Dt.redMul(Be);
                U + 1 < ne && (tt = tt.redMul(dn)), ye = bn, Be = gn, Dt = rn
            }
            return this.curve.jpoint(ye, Dt.redMul(Ge), Be)
        }, Xe.prototype.dbl = function () {
            return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
        }, Xe.prototype._zeroDbl = function () {
            var ne, U, de;
            if (this.zOne) {
                var Ze = this.x.redSqr(), Ge = this.y.redSqr(), ye = Ge.redSqr(),
                    Te = this.x.redAdd(Ge).redSqr().redISub(Ze).redISub(ye);
                Te = Te.redIAdd(Te);
                var Be = Ze.redAdd(Ze).redIAdd(Ze), tt = Be.redSqr().redISub(Te).redISub(Te), Dt = ye.redIAdd(ye);
                Dt = (Dt = Dt.redIAdd(Dt)).redIAdd(Dt), ne = tt, U = Be.redMul(Te.redISub(tt)).redISub(Dt), de = this.y.redAdd(this.y)
            } else {
                var Ft = this.x.redSqr(), zt = this.y.redSqr(), dn = zt.redSqr(),
                    Bt = this.x.redAdd(zt).redSqr().redISub(Ft).redISub(dn);
                Bt = Bt.redIAdd(Bt);
                var Ht = Ft.redAdd(Ft).redIAdd(Ft), bn = Ht.redSqr(), fn = dn.redIAdd(dn);
                fn = (fn = fn.redIAdd(fn)).redIAdd(fn), ne = bn.redISub(Bt).redISub(Bt), U = Ht.redMul(Bt.redISub(ne)).redISub(fn), de = (de = this.y.redMul(this.z)).redIAdd(de)
            }
            return this.curve.jpoint(ne, U, de)
        }, Xe.prototype._threeDbl = function () {
            var ne, U, de;
            if (this.zOne) {
                var Ze = this.x.redSqr(), Ge = this.y.redSqr(), ye = Ge.redSqr(),
                    Te = this.x.redAdd(Ge).redSqr().redISub(Ze).redISub(ye);
                Te = Te.redIAdd(Te);
                var Be = Ze.redAdd(Ze).redIAdd(Ze).redIAdd(this.curve.a), tt = Be.redSqr().redISub(Te).redISub(Te);
                ne = tt;
                var Dt = ye.redIAdd(ye);
                Dt = (Dt = Dt.redIAdd(Dt)).redIAdd(Dt), U = Be.redMul(Te.redISub(tt)).redISub(Dt), de = this.y.redAdd(this.y)
            } else {
                var Ft = this.z.redSqr(), zt = this.y.redSqr(), dn = this.x.redMul(zt),
                    Bt = this.x.redSub(Ft).redMul(this.x.redAdd(Ft));
                Bt = Bt.redAdd(Bt).redIAdd(Bt);
                var Ht = dn.redIAdd(dn), bn = (Ht = Ht.redIAdd(Ht)).redAdd(Ht);
                ne = Bt.redSqr().redISub(bn), de = this.y.redAdd(this.z).redSqr().redISub(zt).redISub(Ft);
                var fn = zt.redSqr();
                fn = (fn = (fn = fn.redIAdd(fn)).redIAdd(fn)).redIAdd(fn), U = Bt.redMul(Ht.redISub(ne)).redISub(fn)
            }
            return this.curve.jpoint(ne, U, de)
        }, Xe.prototype._dbl = function () {
            var ne = this.curve.a, U = this.x, de = this.y, Ze = this.z, Ge = Ze.redSqr().redSqr(), ye = U.redSqr(),
                Te = de.redSqr(), Be = ye.redAdd(ye).redIAdd(ye).redIAdd(ne.redMul(Ge)), tt = U.redAdd(U),
                Dt = (tt = tt.redIAdd(tt)).redMul(Te), Ft = Be.redSqr().redISub(Dt.redAdd(Dt)), zt = Dt.redISub(Ft),
                dn = Te.redSqr();
            dn = (dn = (dn = dn.redIAdd(dn)).redIAdd(dn)).redIAdd(dn);
            var Bt = Be.redMul(zt).redISub(dn), Ht = de.redAdd(de).redMul(Ze);
            return this.curve.jpoint(Ft, Bt, Ht)
        }, Xe.prototype.trpl = function () {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var ne = this.x.redSqr(), U = this.y.redSqr(), de = this.z.redSqr(), Ze = U.redSqr(),
                Ge = ne.redAdd(ne).redIAdd(ne), ye = Ge.redSqr(),
                Te = this.x.redAdd(U).redSqr().redISub(ne).redISub(Ze),
                Be = (Te = (Te = (Te = Te.redIAdd(Te)).redAdd(Te).redIAdd(Te)).redISub(ye)).redSqr(),
                tt = Ze.redIAdd(Ze);
            tt = (tt = (tt = tt.redIAdd(tt)).redIAdd(tt)).redIAdd(tt);
            var Dt = Ge.redIAdd(Te).redSqr().redISub(ye).redISub(Be).redISub(tt), Ft = U.redMul(Dt);
            Ft = (Ft = Ft.redIAdd(Ft)).redIAdd(Ft);
            var zt = this.x.redMul(Be).redISub(Ft);
            zt = (zt = zt.redIAdd(zt)).redIAdd(zt);
            var dn = this.y.redMul(Dt.redMul(tt.redISub(Dt)).redISub(Te.redMul(Be)));
            dn = (dn = (dn = dn.redIAdd(dn)).redIAdd(dn)).redIAdd(dn);
            var Bt = this.z.redAdd(Te).redSqr().redISub(de).redISub(Be);
            return this.curve.jpoint(zt, dn, Bt)
        }, Xe.prototype.mul = function (ne, U) {
            return ne = new (D())(ne, U), this.curve._wnafMul(this, ne)
        }, Xe.prototype.eq = function (ne) {
            if ("affine" === ne.type) return this.eq(ne.toJ());
            if (this === ne) return !0;
            var U = this.z.redSqr(), de = ne.z.redSqr();
            if (0 !== this.x.redMul(de).redISub(ne.x.redMul(U)).cmpn(0)) return !1;
            var Ze = U.redMul(this.z), Ge = de.redMul(ne.z);
            return 0 === this.y.redMul(Ge).redISub(ne.y.redMul(Ze)).cmpn(0)
        }, Xe.prototype.eqXToP = function (ne) {
            var U = this.z.redSqr(), de = ne.toRed(this.curve.red).redMul(U);
            if (0 === this.x.cmp(de)) return !0;
            for (var Ze = ne.clone(), Ge = this.curve.redN.redMul(U); ;) {
                if (Ze.iadd(this.curve.n), Ze.cmp(this.curve.p) >= 0) return !1;
                if (de.redIAdd(Ge), 0 === this.x.cmp(de)) return !0
            }
        }, Xe.prototype.inspect = function () {
            return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
        }, Xe.prototype.isInfinity = function () {
            return 0 === this.z.cmpn(0)
        };
        var Ee = Q(function (Me, ne) {
            var U = ne;
            U.base = xe, U.short = $e, U.mont = null, U.edwards = null
        }), ce = Q(function (Me, ne) {
            var ye, U = ne, de = F.assert;

            function Ze(Te) {
                this.curve = "short" === Te.type ? new Ee.short(Te) : "edwards" === Te.type ? new Ee.edwards(Te) : new Ee.mont(Te), this.g = this.curve.g, this.n = this.curve.n, this.hash = Te.hash, de(this.g.validate(), "Invalid curve"), de(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
            }

            function Ge(Te, Be) {
                Object.defineProperty(U, Te, {
                    configurable: !0, enumerable: !0, get: function () {
                        var tt = new Ze(Be);
                        return Object.defineProperty(U, Te, {configurable: !0, enumerable: !0, value: tt}), tt
                    }
                })
            }

            U.PresetCurve = Ze, Ge("p192", {
                type: "short",
                prime: "p192",
                p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
                b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
                n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
                hash: te().sha256,
                gRed: !1,
                g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
            }), Ge("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: te().sha256,
                gRed: !1,
                g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
            }), Ge("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: te().sha256,
                gRed: !1,
                g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
            }), Ge("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: te().sha384,
                gRed: !1,
                g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
            }), Ge("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: te().sha512,
                gRed: !1,
                g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
            }), Ge("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: te().sha256,
                gRed: !1,
                g: ["9"]
            }), Ge("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: te().sha256,
                gRed: !1,
                g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
            });
            try {
                ye = null.crash()
            } catch (Te) {
                ye = void 0
            }
            Ge("secp256k1", {
                type: "short",
                prime: "k256",
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
                a: "0",
                b: "7",
                n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
                h: "1",
                hash: te().sha256,
                beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
                lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
                basis: [{
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                }, {a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15"}],
                gRed: !1,
                g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", ye]
            })
        });

        function I(Me) {
            if (!(this instanceof I)) return new I(Me);
            this.hash = Me.hash, this.predResist = !!Me.predResist, this.outLen = this.hash.outSize, this.minEntropy = Me.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
            var ne = H.toArray(Me.entropy, Me.entropyEnc || "hex"), U = H.toArray(Me.nonce, Me.nonceEnc || "hex"),
                de = H.toArray(Me.pers, Me.persEnc || "hex");
            X(ne.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(ne, U, de)
        }

        var l = I;
        I.prototype._init = function (ne, U, de) {
            var Ze = ne.concat(U).concat(de);
            this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
            for (var Ge = 0; Ge < this.V.length; Ge++) this.K[Ge] = 0, this.V[Ge] = 1;
            this._update(Ze), this._reseed = 1, this.reseedInterval = 281474976710656
        }, I.prototype._hmac = function () {
            return new (te().hmac)(this.hash, this.K)
        }, I.prototype._update = function (ne) {
            var U = this._hmac().update(this.V).update([0]);
            ne && (U = U.update(ne)), this.K = U.digest(), this.V = this._hmac().update(this.V).digest(), ne && (this.K = this._hmac().update(this.V).update([1]).update(ne).digest(), this.V = this._hmac().update(this.V).digest())
        }, I.prototype.reseed = function (ne, U, de, Ze) {
            "string" != typeof U && (Ze = de, de = U, U = null), ne = H.toArray(ne, U), de = H.toArray(de, Ze), X(ne.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(ne.concat(de || [])), this._reseed = 1
        }, I.prototype.generate = function (ne, U, de, Ze) {
            if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
            "string" != typeof U && (Ze = de, de = U, U = null), de && (de = H.toArray(de, Ze || "hex"), this._update(de));
            for (var Ge = []; Ge.length < ne;) this.V = this._hmac().update(this.V).digest(), Ge = Ge.concat(this.V);
            var ye = Ge.slice(0, ne);
            return this._update(de), this._reseed++, H.encode(ye, U)
        };
        var f = F.assert;

        function g(Me, ne) {
            this.ec = Me, this.priv = null, this.pub = null, ne.priv && this._importPrivate(ne.priv, ne.privEnc), ne.pub && this._importPublic(ne.pub, ne.pubEnc)
        }

        var v = g;
        g.fromPublic = function (ne, U, de) {
            return U instanceof g ? U : new g(ne, {pub: U, pubEnc: de})
        }, g.fromPrivate = function (ne, U, de) {
            return U instanceof g ? U : new g(ne, {priv: U, privEnc: de})
        }, g.prototype.validate = function () {
            var ne = this.getPublic();
            return ne.isInfinity() ? {
                result: !1,
                reason: "Invalid public key"
            } : ne.validate() ? ne.mul(this.ec.curve.n).isInfinity() ? {result: !0, reason: null} : {
                result: !1,
                reason: "Public key * N != O"
            } : {result: !1, reason: "Public key is not a point"}
        }, g.prototype.getPublic = function (ne, U) {
            return "string" == typeof ne && (U = ne, ne = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), U ? this.pub.encode(U, ne) : this.pub
        }, g.prototype.getPrivate = function (ne) {
            return "hex" === ne ? this.priv.toString(16, 2) : this.priv
        }, g.prototype._importPrivate = function (ne, U) {
            this.priv = new (D())(ne, U || 16), this.priv = this.priv.umod(this.ec.curve.n)
        }, g.prototype._importPublic = function (ne, U) {
            if (ne.x || ne.y) return "mont" === this.ec.curve.type ? f(ne.x, "Need x coordinate") : ("short" === this.ec.curve.type || "edwards" === this.ec.curve.type) && f(ne.x && ne.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(ne.x, ne.y));
            this.pub = this.ec.curve.decodePoint(ne, U)
        }, g.prototype.derive = function (ne) {
            return ne.validate() || f(ne.validate(), "public point not validated"), ne.mul(this.priv).getX()
        }, g.prototype.sign = function (ne, U, de) {
            return this.ec.sign(ne, this, U, de)
        }, g.prototype.verify = function (ne, U) {
            return this.ec.verify(ne, U, this)
        }, g.prototype.inspect = function () {
            return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
        };
        var w = F.assert;

        function P(Me, ne) {
            if (Me instanceof P) return Me;
            this._importDER(Me, ne) || (w(Me.r && Me.s, "Signature without r or s"), this.r = new (D())(Me.r, 16), this.s = new (D())(Me.s, 16), this.recoveryParam = void 0 === Me.recoveryParam ? null : Me.recoveryParam)
        }

        var B = P;

        function O() {
            this.place = 0
        }

        function E(Me, ne) {
            var U = Me[ne.place++];
            if (!(128 & U)) return U;
            var de = 15 & U;
            if (0 === de || de > 4) return !1;
            for (var Ze = 0, Ge = 0, ye = ne.place; Ge < de; Ge++, ye++) Ze <<= 8, Ze |= Me[ye], Ze >>>= 0;
            return !(Ze <= 127) && (ne.place = ye, Ze)
        }

        function Z(Me) {
            for (var ne = 0, U = Me.length - 1; !Me[ne] && !(128 & Me[ne + 1]) && ne < U;) ne++;
            return 0 === ne ? Me : Me.slice(ne)
        }

        function ze(Me, ne) {
            if (ne < 128) Me.push(ne); else {
                var U = 1 + (Math.log(ne) / Math.LN2 >>> 3);
                for (Me.push(128 | U); --U;) Me.push(ne >>> (U << 3) & 255);
                Me.push(ne)
            }
        }

        P.prototype._importDER = function (ne, U) {
            ne = F.toArray(ne, U);
            var de = new O;
            if (48 !== ne[de.place++]) return !1;
            var Ze = E(ne, de);
            if (!1 === Ze || Ze + de.place !== ne.length || 2 !== ne[de.place++]) return !1;
            var Ge = E(ne, de);
            if (!1 === Ge) return !1;
            var ye = ne.slice(de.place, Ge + de.place);
            if (de.place += Ge, 2 !== ne[de.place++]) return !1;
            var Te = E(ne, de);
            if (!1 === Te || ne.length !== Te + de.place) return !1;
            var Be = ne.slice(de.place, Te + de.place);
            if (0 === ye[0]) {
                if (!(128 & ye[1])) return !1;
                ye = ye.slice(1)
            }
            if (0 === Be[0]) {
                if (!(128 & Be[1])) return !1;
                Be = Be.slice(1)
            }
            return this.r = new (D())(ye), this.s = new (D())(Be), this.recoveryParam = null, !0
        }, P.prototype.toDER = function (ne) {
            var U = this.r.toArray(), de = this.s.toArray();
            for (128 & U[0] && (U = [0].concat(U)), 128 & de[0] && (de = [0].concat(de)), U = Z(U), de = Z(de); !(de[0] || 128 & de[1]);) de = de.slice(1);
            var Ze = [2];
            ze(Ze, U.length), (Ze = Ze.concat(U)).push(2), ze(Ze, de.length);
            var Ge = Ze.concat(de), ye = [48];
            return ze(ye, Ge.length), ye = ye.concat(Ge), F.encode(ye, ne)
        };
        var Je = function () {
            throw new Error("unsupported")
        }, q = F.assert;

        function Le(Me) {
            if (!(this instanceof Le)) return new Le(Me);
            "string" == typeof Me && (q(Object.prototype.hasOwnProperty.call(ce, Me), "Unknown curve " + Me), Me = ce[Me]), Me instanceof ce.PresetCurve && (Me = {curve: Me}), this.curve = Me.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Me.curve.g, this.g.precompute(Me.curve.n.bitLength() + 1), this.hash = Me.hash || Me.curve.hash
        }

        var ut = Le;
        Le.prototype.keyPair = function (ne) {
            return new v(this, ne)
        }, Le.prototype.keyFromPrivate = function (ne, U) {
            return v.fromPrivate(this, ne, U)
        }, Le.prototype.keyFromPublic = function (ne, U) {
            return v.fromPublic(this, ne, U)
        }, Le.prototype.genKeyPair = function (ne) {
            ne || (ne = {});
            for (var U = new l({
                hash: this.hash,
                pers: ne.pers,
                persEnc: ne.persEnc || "utf8",
                entropy: ne.entropy || Je(),
                entropyEnc: ne.entropy && ne.entropyEnc || "utf8",
                nonce: this.n.toArray()
            }), de = this.n.byteLength(), Ze = this.n.sub(new (D())(2)); ;) {
                var Ge = new (D())(U.generate(de));
                if (!(Ge.cmp(Ze) > 0)) return Ge.iaddn(1), this.keyFromPrivate(Ge)
            }
        }, Le.prototype._truncateToN = function (ne, U) {
            var de = 8 * ne.byteLength() - this.n.bitLength();
            return de > 0 && (ne = ne.ushrn(de)), !U && ne.cmp(this.n) >= 0 ? ne.sub(this.n) : ne
        }, Le.prototype.sign = function (ne, U, de, Ze) {
            "object" == typeof de && (Ze = de, de = null), Ze || (Ze = {}), U = this.keyFromPrivate(U, de), ne = this._truncateToN(new (D())(ne, 16));
            for (var Ge = this.n.byteLength(), ye = U.getPrivate().toArray("be", Ge), Te = ne.toArray("be", Ge), Be = new l({
                hash: this.hash,
                entropy: ye,
                nonce: Te,
                pers: Ze.pers,
                persEnc: Ze.persEnc || "utf8"
            }), tt = this.n.sub(new (D())(1)), Dt = 0; ; Dt++) {
                var Ft = Ze.k ? Ze.k(Dt) : new (D())(Be.generate(this.n.byteLength()));
                if (!((Ft = this._truncateToN(Ft, !0)).cmpn(1) <= 0 || Ft.cmp(tt) >= 0)) {
                    var zt = this.g.mul(Ft);
                    if (!zt.isInfinity()) {
                        var dn = zt.getX(), Bt = dn.umod(this.n);
                        if (0 !== Bt.cmpn(0)) {
                            var Ht = Ft.invm(this.n).mul(Bt.mul(U.getPrivate()).iadd(ne));
                            if (0 !== (Ht = Ht.umod(this.n)).cmpn(0)) {
                                var bn = (zt.getY().isOdd() ? 1 : 0) | (0 !== dn.cmp(Bt) ? 2 : 0);
                                return Ze.canonical && Ht.cmp(this.nh) > 0 && (Ht = this.n.sub(Ht), bn ^= 1), new B({
                                    r: Bt,
                                    s: Ht,
                                    recoveryParam: bn
                                })
                            }
                        }
                    }
                }
            }
        }, Le.prototype.verify = function (ne, U, de, Ze) {
            ne = this._truncateToN(new (D())(ne, 16)), de = this.keyFromPublic(de, Ze);
            var Ge = (U = new B(U, "hex")).r, ye = U.s;
            if (Ge.cmpn(1) < 0 || Ge.cmp(this.n) >= 0 || ye.cmpn(1) < 0 || ye.cmp(this.n) >= 0) return !1;
            var Dt, Te = ye.invm(this.n), Be = Te.mul(ne).umod(this.n), tt = Te.mul(Ge).umod(this.n);
            return this.curve._maxwellTrick ? !(Dt = this.g.jmulAdd(Be, de.getPublic(), tt)).isInfinity() && Dt.eqXToP(Ge) : !(Dt = this.g.mulAdd(Be, de.getPublic(), tt)).isInfinity() && 0 === Dt.getX().umod(this.n).cmp(Ge)
        }, Le.prototype.recoverPubKey = function (Me, ne, U, de) {
            q((3 & U) === U, "The recovery param is more than two bits"), ne = new B(ne, de);
            var Ze = this.n, Ge = new (D())(Me), ye = ne.r, Te = ne.s, Be = 1 & U, tt = U >> 1;
            if (ye.cmp(this.curve.p.umod(this.curve.n)) >= 0 && tt) throw new Error("Unable to find sencond key candinate");
            ye = this.curve.pointFromX(tt ? ye.add(this.curve.n) : ye, Be);
            var Dt = ne.r.invm(Ze), Ft = Ze.sub(Ge).mul(Dt).umod(Ze), zt = Te.mul(Dt).umod(Ze);
            return this.g.mulAdd(Ft, ye, zt)
        }, Le.prototype.getKeyRecoveryParam = function (Me, ne, U, de) {
            if (null !== (ne = new B(ne, de)).recoveryParam) return ne.recoveryParam;
            for (var Ze = 0; Ze < 4; Ze++) {
                var Ge;
                try {
                    Ge = this.recoverPubKey(Me, ne, Ze)
                } catch (ye) {
                    continue
                }
                if (Ge.eq(U)) return Ze
            }
            throw new Error("Unable to find valid recovery factor")
        };
        var Mt = Q(function (Me, ne) {
            var U = ne;
            U.version = "6.5.4", U.utils = F, U.rand = function () {
                throw new Error("unsupported")
            }, U.curve = Ee, U.curves = ce, U.ec = ut, U.eddsa = null
        }).ec, _t = R(499), Pt = R(4325);
        const Xt = new (R(8666).Yd)("signing-key/5.6.2");
        let xn = null;

        function Fn() {
            return xn || (xn = new Mt("secp256k1")), xn
        }

        class wn {
            constructor(ne) {
                (0, Pt.zG)(this, "curve", "secp256k1"), (0, Pt.zG)(this, "privateKey", (0, _t.Dv)(ne)), 32 !== (0, _t.E1)(this.privateKey) && Xt.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
                const U = Fn().keyFromPrivate((0, _t.lE)(this.privateKey));
                (0, Pt.zG)(this, "publicKey", "0x" + U.getPublic(!1, "hex")), (0, Pt.zG)(this, "compressedPublicKey", "0x" + U.getPublic(!0, "hex")), (0, Pt.zG)(this, "_isSigningKey", !0)
            }

            _addPoint(ne) {
                const U = Fn().keyFromPublic((0, _t.lE)(this.publicKey)), de = Fn().keyFromPublic((0, _t.lE)(ne));
                return "0x" + U.pub.add(de.pub).encodeCompressed("hex")
            }

            signDigest(ne) {
                const U = Fn().keyFromPrivate((0, _t.lE)(this.privateKey)), de = (0, _t.lE)(ne);
                32 !== de.length && Xt.throwArgumentError("bad digest length", "digest", ne);
                const Ze = U.sign(de, {canonical: !0});
                return (0, _t.N)({
                    recoveryParam: Ze.recoveryParam,
                    r: (0, _t.$m)("0x" + Ze.r.toString(16), 32),
                    s: (0, _t.$m)("0x" + Ze.s.toString(16), 32)
                })
            }

            computeSharedSecret(ne) {
                const U = Fn().keyFromPrivate((0, _t.lE)(this.privateKey)), de = Fn().keyFromPublic((0, _t.lE)(On(ne)));
                return (0, _t.$m)("0x" + U.derive(de.getPublic()).toString(16), 32)
            }

            static isSigningKey(ne) {
                return !(!ne || !ne._isSigningKey)
            }
        }

        function Nn(Me, ne) {
            const U = (0, _t.N)(ne), de = {r: (0, _t.lE)(U.r), s: (0, _t.lE)(U.s)};
            return "0x" + Fn().recoverPubKey((0, _t.lE)(Me), de, U.recoveryParam).encode("hex", !1)
        }

        function On(Me, ne) {
            const U = (0, _t.lE)(Me);
            if (32 === U.length) {
                const de = new wn(U);
                return ne ? "0x" + Fn().keyFromPrivate(U).getPublic(!0, "hex") : de.publicKey
            }
            return 33 === U.length ? ne ? (0, _t.Dv)(U) : "0x" + Fn().keyFromPublic(U).getPublic(!1, "hex") : 65 === U.length ? ne ? "0x" + Fn().keyFromPublic(U).getPublic(!0, "hex") : (0, _t.Dv)(U) : Xt.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
        }
    }, 3544: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Uj: () => j, uu: () => F, Y0: () => X, XL: () => ge, ZN: () => oe});
        var r = R(499);
        const te = new (R(8666).Yd)("strings/5.6.1");
        var j = (() => {
            return (Ie = j || (j = {})).current = "", Ie.NFC = "NFC", Ie.NFD = "NFD", Ie.NFKC = "NFKC", Ie.NFKD = "NFKD", j;
            var Ie
        })(), W = (() => {
            return (Ie = W || (W = {})).UNEXPECTED_CONTINUE = "unexpected continuation byte", Ie.BAD_PREFIX = "bad codepoint prefix", Ie.OVERRUN = "string overrun", Ie.MISSING_CONTINUE = "missing continuation byte", Ie.OUT_OF_RANGE = "out of UTF-8 range", Ie.UTF16_SURROGATE = "UTF-16 surrogate", Ie.OVERLONG = "overlong representation", W;
            var Ie
        })();

        function Ne(Ie, he, xe, Ue, it) {
            if (Ie === W.BAD_PREFIX || Ie === W.UNEXPECTED_CONTINUE) {
                let yt = 0;
                for (let Ce = he + 1; Ce < xe.length && xe[Ce] >> 6 == 2; Ce++) yt++;
                return yt
            }
            return Ie === W.OVERRUN ? xe.length - he - 1 : 0
        }

        const me = Object.freeze({
            error: function Q(Ie, he, xe, Ue, it) {
                return te.throwArgumentError(`invalid codepoint at offset ${he}; ${Ie}`, "bytes", xe)
            }, ignore: Ne, replace: function ve(Ie, he, xe, Ue, it) {
                return Ie === W.OVERLONG ? (Ue.push(it), 0) : (Ue.push(65533), Ne(Ie, he, xe))
            }
        });

        function ae(Ie, he) {
            null == he && (he = me.error), Ie = (0, r.lE)(Ie);
            const xe = [];
            let Ue = 0;
            for (; Ue < Ie.length;) {
                const it = Ie[Ue++];
                if (it >> 7 == 0) {
                    xe.push(it);
                    continue
                }
                let yt = null, Ce = null;
                if (192 == (224 & it)) yt = 1, Ce = 127; else if (224 == (240 & it)) yt = 2, Ce = 2047; else {
                    if (240 != (248 & it)) {
                        Ue += he(128 == (192 & it) ? W.UNEXPECTED_CONTINUE : W.BAD_PREFIX, Ue - 1, Ie, xe);
                        continue
                    }
                    yt = 3, Ce = 65535
                }
                if (Ue - 1 + yt >= Ie.length) {
                    Ue += he(W.OVERRUN, Ue - 1, Ie, xe);
                    continue
                }
                let $e = it & (1 << 8 - yt - 1) - 1;
                for (let rt = 0; rt < yt; rt++) {
                    let Xe = Ie[Ue];
                    if (128 != (192 & Xe)) {
                        Ue += he(W.MISSING_CONTINUE, Ue, Ie, xe), $e = null;
                        break
                    }
                    $e = $e << 6 | 63 & Xe, Ue++
                }
                if (null !== $e) {
                    if ($e > 1114111) {
                        Ue += he(W.OUT_OF_RANGE, Ue - 1 - yt, Ie, xe, $e);
                        continue
                    }
                    if ($e >= 55296 && $e <= 57343) {
                        Ue += he(W.UTF16_SURROGATE, Ue - 1 - yt, Ie, xe, $e);
                        continue
                    }
                    if ($e <= Ce) {
                        Ue += he(W.OVERLONG, Ue - 1 - yt, Ie, xe, $e);
                        continue
                    }
                    xe.push($e)
                }
            }
            return xe
        }

        function X(Ie, he = j.current) {
            he != j.current && (te.checkNormalize(), Ie = Ie.normalize(he));
            let xe = [];
            for (let Ue = 0; Ue < Ie.length; Ue++) {
                const it = Ie.charCodeAt(Ue);
                if (it < 128) xe.push(it); else if (it < 2048) xe.push(it >> 6 | 192), xe.push(63 & it | 128); else if (55296 == (64512 & it)) {
                    Ue++;
                    const yt = Ie.charCodeAt(Ue);
                    if (Ue >= Ie.length || 56320 != (64512 & yt)) throw new Error("invalid utf-8 string");
                    const Ce = 65536 + ((1023 & it) << 10) + (1023 & yt);
                    xe.push(Ce >> 18 | 240), xe.push(Ce >> 12 & 63 | 128), xe.push(Ce >> 6 & 63 | 128), xe.push(63 & Ce | 128)
                } else xe.push(it >> 12 | 224), xe.push(it >> 6 & 63 | 128), xe.push(63 & it | 128)
            }
            return (0, r.lE)(xe)
        }

        function F(Ie) {
            return Ie.map(he => he <= 65535 ? String.fromCharCode(he) : (he -= 65536, String.fromCharCode(55296 + (he >> 10 & 1023), 56320 + (1023 & he)))).join("")
        }

        function oe(Ie, he) {
            return F(ae(Ie, he))
        }

        function ge(Ie, he = j.current) {
            return ae(X(Ie, he))
        }
    }, 1474: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {z7: () => Ue, db: () => ge, Qc: () => l, qC: () => rt});
        var r = R(8016), D = R(2909), ie = R(499), te = R(3037), j = R(2547), W = R(4325), Q = R(810), Ne = R(3126),
            ve = R(8666);
        const ae = new ve.Yd("transactions/5.6.2");

        function M(f) {
            return "0x" === f ? null : (0, r.Kn)(f)
        }

        function H(f) {
            return "0x" === f ? te._Y : D.O$.from(f)
        }

        const F = [{name: "nonce", maxLength: 32, numeric: !0}, {
                name: "gasPrice",
                maxLength: 32,
                numeric: !0
            }, {name: "gasLimit", maxLength: 32, numeric: !0}, {name: "to", length: 20}, {
                name: "value",
                maxLength: 32,
                numeric: !0
            }, {name: "data"}],
            oe = {chainId: !0, data: !0, gasLimit: !0, gasPrice: !0, nonce: !0, to: !0, type: !0, value: !0};

        function ge(f) {
            const g = (0, Ne.VW)(f);
            return (0, r.Kn)((0, ie.p3)((0, j.w)((0, ie.p3)(g, 1)), 12))
        }

        function Ie(f, g) {
            return ge((0, Ne.LO)((0, ie.lE)(f), g))
        }

        function he(f, g) {
            const v = (0, ie.G1)(D.O$.from(f).toHexString());
            return v.length > 32 && ae.throwArgumentError("invalid length for " + g, "transaction:" + g, f), v
        }

        function xe(f, g) {
            return {
                address: (0, r.Kn)(f),
                storageKeys: (g || []).map((v, w) => (32 !== (0, ie.E1)(v) && ae.throwArgumentError("invalid access list storageKey", `accessList[${f}:${w}]`, v), v.toLowerCase()))
            }
        }

        function Ue(f) {
            if (Array.isArray(f)) return f.map((v, w) => Array.isArray(v) ? (v.length > 2 && ae.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${w}]`, v), xe(v[0], v[1])) : xe(v.address, v.storageKeys));
            const g = Object.keys(f).map(v => {
                const w = f[v].reduce((P, B) => (P[B] = !0, P), {});
                return xe(v, Object.keys(w).sort())
            });
            return g.sort((v, w) => v.address.localeCompare(w.address)), g
        }

        function it(f) {
            return Ue(f).map(g => [g.address, g.storageKeys])
        }

        function yt(f, g) {
            if (null != f.gasPrice) {
                const w = D.O$.from(f.gasPrice), P = D.O$.from(f.maxFeePerGas || 0);
                w.eq(P) || ae.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                    gasPrice: w,
                    maxFeePerGas: P
                })
            }
            const v = [he(f.chainId || 0, "chainId"), he(f.nonce || 0, "nonce"), he(f.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), he(f.maxFeePerGas || 0, "maxFeePerGas"), he(f.gasLimit || 0, "gasLimit"), null != f.to ? (0, r.Kn)(f.to) : "0x", he(f.value || 0, "value"), f.data || "0x", it(f.accessList || [])];
            if (g) {
                const w = (0, ie.N)(g);
                v.push(he(w.recoveryParam, "recoveryParam")), v.push((0, ie.G1)(w.r)), v.push((0, ie.G1)(w.s))
            }
            return (0, ie.xs)(["0x02", Q.c(v)])
        }

        function Ce(f, g) {
            const v = [he(f.chainId || 0, "chainId"), he(f.nonce || 0, "nonce"), he(f.gasPrice || 0, "gasPrice"), he(f.gasLimit || 0, "gasLimit"), null != f.to ? (0, r.Kn)(f.to) : "0x", he(f.value || 0, "value"), f.data || "0x", it(f.accessList || [])];
            if (g) {
                const w = (0, ie.N)(g);
                v.push(he(w.recoveryParam, "recoveryParam")), v.push((0, ie.G1)(w.r)), v.push((0, ie.G1)(w.s))
            }
            return (0, ie.xs)(["0x01", Q.c(v)])
        }

        function rt(f, g) {
            if (null == f.type || 0 === f.type) return null != f.accessList && ae.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", f), function $e(f, g) {
                (0, W.uj)(f, oe);
                const v = [];
                F.forEach(function (O) {
                    let E = f[O.name] || [];
                    const Z = {};
                    O.numeric && (Z.hexPad = "left"), E = (0, ie.lE)((0, ie.Dv)(E, Z)), O.length && E.length !== O.length && E.length > 0 && ae.throwArgumentError("invalid length for " + O.name, "transaction:" + O.name, E), O.maxLength && (E = (0, ie.G1)(E), E.length > O.maxLength && ae.throwArgumentError("invalid length for " + O.name, "transaction:" + O.name, E)), v.push((0, ie.Dv)(E))
                });
                let w = 0;
                if (null != f.chainId ? (w = f.chainId, "number" != typeof w && ae.throwArgumentError("invalid transaction.chainId", "transaction", f)) : g && !(0, ie.Zq)(g) && g.v > 28 && (w = Math.floor((g.v - 35) / 2)), 0 !== w && (v.push((0, ie.Dv)(w)), v.push("0x"), v.push("0x")), !g) return Q.c(v);
                const P = (0, ie.N)(g);
                let B = 27 + P.recoveryParam;
                return 0 !== w ? (v.pop(), v.pop(), v.pop(), B += 2 * w + 8, P.v > 28 && P.v !== B && ae.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", g)) : P.v !== B && ae.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", g), v.push((0, ie.Dv)(B)), v.push((0, ie.G1)((0, ie.lE)(P.r))), v.push((0, ie.G1)((0, ie.lE)(P.s))), Q.c(v)
            }(f, g);
            switch (f.type) {
                case 1:
                    return Ce(f, g);
                case 2:
                    return yt(f, g)
            }
            return ae.throwError(`unsupported transaction type: ${f.type}`, ve.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "serializeTransaction",
                transactionType: f.type
            })
        }

        function Xe(f, g, v) {
            try {
                const w = H(g[0]).toNumber();
                if (0 !== w && 1 !== w) throw new Error("bad recid");
                f.v = w
            } catch (w) {
                ae.throwArgumentError("invalid v for transaction type: 1", "v", g[0])
            }
            f.r = (0, ie.$m)(g[1], 32), f.s = (0, ie.$m)(g[2], 32);
            try {
                const w = (0, j.w)(v(f));
                f.from = Ie(w, {r: f.r, s: f.s, recoveryParam: f.v})
            } catch (w) {
            }
        }

        function l(f) {
            const g = (0, ie.lE)(f);
            if (g[0] > 127) return function I(f) {
                const g = Q.J(f);
                9 !== g.length && 6 !== g.length && ae.throwArgumentError("invalid raw transaction", "rawTransaction", f);
                const v = {
                    nonce: H(g[0]).toNumber(),
                    gasPrice: H(g[1]),
                    gasLimit: H(g[2]),
                    to: M(g[3]),
                    value: H(g[4]),
                    data: g[5],
                    chainId: 0
                };
                if (6 === g.length) return v;
                try {
                    v.v = D.O$.from(g[6]).toNumber()
                } catch (w) {
                    return v
                }
                if (v.r = (0, ie.$m)(g[7], 32), v.s = (0, ie.$m)(g[8], 32), D.O$.from(v.r).isZero() && D.O$.from(v.s).isZero()) v.chainId = v.v, v.v = 0; else {
                    v.chainId = Math.floor((v.v - 35) / 2), v.chainId < 0 && (v.chainId = 0);
                    let w = v.v - 27;
                    const P = g.slice(0, 6);
                    0 !== v.chainId && (P.push((0, ie.Dv)(v.chainId)), P.push("0x"), P.push("0x"), w -= 2 * v.chainId + 8);
                    const B = (0, j.w)(Q.c(P));
                    try {
                        v.from = Ie(B, {r: (0, ie.Dv)(v.r), s: (0, ie.Dv)(v.s), recoveryParam: w})
                    } catch (O) {
                    }
                    v.hash = (0, j.w)(f)
                }
                return v.type = null, v
            }(g);
            switch (g[0]) {
                case 1:
                    return function ce(f) {
                        const g = Q.J(f.slice(1));
                        8 !== g.length && 11 !== g.length && ae.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, ie.Dv)(f));
                        const v = {
                            type: 1,
                            chainId: H(g[0]).toNumber(),
                            nonce: H(g[1]).toNumber(),
                            gasPrice: H(g[2]),
                            gasLimit: H(g[3]),
                            to: M(g[4]),
                            value: H(g[5]),
                            data: g[6],
                            accessList: Ue(g[7])
                        };
                        return 8 === g.length || (v.hash = (0, j.w)(f), Xe(v, g.slice(8), Ce)), v
                    }(g);
                case 2:
                    return function Ee(f) {
                        const g = Q.J(f.slice(1));
                        9 !== g.length && 12 !== g.length && ae.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, ie.Dv)(f));
                        const v = H(g[2]), w = H(g[3]), P = {
                            type: 2,
                            chainId: H(g[0]).toNumber(),
                            nonce: H(g[1]).toNumber(),
                            maxPriorityFeePerGas: v,
                            maxFeePerGas: w,
                            gasPrice: null,
                            gasLimit: H(g[4]),
                            to: M(g[5]),
                            value: H(g[6]),
                            data: g[7],
                            accessList: Ue(g[8])
                        };
                        return 9 === g.length || (P.hash = (0, j.w)(f), Xe(P, g.slice(9), yt)), P
                    }(g)
            }
            return ae.throwError(`unsupported transaction type: ${g[0]}`, ve.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "parseTransaction",
                transactionType: g[0]
            })
        }
    }, 4842: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {w5: () => Qe});
        var r = R(8016), D = R(8314), ie = R(2748), te = R(499), j = R(2547), W = R(3544), ve = R(687), me = R(5887),
            ae = R(2909), X = R(1871);

        function M(gt, dt, wt, Ut, Qt) {
            gt = (0, te.lE)(gt), dt = (0, te.lE)(dt);
            let sn, un = 1;
            const Pn = new Uint8Array(Ut), mn = new Uint8Array(dt.length + 4);
            let Mn, an;
            mn.set(dt);
            for (let En = 1; En <= un; En++) {
                mn[dt.length] = En >> 24 & 255, mn[dt.length + 1] = En >> 16 & 255, mn[dt.length + 2] = En >> 8 & 255, mn[dt.length + 3] = 255 & En;
                let Sn = (0, te.lE)((0, X.Gy)(Qt, gt, mn));
                sn || (sn = Sn.length, an = new Uint8Array(sn), un = Math.ceil(Ut / sn), Mn = Ut - (un - 1) * sn), an.set(Sn);
                for (let nn = 1; nn < wt; nn++) {
                    Sn = (0, te.lE)((0, X.Gy)(Qt, gt, Sn));
                    for (let _n = 0; _n < sn; _n++) an[_n] ^= Sn[_n]
                }
                const ar = (En - 1) * sn, Un = En === un ? Mn : sn;
                Pn.set((0, te.lE)(an).slice(0, Un), ar)
            }
            return (0, te.Dv)(Pn)
        }

        var H = R(4325), F = R(3126), oe = R(5587), ge = R(1474), Ie = R(6171), he = R(8666);
        const it = new he.Yd("wordlists/5.6.1");

        class yt {
            constructor(dt) {
                it.checkAbstract(new.target, yt), (0, H.zG)(this, "locale", dt)
            }

            split(dt) {
                return dt.toLowerCase().split(/ +/g)
            }

            join(dt) {
                return dt.join(" ")
            }

            static check(dt) {
                const wt = [];
                for (let Ut = 0; Ut < 2048; Ut++) {
                    const Qt = dt.getWord(Ut);
                    if (Ut !== dt.getWordIndex(Qt)) return "0x";
                    wt.push(Qt)
                }
                return (0, Ie.id)(wt.join("\n") + "\n")
            }

            static register(dt, wt) {
                wt || (wt = dt.locale)
            }
        }

        let $e = null;

        function rt(gt) {
            if (null == $e && ($e = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60" !== yt.check(gt))) throw $e = null, new Error("BIP39 Wordlist for en (English) FAILED")
        }

        const Ee = new class Xe extends yt {
            constructor() {
                super("en")
            }

            getWord(dt) {
                return rt(this), $e[dt]
            }

            getWordIndex(dt) {
                return rt(this), $e.indexOf(dt)
            }
        };
        yt.register(Ee);
        const ce = {en: Ee}, l = new he.Yd("hdnode/5.6.2"),
            f = ae.O$.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
            g = (0, W.Y0)("Bitcoin seed"), v = 2147483648;

        function w(gt) {
            return (1 << gt) - 1 << 8 - gt
        }

        function P(gt) {
            return (1 << gt) - 1
        }

        function B(gt) {
            return (0, te.$m)((0, te.Dv)(gt), 32)
        }

        function O(gt) {
            return me.eU.encode((0, te.zo)([gt, (0, te.p3)((0, X.JQ)((0, X.JQ)(gt)), 0, 4)]))
        }

        function E(gt) {
            if (null == gt) return ce.en;
            if ("string" == typeof gt) {
                const dt = ce[gt];
                return null == dt && l.throwArgumentError("unknown locale", "wordlist", gt), dt
            }
            return gt
        }

        const Z = {}, ze = "m/44'/60'/0'/0/0";

        class Je {
            constructor(dt, wt, Ut, Qt, sn, un, Pn, mn) {
                if (dt !== Z) throw new Error("HDNode constructor cannot be called directly");
                if (wt) {
                    const Mn = new F.Et(wt);
                    (0, H.zG)(this, "privateKey", Mn.privateKey), (0, H.zG)(this, "publicKey", Mn.compressedPublicKey)
                } else (0, H.zG)(this, "privateKey", null), (0, H.zG)(this, "publicKey", (0, te.Dv)(Ut));
                (0, H.zG)(this, "parentFingerprint", Qt), (0, H.zG)(this, "fingerprint", (0, te.p3)((0, X.bP)((0, X.JQ)(this.publicKey)), 0, 4)), (0, H.zG)(this, "address", (0, ge.db)(this.publicKey)), (0, H.zG)(this, "chainCode", sn), (0, H.zG)(this, "index", un), (0, H.zG)(this, "depth", Pn), null == mn ? ((0, H.zG)(this, "mnemonic", null), (0, H.zG)(this, "path", null)) : "string" == typeof mn ? ((0, H.zG)(this, "mnemonic", null), (0, H.zG)(this, "path", mn)) : ((0, H.zG)(this, "mnemonic", mn), (0, H.zG)(this, "path", mn.path))
            }

            get extendedKey() {
                if (this.depth >= 256) throw new Error("Depth too large!");
                return O((0, te.zo)([null != this.privateKey ? "0x0488ADE4" : "0x0488B21E", (0, te.Dv)(this.depth), this.parentFingerprint, (0, te.$m)((0, te.Dv)(this.index), 4), this.chainCode, null != this.privateKey ? (0, te.zo)(["0x00", this.privateKey]) : this.publicKey]))
            }

            neuter() {
                return new Je(Z, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path)
            }

            _derive(dt) {
                if (dt > 4294967295) throw new Error("invalid index - " + String(dt));
                let wt = this.path;
                wt && (wt += "/" + (dt & ~v));
                const Ut = new Uint8Array(37);
                if (dt & v) {
                    if (!this.privateKey) throw new Error("cannot derive child of neutered node");
                    Ut.set((0, te.lE)(this.privateKey), 1), wt && (wt += "'")
                } else Ut.set((0, te.lE)(this.publicKey));
                for (let En = 24; En >= 0; En -= 8) Ut[33 + (En >> 3)] = dt >> 24 - En & 255;
                const Qt = (0, te.lE)((0, X.Gy)(oe.p.sha512, this.chainCode, Ut)), sn = Qt.slice(0, 32),
                    un = Qt.slice(32);
                let Pn = null, mn = null;
                this.privateKey ? Pn = B(ae.O$.from(sn).add(this.privateKey).mod(f)) : mn = new F.Et((0, te.Dv)(sn))._addPoint(this.publicKey);
                let Mn = wt;
                const an = this.mnemonic;
                return an && (Mn = Object.freeze({
                    phrase: an.phrase,
                    path: wt,
                    locale: an.locale || "en"
                })), new Je(Z, Pn, mn, this.fingerprint, B(un), dt, this.depth + 1, Mn)
            }

            derivePath(dt) {
                const wt = dt.split("/");
                if (0 === wt.length || "m" === wt[0] && 0 !== this.depth) throw new Error("invalid path - " + dt);
                "m" === wt[0] && wt.shift();
                let Ut = this;
                for (let Qt = 0; Qt < wt.length; Qt++) {
                    const sn = wt[Qt];
                    if (sn.match(/^[0-9]+'$/)) {
                        const un = parseInt(sn.substring(0, sn.length - 1));
                        if (un >= v) throw new Error("invalid path index - " + sn);
                        Ut = Ut._derive(v + un)
                    } else {
                        if (!sn.match(/^[0-9]+$/)) throw new Error("invalid path component - " + sn);
                        {
                            const un = parseInt(sn);
                            if (un >= v) throw new Error("invalid path index - " + sn);
                            Ut = Ut._derive(un)
                        }
                    }
                }
                return Ut
            }

            static _fromSeed(dt, wt) {
                const Ut = (0, te.lE)(dt);
                if (Ut.length < 16 || Ut.length > 64) throw new Error("invalid seed");
                const Qt = (0, te.lE)((0, X.Gy)(oe.p.sha512, g, Ut));
                return new Je(Z, B(Qt.slice(0, 32)), null, "0x00000000", B(Qt.slice(32)), 0, 0, wt)
            }

            static fromMnemonic(dt, wt, Ut) {
                return dt = ut(Le(dt, Ut = E(Ut)), Ut), Je._fromSeed(function q(gt, dt) {
                    dt || (dt = "");
                    const wt = (0, W.Y0)("mnemonic" + dt, W.Uj.NFKD);
                    return M((0, W.Y0)(gt, W.Uj.NFKD), wt, 2048, 64, "sha512")
                }(dt, wt), {phrase: dt, path: "m", locale: Ut.locale})
            }

            static fromSeed(dt) {
                return Je._fromSeed(dt, null)
            }

            static fromExtendedKey(dt) {
                const wt = me.eU.decode(dt);
                (82 !== wt.length || O(wt.slice(0, 78)) !== dt) && l.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
                const Ut = wt[4], Qt = (0, te.Dv)(wt.slice(5, 9)),
                    sn = parseInt((0, te.Dv)(wt.slice(9, 13)).substring(2), 16), un = (0, te.Dv)(wt.slice(13, 45)),
                    Pn = wt.slice(45, 78);
                switch ((0, te.Dv)(wt.slice(0, 4))) {
                    case"0x0488b21e":
                    case"0x043587cf":
                        return new Je(Z, null, (0, te.Dv)(Pn), Qt, un, sn, Ut, null);
                    case"0x0488ade4":
                    case"0x04358394 ":
                        if (0 !== Pn[0]) break;
                        return new Je(Z, (0, te.Dv)(Pn.slice(1)), null, Qt, un, sn, Ut, null)
                }
                return l.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]")
            }
        }

        function Le(gt, dt) {
            dt = E(dt), l.checkNormalize();
            const wt = dt.split(gt);
            if (wt.length % 3 != 0) throw new Error("invalid mnemonic");
            const Ut = (0, te.lE)(new Uint8Array(Math.ceil(11 * wt.length / 8)));
            let Qt = 0;
            for (let Mn = 0; Mn < wt.length; Mn++) {
                let an = dt.getWordIndex(wt[Mn].normalize("NFKD"));
                if (-1 === an) throw new Error("invalid mnemonic");
                for (let En = 0; En < 11; En++) an & 1 << 10 - En && (Ut[Qt >> 3] |= 1 << 7 - Qt % 8), Qt++
            }
            const sn = 32 * wt.length / 3, Pn = w(wt.length / 3);
            if (((0, te.lE)((0, X.JQ)(Ut.slice(0, sn / 8)))[0] & Pn) != (Ut[Ut.length - 1] & Pn)) throw new Error("invalid checksum");
            return (0, te.Dv)(Ut.slice(0, sn / 8))
        }

        function ut(gt, dt) {
            if (dt = E(dt), (gt = (0, te.lE)(gt)).length % 4 != 0 || gt.length < 16 || gt.length > 32) throw new Error("invalid entropy");
            const wt = [0];
            let Ut = 11;
            for (let un = 0; un < gt.length; un++) Ut > 8 ? (wt[wt.length - 1] <<= 8, wt[wt.length - 1] |= gt[un], Ut -= 8) : (wt[wt.length - 1] <<= Ut, wt[wt.length - 1] |= gt[un] >> 8 - Ut, wt.push(gt[un] & P(8 - Ut)), Ut += 3);
            const Qt = gt.length / 4, sn = (0, te.lE)((0, X.JQ)(gt))[0] & w(Qt);
            return wt[wt.length - 1] <<= Qt, wt[wt.length - 1] |= sn >> 8 - Qt, dt.join(wt.map(un => dt.getWord(un)))
        }

        const Pt = new he.Yd("random/5.6.1"), yn = function Gt() {
            if ("undefined" != typeof self) return self;
            if ("undefined" != typeof window) return window;
            if ("undefined" != typeof global) return global;
            throw new Error("unable to locate global object")
        }();
        let Xt = yn.crypto || yn.msCrypto;

        function xn(gt) {
            (gt <= 0 || gt > 1024 || gt % 1 || gt != gt) && Pt.throwArgumentError("invalid length", "length", gt);
            const dt = new Uint8Array(gt);
            return Xt.getRandomValues(dt), (0, te.lE)(dt)
        }

        (!Xt || !Xt.getRandomValues) && (Pt.warn("WARNING: Missing strong random number source"), Xt = {
            getRandomValues: function (gt) {
                return Pt.throwError("no secure random source avaialble", he.Yd.errors.UNSUPPORTED_OPERATION, {operation: "crypto.getRandomValues"})
            }
        });
        var Fn = R(240), wn = R.n(Fn);
        const Nn = "json-wallets/5.6.1";

        function On(gt) {
            return "string" == typeof gt && "0x" !== gt.substring(0, 2) && (gt = "0x" + gt), (0, te.lE)(gt)
        }

        function Me(gt, dt) {
            for (gt = String(gt); gt.length < dt;) gt = "0" + gt;
            return gt
        }

        function ne(gt) {
            return "string" == typeof gt ? (0, W.Y0)(gt, W.Uj.NFKC) : (0, te.lE)(gt)
        }

        function U(gt, dt) {
            let wt = gt;
            const Ut = dt.toLowerCase().split("/");
            for (let Qt = 0; Qt < Ut.length; Qt++) {
                let sn = null;
                for (const un in wt) if (un.toLowerCase() === Ut[Qt]) {
                    sn = wt[un];
                    break
                }
                if (null === sn) return null;
                wt = sn
            }
            return wt
        }

        function de(gt) {
            const dt = (0, te.lE)(gt);
            dt[6] = 15 & dt[6] | 64, dt[8] = 63 & dt[8] | 128;
            const wt = (0, te.Dv)(dt);
            return [wt.substring(2, 10), wt.substring(10, 14), wt.substring(14, 18), wt.substring(18, 22), wt.substring(22, 34)].join("-")
        }

        const Ze = new he.Yd(Nn);

        class Ge extends H.dk {
            isCrowdsaleAccount(dt) {
                return !(!dt || !dt._isCrowdsaleAccount)
            }
        }

        function ye(gt, dt) {
            const wt = JSON.parse(gt);
            dt = ne(dt);
            const Ut = (0, r.Kn)(U(wt, "ethaddr")), Qt = On(U(wt, "encseed"));
            (!Qt || Qt.length % 16 != 0) && Ze.throwArgumentError("invalid encseed", "json", gt);
            const sn = (0, te.lE)(M(dt, dt, 2e3, 32, "sha256")).slice(0, 16), un = Qt.slice(0, 16), Pn = Qt.slice(16),
                mn = new (wn().ModeOfOperation.cbc)(sn, un), Mn = wn().padding.pkcs7.strip((0, te.lE)(mn.decrypt(Pn)));
            let an = "";
            for (let ar = 0; ar < Mn.length; ar++) an += String.fromCharCode(Mn[ar]);
            const En = (0, W.Y0)(an), Sn = (0, j.w)(En);
            return new Ge({_isCrowdsaleAccount: !0, address: Ut, privateKey: Sn})
        }

        function Te(gt) {
            let dt = null;
            try {
                dt = JSON.parse(gt)
            } catch (wt) {
                return !1
            }
            return dt.encseed && dt.ethaddr
        }

        function Be(gt) {
            let dt = null;
            try {
                dt = JSON.parse(gt)
            } catch (wt) {
                return !1
            }
            return !(!dt.version || parseInt(dt.version) !== dt.version || 3 !== parseInt(dt.version))
        }

        var Dt = R(2708), Ft = R.n(Dt);
        const dn = new he.Yd(Nn);

        function Bt(gt) {
            return null != gt && gt.mnemonic && gt.mnemonic.phrase
        }

        class Ht extends H.dk {
            isKeystoreAccount(dt) {
                return !(!dt || !dt._isKeystoreAccount)
            }
        }

        function fn(gt, dt) {
            const wt = On(U(gt, "crypto/ciphertext"));
            if ((0, te.Dv)((0, j.w)((0, te.zo)([dt.slice(16, 32), wt]))).substring(2) !== U(gt, "crypto/mac").toLowerCase()) throw new Error("invalid password");
            const Qt = function bn(gt, dt, wt) {
                if ("aes-128-ctr" === U(gt, "crypto/cipher")) {
                    const Qt = On(U(gt, "crypto/cipherparams/iv")), sn = new (wn().Counter)(Qt),
                        un = new (wn().ModeOfOperation.ctr)(dt, sn);
                    return (0, te.lE)(un.decrypt(wt))
                }
                return null
            }(gt, dt.slice(0, 16), wt);
            Qt || dn.throwError("unsupported cipher", he.Yd.errors.UNSUPPORTED_OPERATION, {operation: "decrypt"});
            const sn = dt.slice(32, 64), un = (0, ge.db)(Qt);
            if (gt.address) {
                let mn = gt.address.toLowerCase();
                if ("0x" !== mn.substring(0, 2) && (mn = "0x" + mn), (0, r.Kn)(mn) !== un) throw new Error("address mismatch")
            }
            const Pn = {_isKeystoreAccount: !0, address: un, privateKey: (0, te.Dv)(Qt)};
            if ("0.1" === U(gt, "x-ethers/version")) {
                const mn = On(U(gt, "x-ethers/mnemonicCiphertext")), Mn = On(U(gt, "x-ethers/mnemonicCounter")),
                    an = new (wn().Counter)(Mn), En = new (wn().ModeOfOperation.ctr)(sn, an),
                    Sn = U(gt, "x-ethers/path") || ze, ar = U(gt, "x-ethers/locale") || "en",
                    Un = (0, te.lE)(En.decrypt(mn));
                try {
                    const nn = ut(Un, ar), _n = Je.fromMnemonic(nn, null, ar).derivePath(Sn);
                    if (_n.privateKey != Pn.privateKey) throw new Error("mnemonic mismatch");
                    Pn.mnemonic = _n.mnemonic
                } catch (nn) {
                    if (nn.code !== he.Yd.errors.INVALID_ARGUMENT || "wordlist" !== nn.argument) throw nn
                }
            }
            return new Ht(Pn)
        }

        function rn(gt, dt, wt, Ut, Qt) {
            return (0, te.lE)(M(gt, dt, wt, Ut, Qt))
        }

        function gn(gt, dt, wt, Ut, Qt) {
            return Promise.resolve(rn(gt, dt, wt, Ut, Qt))
        }

        function Hn(gt, dt, wt, Ut, Qt) {
            const sn = ne(dt), un = U(gt, "crypto/kdf");
            if (un && "string" == typeof un) {
                const Pn = function (mn, Mn) {
                    return dn.throwArgumentError("invalid key-derivation function parameters", mn, Mn)
                };
                if ("scrypt" === un.toLowerCase()) {
                    const mn = On(U(gt, "crypto/kdfparams/salt")), Mn = parseInt(U(gt, "crypto/kdfparams/n")),
                        an = parseInt(U(gt, "crypto/kdfparams/r")), En = parseInt(U(gt, "crypto/kdfparams/p"));
                    (!Mn || !an || !En) && Pn("kdf", un), 0 != (Mn & Mn - 1) && Pn("N", Mn);
                    const Sn = parseInt(U(gt, "crypto/kdfparams/dklen"));
                    return 32 !== Sn && Pn("dklen", Sn), Ut(sn, mn, Mn, an, En, 64, Qt)
                }
                if ("pbkdf2" === un.toLowerCase()) {
                    const mn = On(U(gt, "crypto/kdfparams/salt"));
                    let Mn = null;
                    const an = U(gt, "crypto/kdfparams/prf");
                    "hmac-sha256" === an ? Mn = "sha256" : "hmac-sha512" === an ? Mn = "sha512" : Pn("prf", an);
                    const En = parseInt(U(gt, "crypto/kdfparams/c")), Sn = parseInt(U(gt, "crypto/kdfparams/dklen"));
                    return 32 !== Sn && Pn("dklen", Sn), wt(sn, mn, En, Sn, Mn)
                }
            }
            return dn.throwArgumentError("unsupported key-derivation function", "kdf", un)
        }

        function Yn(gt, dt, wt) {
            if (Te(gt)) {
                wt && wt(0);
                const Ut = ye(gt, dt);
                return wt && wt(1), Promise.resolve(Ut)
            }
            return Be(gt) ? function fr(gt, dt, wt) {
                return function (gt, dt, wt, Ut) {
                    return new (wt || (wt = Promise))(function (sn, un) {
                        function Pn(an) {
                            try {
                                Mn(Ut.next(an))
                            } catch (En) {
                                un(En)
                            }
                        }

                        function mn(an) {
                            try {
                                Mn(Ut.throw(an))
                            } catch (En) {
                                un(En)
                            }
                        }

                        function Mn(an) {
                            an.done ? sn(an.value) : function Qt(sn) {
                                return sn instanceof wt ? sn : new wt(function (un) {
                                    un(sn)
                                })
                            }(an.value).then(Pn, mn)
                        }

                        Mn((Ut = Ut.apply(gt, dt || [])).next())
                    })
                }(this, void 0, void 0, function* () {
                    const Ut = JSON.parse(gt);
                    return fn(Ut, yield Hn(Ut, dt, gn, Ft().scrypt, wt))
                })
            }(gt, dt, wt) : Promise.reject(new Error("invalid JSON wallet"))
        }

        var Xn = function (gt, dt, wt, Ut) {
            return new (wt || (wt = Promise))(function (sn, un) {
                function Pn(an) {
                    try {
                        Mn(Ut.next(an))
                    } catch (En) {
                        un(En)
                    }
                }

                function mn(an) {
                    try {
                        Mn(Ut.throw(an))
                    } catch (En) {
                        un(En)
                    }
                }

                function Mn(an) {
                    an.done ? sn(an.value) : function Qt(sn) {
                        return sn instanceof wt ? sn : new wt(function (un) {
                            un(sn)
                        })
                    }(an.value).then(Pn, mn)
                }

                Mn((Ut = Ut.apply(gt, dt || [])).next())
            })
        };
        const Dr = new he.Yd("wallet/5.6.2");

        class Qe extends ie.E {
            constructor(dt, wt) {
                if (super(), function It(gt) {
                    return null != gt && (0, te.A7)(gt.privateKey, 32) && null != gt.address
                }(dt)) {
                    const Ut = new F.Et(dt.privateKey);
                    if ((0, H.zG)(this, "_signingKey", () => Ut), (0, H.zG)(this, "address", (0, ge.db)(this.publicKey)), this.address !== (0, r.Kn)(dt.address) && Dr.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), function vt(gt) {
                        const dt = gt.mnemonic;
                        return dt && dt.phrase
                    }(dt)) {
                        const Qt = dt.mnemonic;
                        (0, H.zG)(this, "_mnemonic", () => ({
                            phrase: Qt.phrase,
                            path: Qt.path || ze,
                            locale: Qt.locale || "en"
                        }));
                        const sn = this.mnemonic, un = Je.fromMnemonic(sn.phrase, null, sn.locale).derivePath(sn.path);
                        (0, ge.db)(un.privateKey) !== this.address && Dr.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]")
                    } else (0, H.zG)(this, "_mnemonic", () => null)
                } else {
                    if (F.Et.isSigningKey(dt)) "secp256k1" !== dt.curve && Dr.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), (0, H.zG)(this, "_signingKey", () => dt); else {
                        "string" == typeof dt && dt.match(/^[0-9a-f]*$/i) && 64 === dt.length && (dt = "0x" + dt);
                        const Ut = new F.Et(dt);
                        (0, H.zG)(this, "_signingKey", () => Ut)
                    }
                    (0, H.zG)(this, "_mnemonic", () => null), (0, H.zG)(this, "address", (0, ge.db)(this.publicKey))
                }
                wt && !D.zt.isProvider(wt) && Dr.throwArgumentError("invalid provider", "provider", wt), (0, H.zG)(this, "provider", wt || null)
            }

            get mnemonic() {
                return this._mnemonic()
            }

            get privateKey() {
                return this._signingKey().privateKey
            }

            get publicKey() {
                return this._signingKey().publicKey
            }

            getAddress() {
                return Promise.resolve(this.address)
            }

            connect(dt) {
                return new Qe(this, dt)
            }

            signTransaction(dt) {
                return (0, H.mE)(dt).then(wt => {
                    null != wt.from && ((0, r.Kn)(wt.from) !== this.address && Dr.throwArgumentError("transaction from address mismatch", "transaction.from", dt.from), delete wt.from);
                    const Ut = this._signingKey().signDigest((0, j.w)((0, ge.qC)(wt)));
                    return (0, ge.qC)(wt, Ut)
                })
            }

            signMessage(dt) {
                return Xn(this, void 0, void 0, function* () {
                    return (0, te.gV)(this._signingKey().signDigest(function Ne(gt) {
                        return "string" == typeof gt && (gt = (0, W.Y0)(gt)), (0, j.w)((0, te.zo)([(0, W.Y0)("\x19Ethereum Signed Message:\n"), (0, W.Y0)(String(gt.length)), gt]))
                    }(dt)))
                })
            }

            _signTypedData(dt, wt, Ut) {
                return Xn(this, void 0, void 0, function* () {
                    const Qt = yield ve.E.resolveNames(dt, wt, Ut, sn => (null == this.provider && Dr.throwError("cannot resolve ENS names without a provider", he.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: "resolveName",
                        value: sn
                    }), this.provider.resolveName(sn)));
                    return (0, te.gV)(this._signingKey().signDigest(ve.E.hash(Qt.domain, wt, Qt.value)))
                })
            }

            encrypt(dt, wt, Ut) {
                if ("function" == typeof wt && !Ut && (Ut = wt, wt = {}), Ut && "function" != typeof Ut) throw new Error("invalid callback");
                return wt || (wt = {}), function qn(gt, dt, wt, Ut) {
                    try {
                        if ((0, r.Kn)(gt.address) !== (0, ge.db)(gt.privateKey)) throw new Error("address/privateKey mismatch");
                        if (Bt(gt)) {
                            const _n = gt.mnemonic;
                            if (Je.fromMnemonic(_n.phrase, null, _n.locale).derivePath(_n.path || ze).privateKey != gt.privateKey) throw new Error("mnemonic mismatch")
                        }
                    } catch (_n) {
                        return Promise.reject(_n)
                    }
                    "function" == typeof wt && !Ut && (Ut = wt, wt = {}), wt || (wt = {});
                    const Qt = (0, te.lE)(gt.privateKey), sn = ne(dt);
                    let un = null, Pn = null, mn = null;
                    if (Bt(gt)) {
                        const _n = gt.mnemonic;
                        un = (0, te.lE)(Le(_n.phrase, _n.locale || "en")), Pn = _n.path || ze, mn = _n.locale || "en"
                    }
                    let Mn = wt.client;
                    Mn || (Mn = "ethers.js");
                    let an = null;
                    an = wt.salt ? (0, te.lE)(wt.salt) : xn(32);
                    let En = null;
                    if (wt.iv) {
                        if (En = (0, te.lE)(wt.iv), 16 !== En.length) throw new Error("invalid iv")
                    } else En = xn(16);
                    let Sn = null;
                    if (wt.uuid) {
                        if (Sn = (0, te.lE)(wt.uuid), 16 !== Sn.length) throw new Error("invalid uuid")
                    } else Sn = xn(16);
                    let ar = 1 << 17, Un = 8, nn = 1;
                    return wt.scrypt && (wt.scrypt.N && (ar = wt.scrypt.N), wt.scrypt.r && (Un = wt.scrypt.r), wt.scrypt.p && (nn = wt.scrypt.p)), Ft().scrypt(sn, an, ar, Un, nn, 64, Ut).then(_n => {
                        const tr = (_n = (0, te.lE)(_n)).slice(0, 16), nr = _n.slice(16, 32), Er = _n.slice(32, 64),
                            gr = new (wn().Counter)(En), Ir = new (wn().ModeOfOperation.ctr)(tr, gr),
                            rr = (0, te.lE)(Ir.encrypt(Qt)), br = (0, j.w)((0, te.zo)([nr, rr])), Vn = {
                                address: gt.address.substring(2).toLowerCase(),
                                id: de(Sn),
                                version: 3,
                                Crypto: {
                                    cipher: "aes-128-ctr",
                                    cipherparams: {iv: (0, te.Dv)(En).substring(2)},
                                    ciphertext: (0, te.Dv)(rr).substring(2),
                                    kdf: "scrypt",
                                    kdfparams: {salt: (0, te.Dv)(an).substring(2), n: ar, dklen: 32, p: nn, r: Un},
                                    mac: br.substring(2)
                                }
                            };
                        if (un) {
                            const $n = xn(16), Br = new (wn().Counter)($n), _r = new (wn().ModeOfOperation.ctr)(Er, Br),
                                Pe = (0, te.lE)(_r.encrypt(un)), We = new Date,
                                Et = We.getUTCFullYear() + "-" + Me(We.getUTCMonth() + 1, 2) + "-" + Me(We.getUTCDate(), 2) + "T" + Me(We.getUTCHours(), 2) + "-" + Me(We.getUTCMinutes(), 2) + "-" + Me(We.getUTCSeconds(), 2) + ".0Z";
                            Vn["x-ethers"] = {
                                client: Mn,
                                gethFilename: "UTC--" + Et + "--" + Vn.address,
                                mnemonicCounter: (0, te.Dv)($n).substring(2),
                                mnemonicCiphertext: (0, te.Dv)(Pe).substring(2),
                                path: Pn,
                                locale: mn,
                                version: "0.1"
                            }
                        }
                        return JSON.stringify(Vn)
                    })
                }(this, dt, wt, Ut)
            }

            static createRandom(dt) {
                let wt = xn(16);
                dt || (dt = {}), dt.extraEntropy && (wt = (0, te.lE)((0, te.p3)((0, j.w)((0, te.zo)([wt, dt.extraEntropy])), 0, 16)));
                const Ut = ut(wt, dt.locale);
                return Qe.fromMnemonic(Ut, dt.path, dt.locale)
            }

            static fromEncryptedJson(dt, wt, Ut) {
                return Yn(dt, wt, Ut).then(Qt => new Qe(Qt))
            }

            static fromEncryptedJsonSync(dt, wt) {
                return new Qe(function Qn(gt, dt) {
                    if (Te(gt)) return ye(gt, dt);
                    if (Be(gt)) return function jn(gt, dt) {
                        const wt = JSON.parse(gt);
                        return fn(wt, Hn(wt, dt, rn, Ft().syncScrypt))
                    }(gt, dt);
                    throw new Error("invalid JSON wallet")
                }(dt, wt))
            }

            static fromMnemonic(dt, wt, Ut) {
                return wt || (wt = ze), new Qe(Je.fromMnemonic(dt, null, Ut).derivePath(wt))
            }
        }
    }, 5419: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {KY: () => Ce, DM: () => $e, e4: () => Ee, J2: () => ce, Iq: () => I, G5: () => X});
        var D = R(2916), ie = R(3753), te = {error: "cordova_not_available"}, j = {error: "plugin_not_installed"};

        function W(l) {
            if ("undefined" != typeof window && window.angular) {
                var g = window.document, v = window.angular.element(g.querySelector("[ng-app]") || g.body).injector();
                if (v) return v.get("$q")(function (P, B) {
                    l(P, B)
                });
                console.warn("Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.")
            }
            return function () {
                if (Promise) return new Promise(function (P, B) {
                    l(P, B)
                });
                console.error("No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.")
            }()
        }

        function Q(l, f, g, v) {
            void 0 === v && (v = {});
            var w, P, B = W(function (O, E) {
                w = v.destruct ? H(l, f, g, v, function () {
                    for (var Z = [], ze = 0; ze < arguments.length; ze++) Z[ze] = arguments[ze];
                    return O(Z)
                }, function () {
                    for (var Z = [], ze = 0; ze < arguments.length; ze++) Z[ze] = arguments[ze];
                    return E(Z)
                }) : H(l, f, g, v, O, E), P = E
            });
            return w && w.error && (B.catch(function () {
            }), "function" == typeof P && P(w.error)), B
        }

        function Ne(l, f, g, v) {
            return void 0 === v && (v = {}), W(function (w, P) {
                var B = H(l, f, g, v);
                B ? B.error ? P(B.error) : B.then && B.then(w).catch(P) : P({error: "unexpected_error"})
            })
        }

        function ve(l, f, g, v) {
            return void 0 === v && (v = {}), new D.y(function (w) {
                var P;
                return P = v.destruct ? H(l, f, g, v, function () {
                    for (var B = [], O = 0; O < arguments.length; O++) B[O] = arguments[O];
                    return w.next(B)
                }, function () {
                    for (var B = [], O = 0; O < arguments.length; O++) B[O] = arguments[O];
                    return w.error(B)
                }) : H(l, f, g, v, w.next.bind(w), w.error.bind(w)), P && P.error && (w.error(P.error), w.complete()), function () {
                    try {
                        if (v.clearFunction) return v.clearWithArgs ? H(l, v.clearFunction, g, v, w.next.bind(w), w.error.bind(w)) : H(l, v.clearFunction, [])
                    } catch (B) {
                        console.warn("Unable to clear the previous observable watch for", l.constructor.getPluginName(), f), console.warn(B)
                    }
                }
            })
        }

        function me(l, f) {
            return f = "undefined" != typeof window && f ? ge(window, f) : f || ("undefined" != typeof window ? window : {}), (0, ie.R)(f, l)
        }

        function ae(l, f, g) {
            var v, w, P;
            return "string" == typeof l ? v = l : (v = l.constructor.getPluginRef(), g = l.constructor.getPluginName(), P = l.constructor.getPluginInstallName()), !(!(w = oe(v)) || f && void 0 === w[f]) || ("undefined" != typeof window && window.cordova ? (function Ie(l, f, g) {
                console.warn(g ? "Native: tried calling " + l + "." + g + ", but the " + l + " plugin is not installed." : "Native: tried accessing the " + l + " plugin but it's not installed."), f && console.warn("Install the " + l + " plugin: 'ionic cordova plugin add " + f + "'")
            }(g, P, f), j) : (function he(l, f) {
                "undefined" == typeof process && console.warn(f ? "Native: tried calling " + l + "." + f + ", but Cordova is not available. Make sure to include cordova.js or run in a device/simulator" : "Native: tried accessing the " + l + " plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator")
            }(g, f), te))
        }

        function X(l, f) {
            return l._objectInstance && (!f || void 0 !== l._objectInstance[f])
        }

        function M(l, f, g, v) {
            if (void 0 === f && (f = {}), f.sync) return l;
            if ("reverse" === f.callbackOrder) l.unshift(v), l.unshift(g); else if ("node" === f.callbackStyle) l.push(function (O, E) {
                O ? v(O) : g(E)
            }); else if ("object" === f.callbackStyle && f.successName && f.errorName) {
                var w = {};
                w[f.successName] = g, w[f.errorName] = v, l.push(w)
            } else if (void 0 !== f.successIndex || void 0 !== f.errorIndex) {
                var P = function () {
                    f.successIndex > l.length ? l[f.successIndex] = g : l.splice(f.successIndex, 0, g)
                }, B = function () {
                    f.errorIndex > l.length ? l[f.errorIndex] = v : l.splice(f.errorIndex, 0, v)
                };
                f.successIndex > f.errorIndex ? (B(), P()) : (P(), B())
            } else l.push(g), l.push(v);
            return l
        }

        function H(l, f, g, v, w, P) {
            void 0 === v && (v = {}), g = M(g, v, w, P);
            var B = ae(l, f);
            if (!0 === B) {
                var O = oe(l.constructor.getPluginRef());
                return O[f].apply(O, g)
            }
            return B
        }

        function F(l, f, g, v, w, P) {
            if (void 0 === v && (v = {}), g = M(g, v, w, P), X(l, f)) return l._objectInstance[f].apply(l._objectInstance, g)
        }

        function oe(l) {
            return "undefined" != typeof window ? ge(window, l) : null
        }

        function ge(l, f) {
            for (var g = f.split("."), v = l, w = 0; w < g.length; w++) {
                if (!v) return null;
                v = v[g[w]]
            }
            return v
        }

        var Ce = function () {
            function l() {
            }

            return l.installed = function () {
                return !0 === ae(this.pluginRef)
            }, l.getPlugin = function () {
                return "undefined" != typeof window ? function it(l, f) {
                    for (var g = f.split("."), v = l, w = 0; w < g.length; w++) {
                        if (!v) return null;
                        v = v[g[w]]
                    }
                    return v
                }(window, this.pluginRef) : null
            }, l.getPluginName = function () {
                return this.pluginName
            }, l.getPluginRef = function () {
                return this.pluginRef
            }, l.getPluginInstallName = function () {
                return this.plugin
            }, l.getSupportedPlatforms = function () {
                return this.platforms
            }, l.pluginName = "", l.pluginRef = "", l.plugin = "", l.repo = "", l.platforms = [], l.install = "", l
        }();

        function $e(l, f, g, v) {
            return function (l, f, g) {
                return void 0 === g && (g = {}), function () {
                    for (var v = [], w = 0; w < arguments.length; w++) v[w] = arguments[w];
                    return g.sync ? H(l, f, v, g) : g.observable ? ve(l, f, v, g) : g.eventObservable && g.event ? me(g.event, g.element) : g.otherPromise ? Ne(l, f, v, g) : Q(l, f, v, g)
                }
            }(l, f, g).apply(this, v)
        }

        function Ee(l, f, g, v) {
            return v = Array.from(v), function Ue(l, f, g) {
                return void 0 === g && (g = {}), function () {
                    for (var v = [], w = 0; w < arguments.length; w++) v[w] = arguments[w];
                    if (g.sync) return F(l, f, v, g);
                    if (g.observable) return new D.y(function (E) {
                        var Z;
                        return Z = g.destruct ? F(l, f, v, g, function () {
                            for (var ze = [], Je = 0; Je < arguments.length; Je++) ze[Je] = arguments[Je];
                            return E.next(ze)
                        }, function () {
                            for (var ze = [], Je = 0; Je < arguments.length; Je++) ze[Je] = arguments[Je];
                            return E.error(ze)
                        }) : F(l, f, v, g, E.next.bind(E), E.error.bind(E)), Z && Z.error && E.error(Z.error), function () {
                            try {
                                return g.clearWithArgs ? F(l, g.clearFunction, v, g, E.next.bind(E), E.error.bind(E)) : F(l, g.clearFunction, [])
                            } catch (ze) {
                                console.warn("Unable to clear the previous observable watch for", l.constructor.getPluginName(), f), console.warn(ze)
                            }
                        }
                    });
                    if (g.otherPromise) return W(function (E, Z) {
                        var ze;
                        ze = g.destruct ? F(l, f, v, g, function () {
                            for (var Je = [], q = 0; q < arguments.length; q++) Je[q] = arguments[q];
                            return E(Je)
                        }, function () {
                            for (var Je = [], q = 0; q < arguments.length; q++) Je[q] = arguments[q];
                            return Z(Je)
                        }) : F(l, f, v, g, E, Z), ze && ze.then ? ze.then(E, Z) : Z()
                    });
                    var P, B, O = W(function (E, Z) {
                        P = g.destruct ? F(l, f, v, g, function () {
                            for (var ze = [], Je = 0; Je < arguments.length; Je++) ze[Je] = arguments[Je];
                            return E(ze)
                        }, function () {
                            for (var ze = [], Je = 0; Je < arguments.length; Je++) ze[Je] = arguments[Je];
                            return Z(ze)
                        }) : F(l, f, v, g, E, Z), B = Z
                    });
                    return P && P.error && (O.catch(function () {
                    }), "function" == typeof B && B(P.error)), O
                }
            }(l, f, g).apply(this, v)
        }

        function ce(l, f) {
            return !0 === ae(l, f) ? oe(l.constructor.getPluginRef())[f] : null
        }

        function I(l, f, g) {
            !0 === ae(l, f) && (oe(l.constructor.getPluginRef())[f] = g)
        }

        !function r() {
            if ("undefined" == typeof process) {
                var l = "undefined" != typeof window ? window : {}, g = Date.now(), v = !1;
                l.document.addEventListener("deviceready", function () {
                    console.log("Ionic Native: deviceready event fired after " + (Date.now() - g) + " ms"), v = !0
                }), setTimeout(function () {
                    !v && l.cordova && console.warn("Ionic Native: deviceready did not fire within 5000ms. This can happen when plugins are in an inconsistent state. Try removing plugins from plugins/ and reinstalling them.")
                }, 5e3)
            }
        }()
    }, 2869: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {E: () => te});
        var r = R(655), D = R(5419), ie = R(6435), te = function (j) {
            function W() {
                return null !== j && j.apply(this, arguments) || this
            }

            return (0, r.ZT)(W, j), W.prototype.auth = function () {
                return (0, D.DM)(this, "auth", {}, arguments)
            }, W.prototype.signOut = function () {
                return (0, D.DM)(this, "signOut", {}, arguments)
            }, W.prototype.isSignedIn = function () {
                return (0, D.DM)(this, "isSignedIn", {}, arguments)
            }, W.prototype.showPlayer = function () {
                return (0, D.DM)(this, "showPlayer", {}, arguments)
            }, W.prototype.submitScore = function (Q) {
                return (0, D.DM)(this, "submitScore", {}, arguments)
            }, W.prototype.submitScoreNow = function (Q) {
                return (0, D.DM)(this, "submitScoreNow", {}, arguments)
            }, W.prototype.getPlayerScore = function (Q) {
                return (0, D.DM)(this, "getPlayerScore", {}, arguments)
            }, W.prototype.showAllLeaderboards = function () {
                return (0, D.DM)(this, "showAllLeaderboards", {}, arguments)
            }, W.prototype.showLeaderboard = function (Q) {
                return (0, D.DM)(this, "showLeaderboard", {}, arguments)
            }, W.prototype.unlockAchievement = function (Q) {
                return (0, D.DM)(this, "unlockAchievement", {}, arguments)
            }, W.prototype.unlockAchievementNow = function (Q) {
                return (0, D.DM)(this, "unlockAchievementNow", {}, arguments)
            }, W.prototype.incrementAchievement = function (Q) {
                return (0, D.DM)(this, "incrementAchievement", {}, arguments)
            }, W.prototype.incrementAchievementNow = function (Q) {
                return (0, D.DM)(this, "incrementAchievementNow", {}, arguments)
            }, W.prototype.showAchievements = function () {
                return (0, D.DM)(this, "showAchievements", {}, arguments)
            }, W.pluginName = "GooglePlayGamesServices", W.plugin = "cordova-plugin-play-games-services", W.pluginRef = "plugins.playGamesServices", W.repo = "https://github.com/artberri/cordova-plugin-play-games-services", W.platforms = ["Android"], W.install = 'ionic cordova plugin add cordova-plugin-play-games-services --variable APP_ID="YOUR_APP_ID', W.\u0275fac = function () {
                var Q;
                return function (ve) {
                    return (Q || (Q = ie.n5z(W)))(ve || W)
                }
            }(), W.\u0275prov = ie.Yz7({
                token: W, factory: function (Q) {
                    return W.\u0275fac(Q)
                }
            }), W
        }(D.KY)
    }, 7609: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            Br: () => vr,
            vB: () => Gr,
            w: () => Pt,
            Cb: () => Or,
            dr: () => de,
            YG: () => Dt,
            PM: () => zt,
            nz: () => fn,
            wI: () => gn,
            W2: () => Hn,
            jY: () => Xn,
            Gu: () => Dr,
            gu: () => It,
            pK: () => jt,
            Ie: () => gt,
            Q$: () => un,
            ki: () => mt,
            H$: () => br,
            jP: () => ai,
            Nd: () => Vn,
            PQ: () => at,
            wd: () => Zn,
            sr: () => xr,
            Pc: () => _e,
            r4: () => re,
            IN: () => Tr,
            SH: () => vi,
            X1: () => $r,
            t4: () => ti,
            j9: () => xn,
            yF: () => Ar
        });
        var r = R(6435), D = R(4182), ie = R(655), te = R(3753), j = R(5529), W = R(591), Q = R(9800), Ne = R(9442),
            ae = (R(4181), R(5980), R(8685)), M = (R(3139), R(5729)), H = R(3756), F = R(9753), ge = (R(97), R(3280)),
            he = (R(3509), R(7205)), $e = R(3489);

        class Xe {
            constructor(G, m) {
                this.compare = G, this.keySelector = m
            }

            call(G, m) {
                return m.subscribe(new Ee(G, this.compare, this.keySelector))
            }
        }

        class Ee extends $e.L {
            constructor(G, m, K) {
                super(G), this.keySelector = K, this.hasKey = !1, "function" == typeof m && (this.compare = m)
            }

            compare(G, m) {
                return G === m
            }

            _next(G) {
                let m;
                try {
                    const {keySelector: Re} = this;
                    m = Re ? Re(G) : G
                } catch (Re) {
                    return this.destination.error(Re)
                }
                let K = !1;
                if (this.hasKey) try {
                    const {compare: Re} = this;
                    K = Re(this.key, m)
                } catch (Re) {
                    return this.destination.error(Re)
                } else this.hasKey = !0;
                K || (this.key = m, this.destination.next(G))
            }
        }

        var ce = R(2198), I = R(7545), l = R(9808);
        const g = M.i, P = ["*"];

        function Z(h, G) {
            if (1 & h && (r.TgZ(0, "div", 1), r.GkF(1, 2), r.qZA()), 2 & h) {
                const m = r.oxw();
                r.xp6(1), r.Q6J("ngTemplateOutlet", m.template)
            }
        }

        const Je = h => "function" == typeof __zone_symbol__requestAnimationFrame ? __zone_symbol__requestAnimationFrame(h) : "function" == typeof requestAnimationFrame ? requestAnimationFrame(h) : setTimeout(h),
            q = h => !!h.resolveComponentFactory;
        let Le = (() => {
            class h {
                constructor(m, K) {
                    this.injector = m, this.el = K, this.onChange = () => {
                    }, this.onTouched = () => {
                    }
                }

                writeValue(m) {
                    this.el.nativeElement.value = this.lastValue = null == m ? "" : m, ut(this.el)
                }

                handleChangeEvent(m, K) {
                    m === this.el.nativeElement && (K !== this.lastValue && (this.lastValue = K, this.onChange(K)), ut(this.el))
                }

                _handleBlurEvent(m) {
                    m === this.el.nativeElement && (this.onTouched(), ut(this.el))
                }

                registerOnChange(m) {
                    this.onChange = m
                }

                registerOnTouched(m) {
                    this.onTouched = m
                }

                setDisabledState(m) {
                    this.el.nativeElement.disabled = m
                }

                ngOnDestroy() {
                    this.statusChanges && this.statusChanges.unsubscribe()
                }

                ngAfterViewInit() {
                    let m;
                    try {
                        m = this.injector.get(D.a5)
                    } catch (Re) {
                    }
                    if (!m) return;
                    m.statusChanges && (this.statusChanges = m.statusChanges.subscribe(() => ut(this.el)));
                    const K = m.control;
                    K && ["markAsTouched", "markAllAsTouched", "markAsUntouched", "markAsDirty", "markAsPristine"].forEach(kt => {
                        if (void 0 !== K[kt]) {
                            const Dn = K[kt].bind(K);
                            K[kt] = (...Lt) => {
                                Dn(...Lt), ut(this.el)
                            }
                        }
                    })
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.zs3), r.Y36(r.SBq))
            }, h.\u0275dir = r.lG2({
                type: h, hostBindings: function (m, K) {
                    1 & m && r.NdJ("ionBlur", function (kt) {
                        return K._handleBlurEvent(kt.target)
                    })
                }
            }), h
        })();
        const ut = h => {
            Je(() => {
                const G = h.nativeElement, m = null != G.value && G.value.toString().length > 0, K = Ye(G);
                Mt(G, K);
                const Re = G.closest("ion-item");
                Re && Mt(Re, m ? [...K, "item-has-value"] : K)
            })
        }, Ye = h => {
            const G = h.classList, m = [];
            for (let K = 0; K < G.length; K++) {
                const Re = G.item(K);
                null !== Re && _t(Re, "ng-") && m.push(`ion-${Re.substring(3)}`)
            }
            return m
        }, Mt = (h, G) => {
            const m = h.classList;
            m.remove("ion-valid", "ion-invalid", "ion-touched", "ion-untouched", "ion-dirty", "ion-pristine"), m.add(...G)
        }, _t = (h, G) => h.substring(0, G.length) === G;
        let Pt = (() => {
            class h extends Le {
                constructor(m, K) {
                    super(m, K)
                }

                writeValue(m) {
                    this.el.nativeElement.checked = this.lastValue = null != m && m, ut(this.el)
                }

                _handleIonChange(m) {
                    this.handleChangeEvent(m, m.checked)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.zs3), r.Y36(r.SBq))
            }, h.\u0275dir = r.lG2({
                type: h,
                selectors: [["ion-checkbox"], ["ion-toggle"]],
                hostBindings: function (m, K) {
                    1 & m && r.NdJ("ionChange", function (kt) {
                        return K._handleIonChange(kt.target)
                    })
                },
                features: [r._Bn([{provide: D.JU, useExisting: h, multi: !0}]), r.qOj]
            }), h
        })(), xn = (() => {
            class h extends Le {
                constructor(m, K) {
                    super(m, K)
                }

                _handleInputEvent(m) {
                    this.handleChangeEvent(m, m.value)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.zs3), r.Y36(r.SBq))
            }, h.\u0275dir = r.lG2({
                type: h,
                selectors: [["ion-input", 3, "type", "number"], ["ion-textarea"], ["ion-searchbar"]],
                hostBindings: function (m, K) {
                    1 & m && r.NdJ("ionChange", function (kt) {
                        return K._handleInputEvent(kt.target)
                    })
                },
                features: [r._Bn([{provide: D.JU, useExisting: h, multi: !0}]), r.qOj]
            }), h
        })();
        const Fn = (h, G) => {
            const m = h.prototype;
            G.forEach(K => {
                Object.defineProperty(m, K, {
                    get() {
                        return this.el[K]
                    }, set(Re) {
                        this.z.runOutsideAngular(() => this.el[K] = Re)
                    }
                })
            })
        }, wn = (h, G) => {
            const m = h.prototype;
            G.forEach(K => {
                m[K] = function () {
                    const Re = arguments;
                    return this.z.runOutsideAngular(() => this.el[K].apply(this.el, Re))
                }
            })
        }, Nn = (h, G, m) => {
            m.forEach(K => h[K] = (0, te.R)(G, K))
        };

        function Me(h) {
            return function (m) {
                const {defineCustomElementFn: K, inputs: Re, methods: kt} = h;
                return void 0 !== K && K(), Re && Fn(m, Re), kt && wn(m, kt), m
            }
        }

        let de = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-app"]],
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0})], h), h
        })(), Dt = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement, Nn(this, this.el, ["ionFocus", "ionBlur"])
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-button"]],
                inputs: {
                    buttonType: "buttonType",
                    color: "color",
                    disabled: "disabled",
                    download: "download",
                    expand: "expand",
                    fill: "fill",
                    href: "href",
                    mode: "mode",
                    rel: "rel",
                    routerAnimation: "routerAnimation",
                    routerDirection: "routerDirection",
                    shape: "shape",
                    size: "size",
                    strong: "strong",
                    target: "target",
                    type: "type"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["buttonType", "color", "disabled", "download", "expand", "fill", "href", "mode", "rel", "routerAnimation", "routerDirection", "shape", "size", "strong", "target", "type"]
            })], h), h
        })(), zt = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-card"]],
                inputs: {
                    button: "button",
                    color: "color",
                    disabled: "disabled",
                    download: "download",
                    href: "href",
                    mode: "mode",
                    rel: "rel",
                    routerAnimation: "routerAnimation",
                    routerDirection: "routerDirection",
                    target: "target",
                    type: "type"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["button", "color", "disabled", "download", "href", "mode", "rel", "routerAnimation", "routerDirection", "target", "type"]
            })], h), h
        })(), fn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement, Nn(this, this.el, ["ionChange", "ionFocus", "ionBlur"])
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-checkbox"]],
                inputs: {
                    checked: "checked",
                    color: "color",
                    disabled: "disabled",
                    indeterminate: "indeterminate",
                    mode: "mode",
                    name: "name",
                    value: "value"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["checked", "color", "disabled", "indeterminate", "mode", "name", "value"]
            })], h), h
        })(), gn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-col"]],
                inputs: {
                    offset: "offset",
                    offsetLg: "offsetLg",
                    offsetMd: "offsetMd",
                    offsetSm: "offsetSm",
                    offsetXl: "offsetXl",
                    offsetXs: "offsetXs",
                    pull: "pull",
                    pullLg: "pullLg",
                    pullMd: "pullMd",
                    pullSm: "pullSm",
                    pullXl: "pullXl",
                    pullXs: "pullXs",
                    push: "push",
                    pushLg: "pushLg",
                    pushMd: "pushMd",
                    pushSm: "pushSm",
                    pushXl: "pushXl",
                    pushXs: "pushXs",
                    size: "size",
                    sizeLg: "sizeLg",
                    sizeMd: "sizeMd",
                    sizeSm: "sizeSm",
                    sizeXl: "sizeXl",
                    sizeXs: "sizeXs"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["offset", "offsetLg", "offsetMd", "offsetSm", "offsetXl", "offsetXs", "pull", "pullLg", "pullMd", "pullSm", "pullXl", "pullXs", "push", "pushLg", "pushMd", "pushSm", "pushXl", "pushXs", "size", "sizeLg", "sizeMd", "sizeSm", "sizeXl", "sizeXs"]
            })], h), h
        })(), Hn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement, Nn(this, this.el, ["ionScrollStart", "ionScroll", "ionScrollEnd"])
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-content"]],
                inputs: {
                    color: "color",
                    forceOverscroll: "forceOverscroll",
                    fullscreen: "fullscreen",
                    scrollEvents: "scrollEvents",
                    scrollX: "scrollX",
                    scrollY: "scrollY"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["color", "forceOverscroll", "fullscreen", "scrollEvents", "scrollX", "scrollY"],
                methods: ["getScrollElement", "scrollToTop", "scrollToBottom", "scrollByPoint", "scrollToPoint"]
            })], h), h
        })(), Xn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-grid"]],
                inputs: {fixed: "fixed"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["fixed"]})], h), h
        })(), Dr = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-header"]],
                inputs: {collapse: "collapse", mode: "mode", translucent: "translucent"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["collapse", "mode", "translucent"]})], h), h
        })(), It = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-icon"]],
                inputs: {
                    color: "color",
                    flipRtl: "flipRtl",
                    icon: "icon",
                    ios: "ios",
                    lazy: "lazy",
                    md: "md",
                    mode: "mode",
                    name: "name",
                    sanitize: "sanitize",
                    size: "size",
                    src: "src"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["color", "flipRtl", "icon", "ios", "lazy", "md", "mode", "name", "sanitize", "size", "src"]
            })], h), h
        })(), jt = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement, Nn(this, this.el, ["ionInput", "ionChange", "ionBlur", "ionFocus"])
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-input"]],
                inputs: {
                    accept: "accept",
                    autocapitalize: "autocapitalize",
                    autocomplete: "autocomplete",
                    autocorrect: "autocorrect",
                    autofocus: "autofocus",
                    clearInput: "clearInput",
                    clearOnEdit: "clearOnEdit",
                    color: "color",
                    debounce: "debounce",
                    disabled: "disabled",
                    enterkeyhint: "enterkeyhint",
                    inputmode: "inputmode",
                    max: "max",
                    maxlength: "maxlength",
                    min: "min",
                    minlength: "minlength",
                    mode: "mode",
                    multiple: "multiple",
                    name: "name",
                    pattern: "pattern",
                    placeholder: "placeholder",
                    readonly: "readonly",
                    required: "required",
                    size: "size",
                    spellcheck: "spellcheck",
                    step: "step",
                    type: "type",
                    value: "value"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["accept", "autocapitalize", "autocomplete", "autocorrect", "autofocus", "clearInput", "clearOnEdit", "color", "debounce", "disabled", "enterkeyhint", "inputmode", "max", "maxlength", "min", "minlength", "mode", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "spellcheck", "step", "type", "value"],
                methods: ["setFocus", "getInputElement"]
            })], h), h
        })(), gt = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-item"]],
                inputs: {
                    button: "button",
                    color: "color",
                    counter: "counter",
                    counterFormatter: "counterFormatter",
                    detail: "detail",
                    detailIcon: "detailIcon",
                    disabled: "disabled",
                    download: "download",
                    fill: "fill",
                    href: "href",
                    lines: "lines",
                    mode: "mode",
                    rel: "rel",
                    routerAnimation: "routerAnimation",
                    routerDirection: "routerDirection",
                    shape: "shape",
                    target: "target",
                    type: "type"
                },
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["button", "color", "counter", "counterFormatter", "detail", "detailIcon", "disabled", "download", "fill", "href", "lines", "mode", "rel", "routerAnimation", "routerDirection", "shape", "target", "type"]
            })], h), h
        })(), un = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-label"]],
                inputs: {color: "color", mode: "mode", position: "position"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["color", "mode", "position"]})], h), h
        })(), br = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-ripple-effect"]],
                inputs: {type: "type"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["type"], methods: ["addRipple"]})], h), h
        })(), Vn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-row"]],
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0})], h), h
        })(), at = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-spinner"]],
                inputs: {color: "color", duration: "duration", name: "name", paused: "paused"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                defineCustomElementFn: void 0,
                inputs: ["color", "duration", "name", "paused"]
            })], h), h
        })(), Zn = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-title"]],
                inputs: {color: "color", size: "size"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["color", "size"]})], h), h
        })(), xr = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, m.detach(), this.el = K.nativeElement
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-toolbar"]],
                inputs: {color: "color", mode: "mode"},
                ngContentSelectors: P,
                decls: 1,
                vars: 0,
                template: function (m, K) {
                    1 & m && (r.F$t(), r.Hsn(0))
                },
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({defineCustomElementFn: void 0, inputs: ["color", "mode"]})], h), h
        })();

        class $r {
            constructor(G = {}) {
                this.data = G
            }

            get(G) {
                return this.data[G]
            }
        }

        let Nr = (() => {
            class h {
                constructor(m, K) {
                    this.zone = m, this.appRef = K
                }

                create(m, K, Re) {
                    return new li(m, K, Re, this.appRef, this.zone)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.LFG(r.R0b), r.LFG(r.z2F))
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac}), h
        })();

        class li {
            constructor(G, m, K, Re, kt) {
                this.resolverOrInjector = G, this.injector = m, this.location = K, this.appRef = Re, this.zone = kt, this.elRefMap = new WeakMap, this.elEventsMap = new WeakMap
            }

            attachViewToDom(G, m, K, Re) {
                return this.zone.run(() => new Promise(kt => {
                    kt(Ci(this.zone, this.resolverOrInjector, this.injector, this.location, this.appRef, this.elRefMap, this.elEventsMap, G, m, K, Re))
                }))
            }

            removeViewFromDom(G, m) {
                return this.zone.run(() => new Promise(K => {
                    const Re = this.elRefMap.get(m);
                    if (Re) {
                        Re.destroy(), this.elRefMap.delete(m);
                        const kt = this.elEventsMap.get(m);
                        kt && (kt(), this.elEventsMap.delete(m))
                    }
                    K()
                }))
            }
        }

        const Ci = (h, G, m, K, Re, kt, Dn, Lt, In, mr, dr) => {
                let Mr;
                const Vr = r.zs3.create({providers: Pi(mr), parent: m});
                if (G && q(G)) {
                    const Hi = G.resolveComponentFactory(In);
                    Mr = K ? K.createComponent(Hi, K.length, Vr) : Hi.create(Vr)
                } else {
                    if (!K) return null;
                    Mr = K.createComponent(In, {index: K.indexOf, injector: Vr, environmentInjector: G})
                }
                const Kr = Mr.instance, Zr = Mr.location.nativeElement;
                if (mr && Object.assign(Kr, mr), dr) for (const Hi of dr) Zr.classList.add(Hi);
                const Ai = $i(h, Kr, Zr);
                return Lt.appendChild(Zr), K || Re.attachView(Mr.hostView), Mr.changeDetectorRef.reattach(), kt.set(Zr, Mr), Dn.set(Zr, Ai), Zr
            }, hi = [F.L, F.a, F.b, F.c, F.d], $i = (h, G, m) => h.run(() => {
                const K = hi.filter(Re => "function" == typeof G[Re]).map(Re => {
                    const kt = Dn => G[Re](Dn.detail);
                    return m.addEventListener(Re, kt), () => m.removeEventListener(Re, kt)
                });
                return () => K.forEach(Re => Re())
            }), ki = new r.OlP("NavParamsToken"),
            Pi = h => [{provide: ki, useValue: h}, {provide: $r, useFactory: Fi, deps: [ki]}], Fi = h => new $r(h),
            Qr = (h, G) => ((h = h.filter(m => m.stackId !== G.stackId)).push(G), h), pi = (h, G) => {
                const m = h.createUrlTree(["."], {relativeTo: G});
                return h.serializeUrl(m)
            }, ei = (h, G) => {
                if (!h) return;
                const m = xi(G);
                for (let K = 0; K < m.length; K++) {
                    if (K >= h.length) return m[K];
                    if (m[K] !== h[K]) return
                }
            }, xi = h => h.split("/").map(G => G.trim()).filter(G => "" !== G), Ui = h => {
                h && (h.ref.destroy(), h.unlistenEvents())
            };

        class wi {
            constructor(G, m, K, Re, kt, Dn) {
                this.containerEl = m, this.router = K, this.navCtrl = Re, this.zone = kt, this.location = Dn, this.views = [], this.skipTransition = !1, this.nextId = 0, this.tabsPrefix = void 0 !== G ? xi(G) : void 0
            }

            createView(G, m) {
                var K;
                const Re = pi(this.router, m),
                    kt = null === (K = null == G ? void 0 : G.location) || void 0 === K ? void 0 : K.nativeElement,
                    Dn = $i(this.zone, G.instance, kt);
                return {
                    id: this.nextId++,
                    stackId: ei(this.tabsPrefix, Re),
                    unlistenEvents: Dn,
                    element: kt,
                    ref: G,
                    url: Re
                }
            }

            getExistingView(G) {
                const m = pi(this.router, G), K = this.views.find(Re => Re.url === m);
                return K && K.ref.changeDetectorRef.reattach(), K
            }

            setActive(G) {
                var m, K;
                const Re = this.navCtrl.consumeTransition();
                let {direction: kt, animation: Dn, animationBuilder: Lt} = Re;
                const In = this.activeView, mr = ((h, G) => !G || h.stackId !== G.stackId)(G, In);
                mr && (kt = "back", Dn = void 0);
                const dr = this.views.slice();
                let Mr;
                const Vr = this.router;
                Vr.getCurrentNavigation ? Mr = Vr.getCurrentNavigation() : (null === (m = Vr.navigations) || void 0 === m ? void 0 : m.value) && (Mr = Vr.navigations.value), (null === (K = null == Mr ? void 0 : Mr.extras) || void 0 === K ? void 0 : K.replaceUrl) && this.views.length > 0 && this.views.splice(-1, 1);
                const Kr = this.views.includes(G), Zr = this.insertView(G, kt);
                Kr || G.ref.changeDetectorRef.detectChanges();
                const Ai = G.animationBuilder;
                return void 0 === Lt && "back" === kt && !mr && void 0 !== Ai && (Lt = Ai), In && (In.animationBuilder = Lt), this.zone.runOutsideAngular(() => this.wait(() => (In && In.ref.changeDetectorRef.detach(), G.ref.changeDetectorRef.reattach(), this.transition(G, In, Dn, this.canGoBack(1), !1, Lt).then(() => ui(G, Zr, dr, this.location, this.zone)).then(() => ({
                    enteringView: G,
                    direction: kt,
                    animation: Dn,
                    tabSwitch: mr
                })))))
            }

            canGoBack(G, m = this.getActiveStackId()) {
                return this.getStack(m).length > G
            }

            pop(G, m = this.getActiveStackId()) {
                return this.zone.run(() => {
                    var K, Re;
                    const kt = this.getStack(m);
                    if (kt.length <= G) return Promise.resolve(!1);
                    const Dn = kt[kt.length - G - 1];
                    let Lt = Dn.url;
                    const In = Dn.savedData;
                    if (In) {
                        const dr = In.get("primary");
                        (null === (Re = null === (K = null == dr ? void 0 : dr.route) || void 0 === K ? void 0 : K._routerState) || void 0 === Re ? void 0 : Re.snapshot.url) && (Lt = dr.route._routerState.snapshot.url)
                    }
                    const {animationBuilder: mr} = this.navCtrl.consumeTransition();
                    return this.navCtrl.navigateBack(Lt, Object.assign(Object.assign({}, Dn.savedExtras), {animation: mr})).then(() => !0)
                })
            }

            startBackTransition() {
                const G = this.activeView;
                if (G) {
                    const m = this.getStack(G.stackId), K = m[m.length - 2], Re = K.animationBuilder;
                    return this.wait(() => this.transition(K, G, "back", this.canGoBack(2), !0, Re))
                }
                return Promise.resolve()
            }

            endBackTransition(G) {
                G ? (this.skipTransition = !0, this.pop(1)) : this.activeView && gi(this.activeView, this.views, this.views, this.location, this.zone)
            }

            getLastUrl(G) {
                const m = this.getStack(G);
                return m.length > 0 ? m[m.length - 1] : void 0
            }

            getRootUrl(G) {
                const m = this.getStack(G);
                return m.length > 0 ? m[0] : void 0
            }

            getActiveStackId() {
                return this.activeView ? this.activeView.stackId : void 0
            }

            hasRunningTask() {
                return void 0 !== this.runningTask
            }

            destroy() {
                this.containerEl = void 0, this.views.forEach(Ui), this.activeView = void 0, this.views = []
            }

            getStack(G) {
                return this.views.filter(m => m.stackId === G)
            }

            insertView(G, m) {
                return this.activeView = G, this.views = ((h, G, m) => "root" === m ? Qr(h, G) : "forward" === m ? ((h, G) => (h.indexOf(G) >= 0 ? h = h.filter(K => K.stackId !== G.stackId || K.id <= G.id) : h.push(G), h))(h, G) : ((h, G) => h.indexOf(G) >= 0 ? h.filter(K => K.stackId !== G.stackId || K.id <= G.id) : Qr(h, G))(h, G))(this.views, G, m), this.views.slice()
            }

            transition(G, m, K, Re, kt, Dn) {
                if (this.skipTransition) return this.skipTransition = !1, Promise.resolve(!1);
                if (m === G) return Promise.resolve(!1);
                const Lt = G ? G.element : void 0, In = m ? m.element : void 0, mr = this.containerEl;
                return Lt && Lt !== In && (Lt.classList.add("ion-page"), Lt.classList.add("ion-page-invisible"), Lt.parentElement !== mr && mr.appendChild(Lt), mr.commit) ? mr.commit(Lt, In, {
                    deepWait: !0,
                    duration: void 0 === K ? 0 : void 0,
                    direction: K,
                    showGoBack: Re,
                    progressAnimation: kt,
                    animationBuilder: Dn
                }) : Promise.resolve(!1)
            }

            wait(G) {
                return (0, ie.mG)(this, void 0, void 0, function* () {
                    void 0 !== this.runningTask && (yield this.runningTask, this.runningTask = void 0);
                    const m = this.runningTask = G();
                    return m.finally(() => this.runningTask = void 0), m
                })
            }
        }

        const ui = (h, G, m, K, Re) => "function" == typeof requestAnimationFrame ? new Promise(kt => {
            requestAnimationFrame(() => {
                gi(h, G, m, K, Re), kt()
            })
        }) : Promise.resolve(), gi = (h, G, m, K, Re) => {
            Re.run(() => m.filter(kt => !G.includes(kt)).forEach(Ui)), G.forEach(kt => {
                const Lt = K.path().split("?")[0].split("#")[0];
                if (kt !== h && kt.url !== Lt) {
                    const In = kt.element;
                    In.setAttribute("aria-hidden", "true"), In.classList.add("ion-page-hidden"), kt.ref.changeDetectorRef.detach()
                }
            })
        };
        let Si = (() => {
            class h {
                get(m, K) {
                    const Re = Xr();
                    return Re ? Re.get(m, K) : null
                }

                getBoolean(m, K) {
                    const Re = Xr();
                    return !!Re && Re.getBoolean(m, K)
                }

                getNumber(m, K) {
                    const Re = Xr();
                    return Re ? Re.getNumber(m, K) : 0
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })();
        const mi = new r.OlP("USERCONFIG"), Xr = () => {
            if ("undefined" != typeof window) {
                const h = window.Ionic;
                if (null == h ? void 0 : h.config) return h.config
            }
            return null
        };
        let ti = (() => {
            class h {
                constructor(m, K) {
                    this.doc = m, this.backButton = new j.xQ, this.keyboardDidShow = new j.xQ, this.keyboardDidHide = new j.xQ, this.pause = new j.xQ, this.resume = new j.xQ, this.resize = new j.xQ, K.run(() => {
                        var Re;
                        let kt;
                        this.win = m.defaultView, this.backButton.subscribeWithPriority = function (Dn, Lt) {
                            return this.subscribe(In => In.register(Dn, mr => K.run(() => Lt(mr))))
                        }, si(this.pause, m, "pause"), si(this.resume, m, "resume"), si(this.backButton, m, "ionBackButton"), si(this.resize, this.win, "resize"), si(this.keyboardDidShow, this.win, "ionKeyboardDidShow"), si(this.keyboardDidHide, this.win, "ionKeyboardDidHide"), this._readyPromise = new Promise(Dn => {
                            kt = Dn
                        }), (null === (Re = this.win) || void 0 === Re ? void 0 : Re.cordova) ? m.addEventListener("deviceready", () => {
                            kt("cordova")
                        }, {once: !0}) : kt("dom")
                    })
                }

                is(m) {
                    return (0, M.a)(this.win, m)
                }

                platforms() {
                    return (0, M.g)(this.win)
                }

                ready() {
                    return this._readyPromise
                }

                get isRTL() {
                    return "rtl" === this.doc.dir
                }

                getQueryParam(m) {
                    return Hr(this.win.location.href, m)
                }

                isLandscape() {
                    return !this.isPortrait()
                }

                isPortrait() {
                    var m, K;
                    return null === (K = (m = this.win).matchMedia) || void 0 === K ? void 0 : K.call(m, "(orientation: portrait)").matches
                }

                testUserAgent(m) {
                    const K = this.win.navigator;
                    return !!((null == K ? void 0 : K.userAgent) && K.userAgent.indexOf(m) >= 0)
                }

                url() {
                    return this.win.location.href
                }

                width() {
                    return this.win.innerWidth
                }

                height() {
                    return this.win.innerHeight
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.LFG(l.K0), r.LFG(r.R0b))
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })();
        const Hr = (h, G) => {
            G = G.replace(/[[\]\\]/g, "\\$&");
            const K = new RegExp("[\\?&]" + G + "=([^&#]*)").exec(h);
            return K ? decodeURIComponent(K[1].replace(/\+/g, " ")) : null
        }, si = (h, G, m) => {
            G && G.addEventListener(m, K => {
                h.next(null != K ? K.detail : void 0)
            })
        };
        let vi = (() => {
            class h {
                constructor(m, K, Re, kt) {
                    this.location = K, this.serializer = Re, this.router = kt, this.direction = ni, this.animated = oi, this.guessDirection = "forward", this.lastNavId = -1, kt && kt.events.subscribe(Dn => {
                        if (Dn instanceof Q.OD) {
                            const Lt = Dn.restoredState ? Dn.restoredState.navigationId : Dn.id;
                            this.guessDirection = Lt < this.lastNavId ? "back" : "forward", this.guessAnimation = Dn.restoredState ? void 0 : this.guessDirection, this.lastNavId = "forward" === this.guessDirection ? Dn.id : Lt
                        }
                    }), m.backButton.subscribeWithPriority(0, Dn => {
                        this.pop(), Dn()
                    })
                }

                navigateForward(m, K = {}) {
                    return this.setDirection("forward", K.animated, K.animationDirection, K.animation), this.navigate(m, K)
                }

                navigateBack(m, K = {}) {
                    return this.setDirection("back", K.animated, K.animationDirection, K.animation), this.navigate(m, K)
                }

                navigateRoot(m, K = {}) {
                    return this.setDirection("root", K.animated, K.animationDirection, K.animation), this.navigate(m, K)
                }

                back(m = {animated: !0, animationDirection: "back"}) {
                    return this.setDirection("back", m.animated, m.animationDirection, m.animation), this.location.back()
                }

                pop() {
                    return (0, ie.mG)(this, void 0, void 0, function* () {
                        let m = this.topOutlet;
                        for (; m && !(yield m.pop());) m = m.parentOutlet
                    })
                }

                setDirection(m, K, Re, kt) {
                    this.direction = m, this.animated = Di(m, K, Re), this.animationBuilder = kt
                }

                setTopOutlet(m) {
                    this.topOutlet = m
                }

                consumeTransition() {
                    let K, m = "root";
                    const Re = this.animationBuilder;
                    return "auto" === this.direction ? (m = this.guessDirection, K = this.guessAnimation) : (K = this.animated, m = this.direction), this.direction = ni, this.animated = oi, this.animationBuilder = void 0, {
                        direction: m,
                        animation: K,
                        animationBuilder: Re
                    }
                }

                navigate(m, K) {
                    if (Array.isArray(m)) return this.router.navigate(m, K);
                    {
                        const Re = this.serializer.parse(m.toString());
                        return void 0 !== K.queryParams && (Re.queryParams = Object.assign({}, K.queryParams)), void 0 !== K.fragment && (Re.fragment = K.fragment), this.router.navigateByUrl(Re, K)
                    }
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.LFG(ti), r.LFG(l.Ye), r.LFG(Q.Hx), r.LFG(Q.F0, 8))
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })();
        const Di = (h, G, m) => {
            if (!1 !== G) {
                if (void 0 !== m) return m;
                if ("forward" === h || "back" === h) return h;
                if ("root" === h && !0 === G) return "forward"
            }
        }, ni = "auto", oi = void 0;

        class Ei {
        }

        let ai = (() => {
            class h {
                constructor(m, K, Re, kt, Dn, Lt, In, mr, dr, Mr, Vr, Kr, Zr, Ai) {
                    this.parentContexts = m, this.location = K, this.config = Dn, this.navCtrl = Lt, this.environmentInjector = In, this.componentFactoryResolver = mr, this.parentOutlet = Ai, this.activated = null, this.activatedView = null, this._activatedRoute = null, this.proxyMap = new WeakMap, this.currentActivatedRoute$ = new W.X(null), this.stackEvents = new r.vpe, this.activateEvents = new r.vpe, this.deactivateEvents = new r.vpe, this.nativeEl = Mr.nativeElement, this.name = Re || Q.eC, this.tabsPrefix = "true" === kt ? pi(Vr, Zr) : void 0, this.stackCtrl = new wi(this.tabsPrefix, this.nativeEl, Vr, Lt, Kr, dr), m.onChildOutletCreated(this.name, this)
                }

                set animation(m) {
                    this.nativeEl.animation = m
                }

                set animated(m) {
                    this.nativeEl.animated = m
                }

                set swipeGesture(m) {
                    this._swipeGesture = m, this.nativeEl.swipeHandler = m ? {
                        canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(),
                        onStart: () => this.stackCtrl.startBackTransition(),
                        onEnd: K => this.stackCtrl.endBackTransition(K)
                    } : void 0
                }

                ngOnDestroy() {
                    this.stackCtrl.destroy()
                }

                getContext() {
                    return this.parentContexts.getContext(this.name)
                }

                ngOnInit() {
                    if (!this.activated) {
                        const m = this.getContext();
                        (null == m ? void 0 : m.route) && this.activateWith(m.route, m.resolver || null)
                    }
                    new Promise(m => (0, H.c)(this.nativeEl, m)).then(() => {
                        void 0 === this._swipeGesture && (this.swipeGesture = this.config.getBoolean("swipeBackEnabled", "ios" === this.nativeEl.mode))
                    })
                }

                get isActivated() {
                    return !!this.activated
                }

                get component() {
                    if (!this.activated) throw new Error("Outlet is not activated");
                    return this.activated.instance
                }

                get activatedRoute() {
                    if (!this.activated) throw new Error("Outlet is not activated");
                    return this._activatedRoute
                }

                get activatedRouteData() {
                    return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
                }

                detach() {
                    throw new Error("incompatible reuse strategy")
                }

                attach(m, K) {
                    throw new Error("incompatible reuse strategy")
                }

                deactivate() {
                    if (this.activated) {
                        if (this.activatedView) {
                            const K = this.getContext();
                            this.activatedView.savedData = new Map(K.children.contexts);
                            const Re = this.activatedView.savedData.get("primary");
                            if (Re && K.route && (Re.route = Object.assign({}, K.route)), this.activatedView.savedExtras = {}, K.route) {
                                const kt = K.route.snapshot;
                                this.activatedView.savedExtras.queryParams = kt.queryParams, this.activatedView.savedExtras.fragment = kt.fragment
                            }
                        }
                        const m = this.component;
                        this.activatedView = null, this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(m)
                    }
                }

                activateWith(m, K) {
                    if (this.isActivated) throw new Error("Cannot activate an already activated outlet");
                    this._activatedRoute = m;
                    let Re, kt = this.stackCtrl.getExistingView(m);
                    if (kt) {
                        Re = this.activated = kt.ref;
                        const Dn = kt.savedData;
                        Dn && (this.getContext().children.contexts = Dn), this.updateActivatedRouteProxy(Re.instance, m)
                    } else {
                        const Dn = m._futureSnapshot, Lt = Dn.routeConfig.component;
                        if (null == Lt && Dn.component) return void console.warn("[Ionic Warning]: Standalone components are not currently supported with ion-router-outlet. You can track this feature request at https://github.com/ionic-team/ionic-framework/issues/25404");
                        const In = this.parentContexts.getOrCreateContext(this.name).children, mr = new W.X(null),
                            dr = this.createActivatedRouteProxy(mr, m), Mr = new ri(dr, In, this.location.injector);
                        if ((K = K || this.componentFactoryResolver) && q(K)) {
                            const Vr = K.resolveComponentFactory(Lt);
                            Re = this.activated = this.location.createComponent(Vr, this.location.length, Mr)
                        } else Re = this.activated = this.location.createComponent(Lt, {
                            index: this.location.length,
                            injector: Mr,
                            environmentInjector: null != K ? K : this.environmentInjector
                        });
                        mr.next(Re.instance), kt = this.stackCtrl.createView(this.activated, m), this.proxyMap.set(Re.instance, dr), this.currentActivatedRoute$.next({
                            component: Re.instance,
                            activatedRoute: m
                        })
                    }
                    this.activatedView = kt, this.stackCtrl.setActive(kt).then(Dn => {
                        this.navCtrl.setTopOutlet(this), this.activateEvents.emit(Re.instance), this.stackEvents.emit(Dn)
                    })
                }

                canGoBack(m = 1, K) {
                    return this.stackCtrl.canGoBack(m, K)
                }

                pop(m = 1, K) {
                    return this.stackCtrl.pop(m, K)
                }

                getLastUrl(m) {
                    const K = this.stackCtrl.getLastUrl(m);
                    return K ? K.url : void 0
                }

                getLastRouteView(m) {
                    return this.stackCtrl.getLastUrl(m)
                }

                getRootView(m) {
                    return this.stackCtrl.getRootUrl(m)
                }

                getActiveStackId() {
                    return this.stackCtrl.getActiveStackId()
                }

                createActivatedRouteProxy(m, K) {
                    const Re = new Q.gz;
                    return Re._futureSnapshot = K._futureSnapshot, Re._routerState = K._routerState, Re.snapshot = K.snapshot, Re.outlet = K.outlet, Re.component = K.component, Re._paramMap = this.proxyObservable(m, "paramMap"), Re._queryParamMap = this.proxyObservable(m, "queryParamMap"), Re.url = this.proxyObservable(m, "url"), Re.params = this.proxyObservable(m, "params"), Re.queryParams = this.proxyObservable(m, "queryParams"), Re.fragment = this.proxyObservable(m, "fragment"), Re.data = this.proxyObservable(m, "data"), Re
                }

                proxyObservable(m, K) {
                    return m.pipe((0, ce.h)(Re => !!Re), (0, I.w)(Re => this.currentActivatedRoute$.pipe((0, ce.h)(kt => null !== kt && kt.component === Re), (0, I.w)(kt => kt && kt.activatedRoute[K]), function rt(h, G) {
                        return m => m.lift(new Xe(h, G))
                    }())))
                }

                updateActivatedRouteProxy(m, K) {
                    const Re = this.proxyMap.get(m);
                    if (!Re) throw new Error("Could not find activated route proxy for view");
                    Re._futureSnapshot = K._futureSnapshot, Re._routerState = K._routerState, Re.snapshot = K.snapshot, Re.outlet = K.outlet, Re.component = K.component, this.currentActivatedRoute$.next({
                        component: m,
                        activatedRoute: K
                    })
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(Q.y6), r.Y36(r.s_b), r.$8M("name"), r.$8M("tabs"), r.Y36(Si), r.Y36(vi), r.Y36(Ei, 8), r.Y36(r._Vd, 8), r.Y36(l.Ye), r.Y36(r.SBq), r.Y36(Q.F0), r.Y36(r.R0b), r.Y36(Q.gz), r.Y36(h, 12))
            }, h.\u0275dir = r.lG2({
                type: h,
                selectors: [["ion-router-outlet"]],
                inputs: {animated: "animated", animation: "animation", swipeGesture: "swipeGesture"},
                outputs: {stackEvents: "stackEvents", activateEvents: "activate", deactivateEvents: "deactivate"},
                exportAs: ["outlet"]
            }), h
        })();

        class ri {
            constructor(G, m, K) {
                this.route = G, this.childContexts = m, this.parent = K
            }

            get(G, m) {
                return G === Q.gz ? this.route : G === Q.y6 ? this.childContexts : this.parent.get(G, m)
            }
        }

        let mt = (() => {
            let h = class {
                constructor(m, K, Re) {
                    this.z = Re, this.isCmpOpen = !1, this.el = K.nativeElement, this.el.addEventListener("willPresent", () => {
                        this.isCmpOpen = !0, m.detectChanges()
                    }), this.el.addEventListener("didDismiss", () => {
                        this.isCmpOpen = !1, m.detectChanges()
                    }), Nn(this, this.el, ["ionModalDidPresent", "ionModalWillPresent", "ionModalWillDismiss", "ionModalDidDismiss", "ionBreakpointDidChange", "didPresent", "willPresent", "willDismiss", "didDismiss"])
                }
            };
            return h.\u0275fac = function (m) {
                return new (m || h)(r.Y36(r.sBO), r.Y36(r.SBq), r.Y36(r.R0b))
            }, h.\u0275cmp = r.Xpm({
                type: h,
                selectors: [["ion-modal"]],
                contentQueries: function (m, K, Re) {
                    if (1 & m && r.Suo(Re, r.Rgc, 5), 2 & m) {
                        let kt;
                        r.iGM(kt = r.CRH()) && (K.template = kt.first)
                    }
                },
                inputs: {
                    animated: "animated",
                    keepContentsMounted: "keepContentsMounted",
                    backdropBreakpoint: "backdropBreakpoint",
                    backdropDismiss: "backdropDismiss",
                    breakpoints: "breakpoints",
                    canDismiss: "canDismiss",
                    cssClass: "cssClass",
                    enterAnimation: "enterAnimation",
                    event: "event",
                    handle: "handle",
                    handleBehavior: "handleBehavior",
                    initialBreakpoint: "initialBreakpoint",
                    isOpen: "isOpen",
                    keyboardClose: "keyboardClose",
                    leaveAnimation: "leaveAnimation",
                    mode: "mode",
                    presentingElement: "presentingElement",
                    showBackdrop: "showBackdrop",
                    swipeToClose: "swipeToClose",
                    translucent: "translucent",
                    trigger: "trigger"
                },
                decls: 1,
                vars: 1,
                consts: [["class", "ion-page", 4, "ngIf"], [1, "ion-page"], [3, "ngTemplateOutlet"]],
                template: function (m, K) {
                    1 & m && r.YNc(0, Z, 2, 1, "div", 0), 2 & m && r.Q6J("ngIf", K.isCmpOpen || K.keepContentsMounted)
                },
                directives: [l.O5, l.tP],
                encapsulation: 2,
                changeDetection: 0
            }), h = (0, ie.gn)([Me({
                inputs: ["animated", "keepContentsMounted", "backdropBreakpoint", "backdropDismiss", "breakpoints", "canDismiss", "cssClass", "enterAnimation", "event", "handle", "handleBehavior", "initialBreakpoint", "isOpen", "keyboardClose", "leaveAnimation", "mode", "presentingElement", "showBackdrop", "swipeToClose", "translucent", "trigger"],
                methods: ["present", "dismiss", "onDidDismiss", "onWillDismiss", "setCurrentBreakpoint", "getCurrentBreakpoint"]
            })], h), h
        })();

        class ln {
            constructor(G) {
                this.ctrl = G
            }

            create(G) {
                return this.ctrl.create(G || {})
            }

            dismiss(G, m, K) {
                return this.ctrl.dismiss(G, m, K)
            }

            getTop() {
                return this.ctrl.getTop()
            }
        }

        let vr = (() => {
            class h extends ln {
                constructor() {
                    super(ge.a)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })(), Tr = (() => {
            class h extends ln {
                constructor(m, K, Re, kt) {
                    super(ge.m), this.angularDelegate = m, this.resolver = K, this.injector = Re, this.environmentInjector = kt
                }

                create(m) {
                    var K;
                    return super.create(Object.assign(Object.assign({}, m), {delegate: this.angularDelegate.create(null !== (K = this.resolver) && void 0 !== K ? K : this.environmentInjector, this.injector)}))
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.LFG(Nr), r.LFG(r._Vd), r.LFG(r.zs3), r.LFG(Ei, 8))
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac}), h
        })(), yr = (() => {
            class h extends ln {
                constructor(m, K, Re, kt) {
                    super(ge.c), this.angularDelegate = m, this.resolver = K, this.injector = Re, this.environmentInjector = kt
                }

                create(m) {
                    var K;
                    return super.create(Object.assign(Object.assign({}, m), {delegate: this.angularDelegate.create(null !== (K = this.resolver) && void 0 !== K ? K : this.environmentInjector, this.injector)}))
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)(r.LFG(Nr), r.LFG(r._Vd), r.LFG(r.zs3), r.LFG(Ei, 8))
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac}), h
        })(), Ar = (() => {
            class h extends ln {
                constructor() {
                    super(ge.t)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })(), Or = (() => {
            class h {
                read(m) {
                    Pr().read(m)
                }

                write(m) {
                    Pr().write(m)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })();
        const Pr = () => {
            const h = "undefined" != typeof window ? window : null;
            if (null != h) {
                const G = h.Ionic;
                return (null == G ? void 0 : G.queue) ? G.queue : {
                    read: m => h.requestAnimationFrame(m),
                    write: m => h.requestAnimationFrame(m)
                }
            }
            return {read: G => G(), write: G => G()}
        };
        let Gr = (() => {
            class h {
                create(m) {
                    return (0, Ne.c)(m)
                }

                easingTime(m, K, Re, kt, Dn) {
                    return (0, ae.g)(m, K, Re, kt, Dn)
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275prov = r.Yz7({token: h, factory: h.\u0275fac, providedIn: "root"}), h
        })();

        class re {
            shouldDetach(G) {
                return !1
            }

            shouldAttach(G) {
                return !1
            }

            store(G, m) {
            }

            retrieve(G) {
                return null
            }

            shouldReuseRoute(G, m) {
                if (G.routeConfig !== m.routeConfig) return !1;
                const K = G.params, Re = m.params, kt = Object.keys(K), Dn = Object.keys(Re);
                if (kt.length !== Dn.length) return !1;
                for (const Lt of kt) if (Re[Lt] !== K[Lt]) return !1;
                return !0
            }
        }

        const z = (h, G, m) => () => {
            if (G.defaultView && "undefined" != typeof window) {
                (h => {
                    const G = window, m = G.Ionic;
                    m && m.config && "Object" !== m.config.constructor.name || (G.Ionic = G.Ionic || {}, G.Ionic.config = Object.assign(Object.assign({}, G.Ionic.config), h))
                })(Object.assign(Object.assign({}, h), {_zoneGate: kt => m.run(kt)}));
                const Re = "__zone_symbol__addEventListener" in G.body ? "__zone_symbol__addEventListener" : "addEventListener";
                return function f() {
                    var h = [];
                    if ("undefined" != typeof window) {
                        var G = window;
                        (!G.customElements || G.Element && (!G.Element.prototype.closest || !G.Element.prototype.matches || !G.Element.prototype.remove || !G.Element.prototype.getRootNode)) && h.push(R.e(6748).then(R.t.bind(R, 723, 23))), ("function" != typeof Object.assign || !Object.entries || !Array.prototype.find || !Array.prototype.includes || !String.prototype.startsWith || !String.prototype.endsWith || G.NodeList && !G.NodeList.prototype.forEach || !G.fetch || !function () {
                            try {
                                var K = new URL("b", "http://a");
                                return K.pathname = "c%20d", "http://a/c%20d" === K.href && K.searchParams
                            } catch (Re) {
                                return !1
                            }
                        }() || "undefined" == typeof WeakMap) && h.push(R.e(2214).then(R.t.bind(R, 4144, 23)))
                    }
                    return Promise.all(h)
                }().then(() => ((h, G) => "undefined" == typeof window ? Promise.resolve() : (0, he.p)().then(() => (g(), (0, he.b)(JSON.parse('[["ion-menu_3",[[33,"ion-menu-button",{"color":[513],"disabled":[4],"menu":[1],"autoHide":[4,"auto-hide"],"type":[1],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]],[33,"ion-menu",{"contentId":[513,"content-id"],"menuId":[513,"menu-id"],"type":[1025],"disabled":[1028],"side":[513],"swipeGesture":[4,"swipe-gesture"],"maxEdgeStart":[2,"max-edge-start"],"isPaneVisible":[32],"isEndSide":[32],"isOpen":[64],"isActive":[64],"open":[64],"close":[64],"toggle":[64],"setOpen":[64]},[[16,"ionSplitPaneVisible","onSplitPaneChanged"],[2,"click","onBackdropClick"],[0,"keydown","onKeydown"]]],[1,"ion-menu-toggle",{"menu":[1],"autoHide":[4,"auto-hide"],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]]]],["ion-fab_3",[[33,"ion-fab-button",{"color":[513],"activated":[4],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1],"show":[4],"translucent":[4],"type":[1],"size":[1],"closeIcon":[1,"close-icon"]}],[1,"ion-fab",{"horizontal":[1],"vertical":[1],"edge":[4],"activated":[1028],"close":[64],"toggle":[64]}],[1,"ion-fab-list",{"activated":[4],"side":[1]}]]],["ion-refresher_2",[[0,"ion-refresher-content",{"pullingIcon":[1025,"pulling-icon"],"pullingText":[1,"pulling-text"],"refreshingSpinner":[1025,"refreshing-spinner"],"refreshingText":[1,"refreshing-text"]}],[32,"ion-refresher",{"pullMin":[2,"pull-min"],"pullMax":[2,"pull-max"],"closeDuration":[1,"close-duration"],"snapbackDuration":[1,"snapback-duration"],"pullFactor":[2,"pull-factor"],"disabled":[4],"nativeRefresher":[32],"state":[32],"complete":[64],"cancel":[64],"getProgress":[64]}]]],["ion-back-button",[[33,"ion-back-button",{"color":[513],"defaultHref":[1025,"default-href"],"disabled":[516],"icon":[1],"text":[1],"type":[1],"routerAnimation":[16]}]]],["ion-toast",[[33,"ion-toast",{"overlayIndex":[2,"overlay-index"],"color":[513],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"duration":[2],"header":[1],"message":[1],"keyboardClose":[4,"keyboard-close"],"position":[1],"buttons":[16],"translucent":[4],"animated":[4],"icon":[1],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-card_5",[[33,"ion-card",{"color":[513],"button":[4],"type":[1],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}],[32,"ion-card-content"],[33,"ion-card-header",{"color":[513],"translucent":[4]}],[33,"ion-card-subtitle",{"color":[513]}],[33,"ion-card-title",{"color":[513]}]]],["ion-item-option_3",[[33,"ion-item-option",{"color":[513],"disabled":[4],"download":[1],"expandable":[4],"href":[1],"rel":[1],"target":[1],"type":[1]}],[32,"ion-item-options",{"side":[1],"fireSwipeEvent":[64]}],[0,"ion-item-sliding",{"disabled":[4],"state":[32],"getOpenAmount":[64],"getSlidingRatio":[64],"open":[64],"close":[64],"closeOpened":[64]}]]],["ion-accordion_2",[[49,"ion-accordion",{"value":[1],"disabled":[4],"readonly":[4],"toggleIcon":[1,"toggle-icon"],"toggleIconSlot":[1,"toggle-icon-slot"],"state":[32],"isNext":[32],"isPrevious":[32]}],[33,"ion-accordion-group",{"animated":[4],"multiple":[4],"value":[1025],"disabled":[4],"readonly":[4],"expand":[1],"requestAccordionToggle":[64],"getAccordions":[64]},[[0,"keydown","onKeydown"]]]]],["ion-breadcrumb_2",[[33,"ion-breadcrumb",{"collapsed":[4],"last":[4],"showCollapsedIndicator":[4,"show-collapsed-indicator"],"color":[1],"active":[4],"disabled":[4],"download":[1],"href":[1],"rel":[1],"separator":[4],"target":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16]}],[33,"ion-breadcrumbs",{"color":[1],"maxItems":[2,"max-items"],"itemsBeforeCollapse":[2,"items-before-collapse"],"itemsAfterCollapse":[2,"items-after-collapse"],"collapsed":[32],"activeChanged":[32]},[[0,"collapsedClick","onCollapsedClick"]]]]],["ion-infinite-scroll_2",[[32,"ion-infinite-scroll-content",{"loadingSpinner":[1025,"loading-spinner"],"loadingText":[1,"loading-text"]}],[0,"ion-infinite-scroll",{"threshold":[1],"disabled":[4],"position":[1],"isLoading":[32],"complete":[64]}]]],["ion-reorder_2",[[33,"ion-reorder",null,[[2,"click","onClick"]]],[0,"ion-reorder-group",{"disabled":[4],"state":[32],"complete":[64]}]]],["ion-segment_2",[[33,"ion-segment-button",{"disabled":[4],"layout":[1],"type":[1],"value":[1],"checked":[32]}],[33,"ion-segment",{"color":[513],"disabled":[4],"scrollable":[4],"swipeGesture":[4,"swipe-gesture"],"value":[1025],"selectOnFocus":[4,"select-on-focus"],"activated":[32]},[[0,"keydown","onKeyDown"]]]]],["ion-tab-bar_2",[[33,"ion-tab-button",{"disabled":[4],"download":[1],"href":[1],"rel":[1],"layout":[1025],"selected":[1028],"tab":[1],"target":[1]},[[8,"ionTabBarChanged","onTabBarChanged"]]],[33,"ion-tab-bar",{"color":[513],"selectedTab":[1,"selected-tab"],"translucent":[4],"keyboardVisible":[32]}]]],["ion-chip",[[33,"ion-chip",{"color":[513],"outline":[4],"disabled":[4]}]]],["ion-datetime-button",[[33,"ion-datetime-button",{"color":[513],"disabled":[516],"datetime":[1],"datetimePresentation":[32],"dateText":[32],"timeText":[32],"datetimeActive":[32],"selectedButton":[32]}]]],["ion-searchbar",[[34,"ion-searchbar",{"color":[513],"animated":[4],"autocomplete":[1],"autocorrect":[1],"cancelButtonIcon":[1,"cancel-button-icon"],"cancelButtonText":[1,"cancel-button-text"],"clearIcon":[1,"clear-icon"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"placeholder":[1],"searchIcon":[1,"search-icon"],"showCancelButton":[1,"show-cancel-button"],"showClearButton":[1,"show-clear-button"],"spellcheck":[4],"type":[1],"value":[1025],"focused":[32],"noAnimate":[32],"setFocus":[64],"getInputElement":[64]}]]],["ion-toggle",[[33,"ion-toggle",{"color":[513],"name":[1],"checked":[1028],"disabled":[4],"value":[1],"enableOnOffLabels":[4,"enable-on-off-labels"],"activated":[32]}]]],["ion-nav_2",[[1,"ion-nav",{"delegate":[16],"swipeGesture":[1028,"swipe-gesture"],"animated":[4],"animation":[16],"rootParams":[16],"root":[1],"push":[64],"insert":[64],"insertPages":[64],"pop":[64],"popTo":[64],"popToRoot":[64],"removeIndex":[64],"setRoot":[64],"setPages":[64],"setRouteId":[64],"getRouteId":[64],"getActive":[64],"getByIndex":[64],"canGoBack":[64],"getPrevious":[64]}],[0,"ion-nav-link",{"component":[1],"componentProps":[16],"routerDirection":[1,"router-direction"],"routerAnimation":[16]}]]],["ion-input",[[34,"ion-input",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"accept":[1],"autocapitalize":[1],"autocomplete":[1],"autocorrect":[1],"autofocus":[4],"clearInput":[4,"clear-input"],"clearOnEdit":[4,"clear-on-edit"],"debounce":[2],"disabled":[4],"enterkeyhint":[1],"inputmode":[1],"max":[8],"maxlength":[2],"min":[8],"minlength":[2],"multiple":[4],"name":[1],"pattern":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"step":[1],"size":[2],"type":[1],"value":[1032],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-textarea",[[34,"ion-textarea",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"autocapitalize":[1],"autofocus":[4],"clearOnEdit":[1028,"clear-on-edit"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"maxlength":[2],"minlength":[2],"name":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"cols":[2],"rows":[2],"wrap":[1],"autoGrow":[516,"auto-grow"],"value":[1025],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-backdrop",[[33,"ion-backdrop",{"visible":[4],"tappable":[4],"stopPropagation":[4,"stop-propagation"]},[[2,"click","onMouseDown"]]]]],["ion-loading",[[34,"ion-loading",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"message":[1],"cssClass":[1,"css-class"],"duration":[2],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"spinner":[1025],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-modal",[[33,"ion-modal",{"hasController":[4,"has-controller"],"overlayIndex":[2,"overlay-index"],"delegate":[16],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"breakpoints":[16],"initialBreakpoint":[2,"initial-breakpoint"],"backdropBreakpoint":[2,"backdrop-breakpoint"],"handle":[4],"handleBehavior":[1,"handle-behavior"],"component":[1],"componentProps":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"animated":[4],"swipeToClose":[4,"swipe-to-close"],"presentingElement":[16],"htmlAttributes":[16],"isOpen":[4,"is-open"],"trigger":[1],"keepContentsMounted":[4,"keep-contents-mounted"],"canDismiss":[4,"can-dismiss"],"presented":[32],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64],"setCurrentBreakpoint":[64],"getCurrentBreakpoint":[64]}]]],["ion-route_4",[[0,"ion-route",{"url":[1],"component":[1],"componentProps":[16],"beforeLeave":[16],"beforeEnter":[16]}],[0,"ion-route-redirect",{"from":[1],"to":[1]}],[0,"ion-router",{"root":[1],"useHash":[4,"use-hash"],"canTransition":[64],"push":[64],"back":[64],"printDebug":[64],"navChanged":[64]},[[8,"popstate","onPopState"],[4,"ionBackButton","onBackButton"]]],[1,"ion-router-link",{"color":[513],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}]]],["ion-avatar_3",[[33,"ion-avatar"],[33,"ion-badge",{"color":[513]}],[1,"ion-thumbnail"]]],["ion-col_3",[[1,"ion-col",{"offset":[1],"offsetXs":[1,"offset-xs"],"offsetSm":[1,"offset-sm"],"offsetMd":[1,"offset-md"],"offsetLg":[1,"offset-lg"],"offsetXl":[1,"offset-xl"],"pull":[1],"pullXs":[1,"pull-xs"],"pullSm":[1,"pull-sm"],"pullMd":[1,"pull-md"],"pullLg":[1,"pull-lg"],"pullXl":[1,"pull-xl"],"push":[1],"pushXs":[1,"push-xs"],"pushSm":[1,"push-sm"],"pushMd":[1,"push-md"],"pushLg":[1,"push-lg"],"pushXl":[1,"push-xl"],"size":[1],"sizeXs":[1,"size-xs"],"sizeSm":[1,"size-sm"],"sizeMd":[1,"size-md"],"sizeLg":[1,"size-lg"],"sizeXl":[1,"size-xl"]},[[9,"resize","onResize"]]],[1,"ion-grid",{"fixed":[4]}],[1,"ion-row"]]],["ion-slide_2",[[0,"ion-slide"],[36,"ion-slides",{"options":[8],"pager":[4],"scrollbar":[4],"update":[64],"updateAutoHeight":[64],"slideTo":[64],"slideNext":[64],"slidePrev":[64],"getActiveIndex":[64],"getPreviousIndex":[64],"length":[64],"isEnd":[64],"isBeginning":[64],"startAutoplay":[64],"stopAutoplay":[64],"lockSwipeToNext":[64],"lockSwipeToPrev":[64],"lockSwipes":[64],"getSwiper":[64]}]]],["ion-tab_2",[[1,"ion-tab",{"active":[1028],"delegate":[16],"tab":[1],"component":[1],"setActive":[64]}],[1,"ion-tabs",{"useRouter":[1028,"use-router"],"selectedTab":[32],"select":[64],"getTab":[64],"getSelected":[64],"setRouteId":[64],"getRouteId":[64]}]]],["ion-img",[[1,"ion-img",{"alt":[1],"src":[1],"loadSrc":[32],"loadError":[32]}]]],["ion-progress-bar",[[33,"ion-progress-bar",{"type":[1],"reversed":[4],"value":[2],"buffer":[2],"color":[513]}]]],["ion-range",[[33,"ion-range",{"color":[513],"debounce":[2],"name":[1],"dualKnobs":[4,"dual-knobs"],"min":[2],"max":[2],"pin":[4],"pinFormatter":[16],"snaps":[4],"step":[2],"ticks":[4],"activeBarStart":[1026,"active-bar-start"],"disabled":[4],"value":[1026],"ratioA":[32],"ratioB":[32],"pressedKnob":[32]}]]],["ion-split-pane",[[33,"ion-split-pane",{"contentId":[513,"content-id"],"disabled":[4],"when":[8],"visible":[32]}]]],["ion-text",[[1,"ion-text",{"color":[513]}]]],["ion-virtual-scroll",[[0,"ion-virtual-scroll",{"approxItemHeight":[2,"approx-item-height"],"approxHeaderHeight":[2,"approx-header-height"],"approxFooterHeight":[2,"approx-footer-height"],"headerFn":[16],"footerFn":[16],"items":[16],"itemHeight":[16],"headerHeight":[16],"footerHeight":[16],"renderItem":[16],"renderHeader":[16],"renderFooter":[16],"nodeRender":[16],"domRender":[16],"totalHeight":[32],"positionForItem":[64],"checkRange":[64],"checkEnd":[64]},[[9,"resize","onResize"]]]]],["ion-picker-column-internal",[[33,"ion-picker-column-internal",{"items":[16],"value":[1032],"color":[513],"numericInput":[4,"numeric-input"],"isActive":[32],"scrollActiveItemIntoView":[64],"setValue":[64]}]]],["ion-picker-internal",[[33,"ion-picker-internal"]]],["ion-radio_2",[[33,"ion-radio",{"color":[513],"name":[1],"disabled":[4],"value":[8],"checked":[32],"buttonTabindex":[32],"setFocus":[64],"setButtonTabindex":[64]}],[0,"ion-radio-group",{"allowEmptySelection":[4,"allow-empty-selection"],"name":[1],"value":[1032]},[[4,"keydown","onKeydown"]]]]],["ion-ripple-effect",[[1,"ion-ripple-effect",{"type":[1],"addRipple":[64]}]]],["ion-button_2",[[33,"ion-button",{"color":[513],"buttonType":[1025,"button-type"],"disabled":[516],"expand":[513],"fill":[1537],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"download":[1],"href":[1],"rel":[1],"shape":[513],"size":[513],"strong":[4],"target":[1],"type":[1]}],[1,"ion-icon",{"mode":[1025],"color":[1],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[513],"src":[1],"icon":[8],"size":[1],"lazy":[4],"sanitize":[4],"svgContent":[32],"isVisible":[32],"ariaLabel":[32]}]]],["ion-datetime_3",[[33,"ion-datetime",{"color":[1],"name":[1],"disabled":[4],"readonly":[4],"isDateEnabled":[16],"min":[1025],"max":[1025],"presentation":[1],"cancelText":[1,"cancel-text"],"doneText":[1,"done-text"],"clearText":[1,"clear-text"],"yearValues":[8,"year-values"],"monthValues":[8,"month-values"],"dayValues":[8,"day-values"],"hourValues":[8,"hour-values"],"minuteValues":[8,"minute-values"],"locale":[1],"firstDayOfWeek":[2,"first-day-of-week"],"multiple":[4],"value":[1025],"showDefaultTitle":[4,"show-default-title"],"showDefaultButtons":[4,"show-default-buttons"],"showClearButton":[4,"show-clear-button"],"showDefaultTimeLabel":[4,"show-default-time-label"],"hourCycle":[1,"hour-cycle"],"size":[1],"preferWheel":[4,"prefer-wheel"],"showMonthAndYear":[32],"activeParts":[32],"workingParts":[32],"isPresented":[32],"isTimePopoverOpen":[32],"confirm":[64],"reset":[64],"cancel":[64]}],[34,"ion-picker",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"columns":[16],"cssClass":[1,"css-class"],"duration":[2],"showBackdrop":[4,"show-backdrop"],"backdropDismiss":[4,"backdrop-dismiss"],"animated":[4],"htmlAttributes":[16],"presented":[32],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64],"getColumn":[64]}],[32,"ion-picker-column",{"col":[16]}]]],["ion-action-sheet",[[34,"ion-action-sheet",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"header":[1],"subHeader":[1,"sub-header"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-alert",[[34,"ion-alert",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"header":[1],"subHeader":[1,"sub-header"],"message":[1],"buttons":[16],"inputs":[1040],"backdropDismiss":[4,"backdrop-dismiss"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]},[[4,"keydown","onKeydown"]]]]],["ion-popover",[[33,"ion-popover",{"hasController":[4,"has-controller"],"delegate":[16],"overlayIndex":[2,"overlay-index"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"keyboardClose":[4,"keyboard-close"],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"event":[8],"showBackdrop":[4,"show-backdrop"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"triggerAction":[1,"trigger-action"],"trigger":[1],"size":[1],"dismissOnSelect":[4,"dismiss-on-select"],"reference":[1],"side":[1],"alignment":[1025],"arrow":[4],"isOpen":[4,"is-open"],"keyboardEvents":[4,"keyboard-events"],"keepContentsMounted":[4,"keep-contents-mounted"],"presented":[32],"presentFromTrigger":[64],"present":[64],"dismiss":[64],"getParentPopover":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-checkbox",[[33,"ion-checkbox",{"color":[513],"name":[1],"checked":[1028],"indeterminate":[1028],"disabled":[4],"value":[8]}]]],["ion-select_3",[[33,"ion-select",{"disabled":[4],"cancelText":[1,"cancel-text"],"okText":[1,"ok-text"],"placeholder":[1],"name":[1],"selectedText":[1,"selected-text"],"multiple":[4],"interface":[1],"interfaceOptions":[8,"interface-options"],"compareWith":[1,"compare-with"],"value":[1032],"isExpanded":[32],"open":[64]}],[1,"ion-select-option",{"disabled":[4],"value":[8]}],[34,"ion-select-popover",{"header":[1],"subHeader":[1,"sub-header"],"message":[1],"multiple":[4],"options":[16]},[[0,"ionChange","onSelect"]]]]],["ion-app_8",[[0,"ion-app",{"setFocus":[64]}],[1,"ion-content",{"color":[513],"fullscreen":[4],"forceOverscroll":[1028,"force-overscroll"],"scrollX":[4,"scroll-x"],"scrollY":[4,"scroll-y"],"scrollEvents":[4,"scroll-events"],"getScrollElement":[64],"scrollToTop":[64],"scrollToBottom":[64],"scrollByPoint":[64],"scrollToPoint":[64]},[[8,"appload","onAppLoad"]]],[36,"ion-footer",{"collapse":[1],"translucent":[4]}],[36,"ion-header",{"collapse":[1],"translucent":[4]}],[1,"ion-router-outlet",{"mode":[1025],"delegate":[16],"animated":[4],"animation":[16],"swipeHandler":[16],"commit":[64],"setRouteId":[64],"getRouteId":[64]}],[33,"ion-title",{"color":[513],"size":[1]}],[33,"ion-toolbar",{"color":[513]},[[0,"ionStyle","childrenStyle"]]],[34,"ion-buttons",{"collapse":[4]}]]],["ion-spinner",[[1,"ion-spinner",{"color":[513],"duration":[2],"name":[1],"paused":[4]}]]],["ion-item_8",[[33,"ion-item-divider",{"color":[513],"sticky":[4]}],[32,"ion-item-group"],[1,"ion-skeleton-text",{"animated":[4]}],[32,"ion-list",{"lines":[1],"inset":[4],"closeSlidingItems":[64]}],[33,"ion-list-header",{"color":[513],"lines":[1]}],[49,"ion-item",{"color":[513],"button":[4],"detail":[4],"detailIcon":[1,"detail-icon"],"disabled":[4],"download":[1],"fill":[1],"shape":[1],"href":[1],"rel":[1],"lines":[1],"counter":[4],"routerAnimation":[16],"routerDirection":[1,"router-direction"],"target":[1],"type":[1],"counterFormatter":[16],"multipleInputs":[32],"focusable":[32],"counterString":[32]},[[0,"ionChange","handleIonChange"],[0,"ionColor","labelColorChanged"],[0,"ionStyle","itemStyle"]]],[34,"ion-label",{"color":[513],"position":[1],"noAnimate":[32]}],[33,"ion-note",{"color":[513]}]]]]'), G))))(0, {
                    exclude: ["ion-tabs", "ion-tab"],
                    syncQueue: !0,
                    raf: Je,
                    jmp: kt => m.runOutsideAngular(kt),
                    ael(kt, Dn, Lt, In) {
                        kt[Re](Dn, Lt, In)
                    },
                    rel(kt, Dn, Lt, In) {
                        kt.removeEventListener(Dn, Lt, In)
                    }
                }))
            }
        };
        let _e = (() => {
            class h {
                static forRoot(m) {
                    return {
                        ngModule: h,
                        providers: [{provide: mi, useValue: m}, {
                            provide: r.ip1,
                            useFactory: z,
                            multi: !0,
                            deps: [mi, l.K0, r.R0b]
                        }]
                    }
                }
            }

            return h.\u0275fac = function (m) {
                return new (m || h)
            }, h.\u0275mod = r.oAB({type: h}), h.\u0275inj = r.cJS({providers: [Nr, Tr, yr], imports: [[l.ez]]}), h
        })()
    }, 9442: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {c: () => F});
        var r = R(3756);
        let D;
        const te = oe => oe.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), j = oe => {
            if (void 0 === D) {
                const Ie = void 0 !== oe.style.webkitAnimationName;
                D = void 0 === oe.style.animationName && Ie ? "-webkit-" : ""
            }
            return D
        }, W = (oe, ge, Ie) => {
            const he = ge.startsWith("animation") ? j(oe) : "";
            oe.style.setProperty(he + ge, Ie)
        }, Q = (oe, ge) => {
            const Ie = ge.startsWith("animation") ? j(oe) : "";
            oe.style.removeProperty(Ie + ge)
        }, me = [], H = (oe = [], ge) => {
            if (void 0 !== ge) {
                const Ie = Array.isArray(ge) ? ge : [ge];
                return [...oe, ...Ie]
            }
            return oe
        }, F = oe => {
            let ge, Ie, he, xe, Ue, it, Xe, w, P, B, O, Je, q, yt = [], Ce = [], $e = [], rt = !1, Ee = {}, ce = [],
                I = [], l = {}, f = 0, g = !1, v = !1, E = !0, Z = !1, ze = !0, Le = !1;
            const ut = oe, Ye = [], Mt = [], _t = [], Pt = [], Gt = [], yn = [], Xt = [], xn = [], Fn = [], wn = [],
                Nn = "function" == typeof AnimationEffect || "function" == typeof window.AnimationEffect,
                On = "function" == typeof Element && "function" == typeof Element.prototype.animate && Nn,
                ne = () => wn,
                ye = (Ke, at) => (((null == at ? void 0 : at.oneTimeCallback) ? Mt : Ye).push({c: Ke, o: at}), q),
                Be = () => {
                    if (On) wn.forEach(Ke => {
                        Ke.cancel()
                    }), wn.length = 0; else {
                        const Ke = _t.slice();
                        (0, r.r)(() => {
                            Ke.forEach(at => {
                                Q(at, "animation-name"), Q(at, "animation-duration"), Q(at, "animation-timing-function"), Q(at, "animation-iteration-count"), Q(at, "animation-delay"), Q(at, "animation-play-state"), Q(at, "animation-fill-mode"), Q(at, "animation-direction")
                            })
                        })
                    }
                }, tt = () => {
                    Gt.forEach(Ke => {
                        (null == Ke ? void 0 : Ke.parentNode) && Ke.parentNode.removeChild(Ke)
                    }), Gt.length = 0
                }, fr = () => void 0 !== Ue ? Ue : Xe ? Xe.getFill() : "both",
                qn = () => void 0 !== P ? P : void 0 !== it ? it : Xe ? Xe.getDirection() : "normal",
                Yn = () => g ? "linear" : void 0 !== he ? he : Xe ? Xe.getEasing() : "linear",
                Qn = () => v ? 0 : void 0 !== B ? B : void 0 !== Ie ? Ie : Xe ? Xe.getDuration() : 0,
                Wn = () => void 0 !== xe ? xe : Xe ? Xe.getIterations() : 1,
                Xn = () => void 0 !== O ? O : void 0 !== ge ? ge : Xe ? Xe.getDelay() : 0, mn = () => {
                    0 !== f && (f--, 0 === f && ((() => {
                        rr(), xn.forEach(qt => qt()), Fn.forEach(qt => qt());
                        const Ke = E ? 1 : 0, at = ce, Ct = I, Kt = l;
                        _t.forEach(qt => {
                            const Zt = qt.classList;
                            at.forEach(hn => Zt.add(hn)), Ct.forEach(hn => Zt.remove(hn));
                            for (const hn in Kt) Kt.hasOwnProperty(hn) && W(qt, hn, Kt[hn])
                        }), Ye.forEach(qt => qt.c(Ke, q)), Mt.forEach(qt => qt.c(Ke, q)), Mt.length = 0, ze = !0, E && (Z = !0), E = !0
                    })(), Xe && Xe.animationFinish()))
                }, Mn = (Ke = !0) => {
                    tt();
                    const at = (oe => (oe.forEach(ge => {
                        for (const Ie in ge) if (ge.hasOwnProperty(Ie)) {
                            const he = ge[Ie];
                            if ("easing" === Ie) ge["animation-timing-function"] = he, delete ge[Ie]; else {
                                const xe = te(Ie);
                                xe !== Ie && (ge[xe] = he, delete ge[Ie])
                            }
                        }
                    }), oe))(yt);
                    _t.forEach(Ct => {
                        if (at.length > 0) {
                            const Kt = ((oe = []) => oe.map(ge => {
                                const Ie = ge.offset, he = [];
                                for (const xe in ge) ge.hasOwnProperty(xe) && "offset" !== xe && he.push(`${xe}: ${ge[xe]};`);
                                return `${100 * Ie}% { ${he.join(" ")} }`
                            }).join(" "))(at);
                            Je = void 0 !== oe ? oe : (oe => {
                                let ge = me.indexOf(oe);
                                return ge < 0 && (ge = me.push(oe) - 1), `ion-animation-${ge}`
                            })(Kt);
                            const qt = ((oe, ge, Ie) => {
                                const he = (oe => {
                                    const ge = oe.getRootNode();
                                    return ge.head || ge
                                })(Ie), xe = j(Ie), Ue = he.querySelector("#" + oe);
                                if (Ue) return Ue;
                                const it = (Ie.ownerDocument || document).createElement("style");
                                return it.id = oe, it.textContent = `@${xe}keyframes ${oe} { ${ge} } @${xe}keyframes ${oe}-alt { ${ge} }`, he.appendChild(it), it
                            })(Je, Kt, Ct);
                            Gt.push(qt), W(Ct, "animation-duration", `${Qn()}ms`), W(Ct, "animation-timing-function", Yn()), W(Ct, "animation-delay", `${Xn()}ms`), W(Ct, "animation-fill-mode", fr()), W(Ct, "animation-direction", qn());
                            const Zt = Wn() === 1 / 0 ? "infinite" : Wn().toString();
                            W(Ct, "animation-iteration-count", Zt), W(Ct, "animation-play-state", "paused"), Ke && W(Ct, "animation-name", `${qt.id}-alt`), (0, r.r)(() => {
                                W(Ct, "animation-name", qt.id || null)
                            })
                        }
                    })
                }, En = (Ke = !0) => {
                    (() => {
                        yn.forEach(Kt => Kt()), Xt.forEach(Kt => Kt());
                        const Ke = Ce, at = $e, Ct = Ee;
                        _t.forEach(Kt => {
                            const qt = Kt.classList;
                            Ke.forEach(Zt => qt.add(Zt)), at.forEach(Zt => qt.remove(Zt));
                            for (const Zt in Ct) Ct.hasOwnProperty(Zt) && W(Kt, Zt, Ct[Zt])
                        })
                    })(), yt.length > 0 && (On ? (_t.forEach(Ke => {
                        const at = Ke.animate(yt, {
                            id: ut,
                            delay: Xn(),
                            duration: Qn(),
                            easing: Yn(),
                            iterations: Wn(),
                            fill: fr(),
                            direction: qn()
                        });
                        at.pause(), wn.push(at)
                    }), wn.length > 0 && (wn[0].onfinish = () => {
                        mn()
                    })) : Mn(Ke)), rt = !0
                }, Sn = Ke => {
                    if (Ke = Math.min(Math.max(Ke, 0), .9999), On) wn.forEach(at => {
                        at.currentTime = at.effect.getComputedTiming().delay + Qn() * Ke, at.pause()
                    }); else {
                        const at = `-${Qn() * Ke}ms`;
                        _t.forEach(Ct => {
                            yt.length > 0 && (W(Ct, "animation-delay", at), W(Ct, "animation-play-state", "paused"))
                        })
                    }
                }, ar = Ke => {
                    wn.forEach(at => {
                        at.effect.updateTiming({
                            delay: Xn(),
                            duration: Qn(),
                            easing: Yn(),
                            iterations: Wn(),
                            fill: fr(),
                            direction: qn()
                        })
                    }), void 0 !== Ke && Sn(Ke)
                }, Un = (Ke = !0, at) => {
                    (0, r.r)(() => {
                        _t.forEach(Ct => {
                            W(Ct, "animation-name", Je || null), W(Ct, "animation-duration", `${Qn()}ms`), W(Ct, "animation-timing-function", Yn()), W(Ct, "animation-delay", void 0 !== at ? `-${at * Qn()}ms` : `${Xn()}ms`), W(Ct, "animation-fill-mode", fr() || null), W(Ct, "animation-direction", qn() || null);
                            const Kt = Wn() === 1 / 0 ? "infinite" : Wn().toString();
                            W(Ct, "animation-iteration-count", Kt), Ke && W(Ct, "animation-name", `${Je}-alt`), (0, r.r)(() => {
                                W(Ct, "animation-name", Je || null)
                            })
                        })
                    })
                }, nn = (Ke = !1, at = !0, Ct) => (Ke && Pt.forEach(Kt => {
                    Kt.update(Ke, at, Ct)
                }), On ? ar(Ct) : Un(at, Ct), q), Er = () => {
                    rt && (On ? wn.forEach(Ke => {
                        Ke.pause()
                    }) : _t.forEach(Ke => {
                        W(Ke, "animation-play-state", "paused")
                    }), Le = !0)
                }, Ir = () => {
                    w = void 0, mn()
                }, rr = () => {
                    w && clearTimeout(w)
                }, _r = Ke => new Promise(at => {
                    (null == Ke ? void 0 : Ke.sync) && (v = !0, ye(() => v = !1, {oneTimeCallback: !0})), rt || En(), Z && (On ? (Sn(0), ar()) : Un(), Z = !1), ze && (f = Pt.length + 1, ze = !1), ye(() => at(), {oneTimeCallback: !0}), Pt.forEach(Ct => {
                        Ct.play()
                    }), On ? (wn.forEach(Ke => {
                        Ke.play()
                    }), (0 === yt.length || 0 === _t.length) && mn()) : (() => {
                        if (rr(), (0, r.r)(() => {
                            _t.forEach(Ke => {
                                yt.length > 0 && W(Ke, "animation-play-state", "running")
                            })
                        }), 0 === yt.length || 0 === _t.length) mn(); else {
                            const Ke = Xn() || 0, at = Qn() || 0, Ct = Wn() || 1;
                            isFinite(Ct) && (w = setTimeout(Ir, Ke + at * Ct + 100)), ((oe, ge) => {
                                let Ie;
                                const he = {passive: !0}, Ue = it => {
                                    oe === it.target && (Ie && Ie(), rr(), (0, r.r)(() => {
                                        _t.forEach(Ke => {
                                            Q(Ke, "animation-duration"), Q(Ke, "animation-delay"), Q(Ke, "animation-play-state")
                                        }), (0, r.r)(mn)
                                    }))
                                };
                                oe && (oe.addEventListener("webkitAnimationEnd", Ue, he), oe.addEventListener("animationend", Ue, he), Ie = () => {
                                    oe.removeEventListener("webkitAnimationEnd", Ue, he), oe.removeEventListener("animationend", Ue, he)
                                })
                            })(_t[0])
                        }
                    })(), Le = !1
                }), We = (Ke, at) => {
                    const Ct = yt[0];
                    return void 0 === Ct || void 0 !== Ct.offset && 0 !== Ct.offset ? yt = [{
                        offset: 0,
                        [Ke]: at
                    }, ...yt] : Ct[Ke] = at, q
                };
            return q = {
                parentAnimation: Xe,
                elements: _t,
                childAnimations: Pt,
                id: ut,
                animationFinish: mn,
                from: We,
                to: (Ke, at) => {
                    const Ct = yt[yt.length - 1];
                    return void 0 === Ct || void 0 !== Ct.offset && 1 !== Ct.offset ? yt = [...yt, {
                        offset: 1,
                        [Ke]: at
                    }] : Ct[Ke] = at, q
                },
                fromTo: (Ke, at, Ct) => We(Ke, at).to(Ke, Ct),
                parent: Ke => (Xe = Ke, q),
                play: _r,
                pause: () => (Pt.forEach(Ke => {
                    Ke.pause()
                }), Er(), q),
                stop: () => {
                    Pt.forEach(Ke => {
                        Ke.stop()
                    }), rt && (Be(), rt = !1), g = !1, v = !1, ze = !0, P = void 0, B = void 0, O = void 0, f = 0, Z = !1, E = !0, Le = !1
                },
                destroy: Ke => (Pt.forEach(at => {
                    at.destroy(Ke)
                }), (Ke => {
                    Be(), Ke && tt()
                })(Ke), _t.length = 0, Pt.length = 0, yt.length = 0, Ye.length = 0, Mt.length = 0, rt = !1, ze = !0, q),
                keyframes: Ke => {
                    const at = yt !== Ke;
                    return yt = Ke, at && (Ke => {
                        On ? ne().forEach(at => {
                            if (at.effect.setKeyframes) at.effect.setKeyframes(Ke); else {
                                const Ct = new KeyframeEffect(at.effect.target, Ke, at.effect.getTiming());
                                at.effect = Ct
                            }
                        }) : Mn()
                    })(yt), q
                },
                addAnimation: Ke => {
                    if (null != Ke) if (Array.isArray(Ke)) for (const at of Ke) at.parent(q), Pt.push(at); else Ke.parent(q), Pt.push(Ke);
                    return q
                },
                addElement: Ke => {
                    if (null != Ke) if (1 === Ke.nodeType) _t.push(Ke); else if (Ke.length >= 0) for (let at = 0; at < Ke.length; at++) _t.push(Ke[at]); else console.error("Invalid addElement value");
                    return q
                },
                update: nn,
                fill: Ke => (Ue = Ke, nn(!0), q),
                direction: Ke => (it = Ke, nn(!0), q),
                iterations: Ke => (xe = Ke, nn(!0), q),
                duration: Ke => (!On && 0 === Ke && (Ke = 1), Ie = Ke, nn(!0), q),
                easing: Ke => (he = Ke, nn(!0), q),
                delay: Ke => (ge = Ke, nn(!0), q),
                getWebAnimations: ne,
                getKeyframes: () => yt,
                getFill: fr,
                getDirection: qn,
                getDelay: Xn,
                getIterations: Wn,
                getEasing: Yn,
                getDuration: Qn,
                afterAddRead: Ke => (xn.push(Ke), q),
                afterAddWrite: Ke => (Fn.push(Ke), q),
                afterClearStyles: (Ke = []) => {
                    for (const at of Ke) l[at] = "";
                    return q
                },
                afterStyles: (Ke = {}) => (l = Ke, q),
                afterRemoveClass: Ke => (I = H(I, Ke), q),
                afterAddClass: Ke => (ce = H(ce, Ke), q),
                beforeAddRead: Ke => (yn.push(Ke), q),
                beforeAddWrite: Ke => (Xt.push(Ke), q),
                beforeClearStyles: (Ke = []) => {
                    for (const at of Ke) Ee[at] = "";
                    return q
                },
                beforeStyles: (Ke = {}) => (Ee = Ke, q),
                beforeRemoveClass: Ke => ($e = H($e, Ke), q),
                beforeAddClass: Ke => (Ce = H(Ce, Ke), q),
                onFinish: ye,
                isRunning: () => 0 !== f && !Le,
                progressStart: (Ke = !1, at) => (Pt.forEach(Ct => {
                    Ct.progressStart(Ke, at)
                }), Er(), g = Ke, rt || En(), nn(!1, !0, at), q),
                progressStep: Ke => (Pt.forEach(at => {
                    at.progressStep(Ke)
                }), Sn(Ke), q),
                progressEnd: (Ke, at, Ct) => (g = !1, Pt.forEach(Kt => {
                    Kt.progressEnd(Ke, at, Ct)
                }), void 0 !== Ct && (B = Ct), Z = !1, E = !0, 0 === Ke ? (P = "reverse" === qn() ? "normal" : "reverse", "reverse" === P && (E = !1), On ? (nn(), Sn(1 - at)) : (O = (1 - at) * Qn() * -1, nn(!1, !1))) : 1 === Ke && (On ? (nn(), Sn(at)) : (O = at * Qn() * -1, nn(!1, !1))), void 0 !== Ke && (ye(() => {
                    B = void 0, P = void 0, O = void 0
                }, {oneTimeCallback: !0}), Xe || _r()), q)
            }
        }
    }, 8685: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {g: () => r});
        const r = (W, Q, Ne, ve, me) => ie(W[1], Q[1], Ne[1], ve[1], me).map(ae => D(W[0], Q[0], Ne[0], ve[0], ae)),
            D = (W, Q, Ne, ve, me) => me * (3 * Q * Math.pow(me - 1, 2) + me * (-3 * Ne * me + 3 * Ne + ve * me)) - W * Math.pow(me - 1, 3),
            ie = (W, Q, Ne, ve, me) => j((ve -= me) - 3 * (Ne -= me) + 3 * (Q -= me) - (W -= me), 3 * Ne - 6 * Q + 3 * W, 3 * Q - 3 * W, W).filter(X => X >= 0 && X <= 1),
            j = (W, Q, Ne, ve) => {
                if (0 === W) return ((W, Q, Ne) => {
                    const ve = Q * Q - 4 * W * Ne;
                    return ve < 0 ? [] : [(-Q + Math.sqrt(ve)) / (2 * W), (-Q - Math.sqrt(ve)) / (2 * W)]
                })(Q, Ne, ve);
                const me = (3 * (Ne /= W) - (Q /= W) * Q) / 3, ae = (2 * Q * Q * Q - 9 * Q * Ne + 27 * (ve /= W)) / 27;
                if (0 === me) return [Math.pow(-ae, 1 / 3)];
                if (0 === ae) return [Math.sqrt(-me), -Math.sqrt(-me)];
                const X = Math.pow(ae / 2, 2) + Math.pow(me / 3, 3);
                if (0 === X) return [Math.pow(ae / 2, .5) - Q / 3];
                if (X > 0) return [Math.pow(-ae / 2 + Math.sqrt(X), 1 / 3) - Math.pow(ae / 2 + Math.sqrt(X), 1 / 3) - Q / 3];
                const M = Math.sqrt(Math.pow(-me / 3, 3)), H = Math.acos(-ae / (2 * Math.sqrt(Math.pow(-me / 3, 3)))),
                    F = 2 * Math.pow(M, 1 / 3);
                return [F * Math.cos(H / 3) - Q / 3, F * Math.cos((H + 2 * Math.PI) / 3) - Q / 3, F * Math.cos((H + 4 * Math.PI) / 3) - Q / 3]
            }
    }, 3509: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {G: () => j});

        class D {
            constructor(Q, Ne, ve, me, ae) {
                this.id = Ne, this.name = ve, this.disableScroll = ae, this.priority = 1e6 * me + Ne, this.ctrl = Q
            }

            canStart() {
                return !!this.ctrl && this.ctrl.canStart(this.name)
            }

            start() {
                return !!this.ctrl && this.ctrl.start(this.name, this.id, this.priority)
            }

            capture() {
                if (!this.ctrl) return !1;
                const Q = this.ctrl.capture(this.name, this.id, this.priority);
                return Q && this.disableScroll && this.ctrl.disableScroll(this.id), Q
            }

            release() {
                this.ctrl && (this.ctrl.release(this.id), this.disableScroll && this.ctrl.enableScroll(this.id))
            }

            destroy() {
                this.release(), this.ctrl = void 0
            }
        }

        class ie {
            constructor(Q, Ne, ve, me) {
                this.id = Ne, this.disable = ve, this.disableScroll = me, this.ctrl = Q
            }

            block() {
                if (this.ctrl) {
                    if (this.disable) for (const Q of this.disable) this.ctrl.disableGesture(Q, this.id);
                    this.disableScroll && this.ctrl.disableScroll(this.id)
                }
            }

            unblock() {
                if (this.ctrl) {
                    if (this.disable) for (const Q of this.disable) this.ctrl.enableGesture(Q, this.id);
                    this.disableScroll && this.ctrl.enableScroll(this.id)
                }
            }

            destroy() {
                this.unblock(), this.ctrl = void 0
            }
        }

        const te = "backdrop-no-scroll", j = new class r {
            constructor() {
                this.gestureId = 0, this.requestedStart = new Map, this.disabledGestures = new Map, this.disabledScroll = new Set
            }

            createGesture(Q) {
                return new D(this, this.newID(), Q.name, Q.priority || 0, !!Q.disableScroll)
            }

            createBlocker(Q = {}) {
                return new ie(this, this.newID(), Q.disable, !!Q.disableScroll)
            }

            start(Q, Ne, ve) {
                return this.canStart(Q) ? (this.requestedStart.set(Ne, ve), !0) : (this.requestedStart.delete(Ne), !1)
            }

            capture(Q, Ne, ve) {
                if (!this.start(Q, Ne, ve)) return !1;
                const me = this.requestedStart;
                let ae = -1e4;
                if (me.forEach(X => {
                    ae = Math.max(ae, X)
                }), ae === ve) {
                    this.capturedId = Ne, me.clear();
                    const X = new CustomEvent("ionGestureCaptured", {detail: {gestureName: Q}});
                    return document.dispatchEvent(X), !0
                }
                return me.delete(Ne), !1
            }

            release(Q) {
                this.requestedStart.delete(Q), this.capturedId === Q && (this.capturedId = void 0)
            }

            disableGesture(Q, Ne) {
                let ve = this.disabledGestures.get(Q);
                void 0 === ve && (ve = new Set, this.disabledGestures.set(Q, ve)), ve.add(Ne)
            }

            enableGesture(Q, Ne) {
                const ve = this.disabledGestures.get(Q);
                void 0 !== ve && ve.delete(Ne)
            }

            disableScroll(Q) {
                this.disabledScroll.add(Q), 1 === this.disabledScroll.size && document.body.classList.add(te)
            }

            enableScroll(Q) {
                this.disabledScroll.delete(Q), 0 === this.disabledScroll.size && document.body.classList.remove(te)
            }

            canStart(Q) {
                return !(void 0 !== this.capturedId || this.isDisabled(Q))
            }

            isCaptured() {
                return void 0 !== this.capturedId
            }

            isScrollDisabled() {
                return this.disabledScroll.size > 0
            }

            isDisabled(Q) {
                const Ne = this.disabledGestures.get(Q);
                return !!(Ne && Ne.size > 0)
            }

            newID() {
                return this.gestureId++, this.gestureId
            }
        }
    }, 7593: (Jt, lt, R) => {
        "use strict";
        R.r(lt), R.d(lt, {
            MENU_BACK_BUTTON_PRIORITY: () => j,
            OVERLAY_BACK_BUTTON_PRIORITY: () => te,
            blockHardwareBackButton: () => D,
            startHardwareBackButton: () => ie
        });
        var r = R(5861);
        const D = () => {
            document.addEventListener("backbutton", () => {
            })
        }, ie = () => {
            const W = document;
            let Q = !1;
            W.addEventListener("backbutton", () => {
                if (Q) return;
                let Ne = 0, ve = [];
                const me = new CustomEvent("ionBackButton", {
                    bubbles: !1, detail: {
                        register(M, H) {
                            ve.push({priority: M, handler: H, id: Ne++})
                        }
                    }
                });
                W.dispatchEvent(me);
                const ae = function () {
                    var M = (0, r.Z)(function* (H) {
                        try {
                            if (null == H ? void 0 : H.handler) {
                                const F = H.handler(X);
                                null != F && (yield F)
                            }
                        } catch (F) {
                            console.error(F)
                        }
                    });
                    return function (F) {
                        return M.apply(this, arguments)
                    }
                }(), X = () => {
                    if (ve.length > 0) {
                        let M = {
                            priority: Number.MIN_SAFE_INTEGER, handler: () => {
                            }, id: -1
                        };
                        ve.forEach(H => {
                            H.priority >= M.priority && (M = H)
                        }), Q = !0, ve = ve.filter(H => H.id !== M.id), ae(M).then(() => Q = !1)
                    }
                };
                X()
            })
        }, te = 100, j = 99
    }, 3756: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            a: () => Q,
            b: () => Ne,
            c: () => ie,
            d: () => H,
            e: () => F,
            f: () => M,
            g: () => ve,
            h: () => Ue,
            i: () => W,
            j: () => te,
            k: () => X,
            l: () => oe,
            m: () => ae,
            n: () => ge,
            o: () => xe,
            p: () => he,
            q: () => it,
            r: () => me,
            s: () => yt,
            t: () => r,
            u: () => Ie
        });
        const r = (Ce, $e = 0) => new Promise(rt => {
                D(Ce, $e, rt)
            }), D = (Ce, $e = 0, rt) => {
                let Xe, Ee;
                const ce = {passive: !0}, l = () => {
                    Xe && Xe()
                }, f = g => {
                    (void 0 === g || Ce === g.target) && (l(), rt(g))
                };
                return Ce && (Ce.addEventListener("webkitTransitionEnd", f, ce), Ce.addEventListener("transitionend", f, ce), Ee = setTimeout(f, $e + 500), Xe = () => {
                    Ee && (clearTimeout(Ee), Ee = void 0), Ce.removeEventListener("webkitTransitionEnd", f, ce), Ce.removeEventListener("transitionend", f, ce)
                }), l
            }, ie = (Ce, $e) => {
                Ce.componentOnReady ? Ce.componentOnReady().then(rt => $e(rt)) : me(() => $e(Ce))
            }, te = (Ce, $e = []) => {
                const rt = {};
                return $e.forEach(Xe => {
                    Ce.hasAttribute(Xe) && (null !== Ce.getAttribute(Xe) && (rt[Xe] = Ce.getAttribute(Xe)), Ce.removeAttribute(Xe))
                }), rt
            },
            j = ["role", "aria-activedescendant", "aria-atomic", "aria-autocomplete", "aria-braillelabel", "aria-brailleroledescription", "aria-busy", "aria-checked", "aria-colcount", "aria-colindex", "aria-colindextext", "aria-colspan", "aria-controls", "aria-current", "aria-describedby", "aria-description", "aria-details", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-flowto", "aria-haspopup", "aria-hidden", "aria-invalid", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-level", "aria-live", "aria-multiline", "aria-multiselectable", "aria-orientation", "aria-owns", "aria-placeholder", "aria-posinset", "aria-pressed", "aria-readonly", "aria-relevant", "aria-required", "aria-roledescription", "aria-rowcount", "aria-rowindex", "aria-rowindextext", "aria-rowspan", "aria-selected", "aria-setsize", "aria-sort", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"],
            W = Ce => te(Ce, j), Q = (Ce, $e, rt, Xe) => {
                var Ee;
                if ("undefined" != typeof window) {
                    const ce = window,
                        I = null === (Ee = null == ce ? void 0 : ce.Ionic) || void 0 === Ee ? void 0 : Ee.config;
                    if (I) {
                        const l = I.get("_ael");
                        if (l) return l(Ce, $e, rt, Xe);
                        if (I._ael) return I._ael(Ce, $e, rt, Xe)
                    }
                }
                return Ce.addEventListener($e, rt, Xe)
            }, Ne = (Ce, $e, rt, Xe) => {
                var Ee;
                if ("undefined" != typeof window) {
                    const ce = window,
                        I = null === (Ee = null == ce ? void 0 : ce.Ionic) || void 0 === Ee ? void 0 : Ee.config;
                    if (I) {
                        const l = I.get("_rel");
                        if (l) return l(Ce, $e, rt, Xe);
                        if (I._rel) return I._rel(Ce, $e, rt, Xe)
                    }
                }
                return Ce.removeEventListener($e, rt, Xe)
            }, ve = (Ce, $e = Ce) => Ce.shadowRoot || $e,
            me = Ce => "function" == typeof __zone_symbol__requestAnimationFrame ? __zone_symbol__requestAnimationFrame(Ce) : "function" == typeof requestAnimationFrame ? requestAnimationFrame(Ce) : setTimeout(Ce),
            ae = Ce => !!Ce.shadowRoot && !!Ce.attachShadow, X = Ce => {
                const $e = Ce.closest("ion-item");
                return $e ? $e.querySelector("ion-label") : null
            }, M = Ce => {
                if (Ce.focus(), Ce.classList.contains("ion-focusable")) {
                    const $e = Ce.closest("ion-app");
                    $e && $e.setFocus([Ce])
                }
            }, H = (Ce, $e) => {
                let rt;
                const Xe = Ce.getAttribute("aria-labelledby"), Ee = Ce.id;
                let ce = null !== Xe && "" !== Xe.trim() ? Xe : $e + "-lbl",
                    I = null !== Xe && "" !== Xe.trim() ? document.getElementById(Xe) : X(Ce);
                return I ? (null === Xe && (I.id = ce), rt = I.textContent, I.setAttribute("aria-hidden", "true")) : "" !== Ee.trim() && (I = document.querySelector(`label[for="${Ee}"]`), I && ("" !== I.id ? ce = I.id : I.id = ce = `${Ee}-lbl`, rt = I.textContent)), {
                    label: I,
                    labelId: ce,
                    labelText: rt
                }
            }, F = (Ce, $e, rt, Xe, Ee) => {
                if (Ce || ae($e)) {
                    let ce = $e.querySelector("input.aux-input");
                    ce || (ce = $e.ownerDocument.createElement("input"), ce.type = "hidden", ce.classList.add("aux-input"), $e.appendChild(ce)), ce.disabled = Ee, ce.name = rt, ce.value = Xe || ""
                }
            }, oe = (Ce, $e, rt) => Math.max(Ce, Math.min($e, rt)), ge = (Ce, $e) => {
                if (!Ce) {
                    const rt = "ASSERT: " + $e;
                    throw console.error(rt), new Error(rt)
                }
            }, Ie = Ce => Ce.timeStamp || Date.now(), he = Ce => {
                if (Ce) {
                    const $e = Ce.changedTouches;
                    if ($e && $e.length > 0) {
                        const rt = $e[0];
                        return {x: rt.clientX, y: rt.clientY}
                    }
                    if (void 0 !== Ce.pageX) return {x: Ce.pageX, y: Ce.pageY}
                }
                return {x: 0, y: 0}
            }, xe = Ce => {
                const $e = "rtl" === document.dir;
                switch (Ce) {
                    case"start":
                        return $e;
                    case"end":
                        return !$e;
                    default:
                        throw new Error(`"${Ce}" is not a valid value for [side]. Use "start" or "end" instead.`)
                }
            }, Ue = (Ce, $e) => {
                const rt = Ce._original || Ce;
                return {_original: Ce, emit: it(rt.emit.bind(rt), $e)}
            }, it = (Ce, $e = 0) => {
                let rt;
                return (...Xe) => {
                    clearTimeout(rt), rt = setTimeout(Ce, $e, ...Xe)
                }
            }, yt = (Ce, $e) => {
                if (null != Ce || (Ce = {}), null != $e || ($e = {}), Ce === $e) return !0;
                const rt = Object.keys(Ce);
                if (rt.length !== Object.keys($e).length) return !1;
                for (const Xe of rt) if (!(Xe in $e) || Ce[Xe] !== $e[Xe]) return !1;
                return !0
            }
    }, 3139: (Jt, lt, R) => {
        "use strict";
        R.r(lt), R.d(lt, {GESTURE_CONTROLLER: () => r.G, createGesture: () => ve});
        var r = R(3509);
        const D = (M, H, F, oe) => {
            const ge = ie(M) ? {capture: !!oe.capture, passive: !!oe.passive} : !!oe.capture;
            let Ie, he;
            return M.__zone_symbol__addEventListener ? (Ie = "__zone_symbol__addEventListener", he = "__zone_symbol__removeEventListener") : (Ie = "addEventListener", he = "removeEventListener"), M[Ie](H, F, ge), () => {
                M[he](H, F, ge)
            }
        }, ie = M => {
            if (void 0 === te) try {
                const H = Object.defineProperty({}, "passive", {
                    get: () => {
                        te = !0
                    }
                });
                M.addEventListener("optsTest", () => {
                }, H)
            } catch (H) {
                te = !1
            }
            return !!te
        };
        let te;
        const Q = M => M instanceof Document ? M : M.ownerDocument, ve = M => {
            let H = !1, F = !1, oe = !0, ge = !1;
            const Ie = Object.assign({
                    disableScroll: !1,
                    direction: "x",
                    gesturePriority: 0,
                    passive: !0,
                    maxAngle: 40,
                    threshold: 10
                }, M), he = Ie.canStart, xe = Ie.onWillStart, Ue = Ie.onStart, it = Ie.onEnd, yt = Ie.notCaptured,
                Ce = Ie.onMove, $e = Ie.threshold, rt = Ie.passive, Xe = Ie.blurOnStart, Ee = {
                    type: "pan",
                    startX: 0,
                    startY: 0,
                    startTime: 0,
                    currentX: 0,
                    currentY: 0,
                    velocityX: 0,
                    velocityY: 0,
                    deltaX: 0,
                    deltaY: 0,
                    currentTime: 0,
                    event: void 0,
                    data: void 0
                }, ce = ((M, H, F) => {
                    const oe = F * (Math.PI / 180), ge = "x" === M, Ie = Math.cos(oe), he = H * H;
                    let xe = 0, Ue = 0, it = !1, yt = 0;
                    return {
                        start(Ce, $e) {
                            xe = Ce, Ue = $e, yt = 0, it = !0
                        }, detect(Ce, $e) {
                            if (!it) return !1;
                            const rt = Ce - xe, Xe = $e - Ue, Ee = rt * rt + Xe * Xe;
                            if (Ee < he) return !1;
                            const ce = Math.sqrt(Ee), I = (ge ? rt : Xe) / ce;
                            return yt = I > Ie ? 1 : I < -Ie ? -1 : 0, it = !1, !0
                        }, isGesture: () => 0 !== yt, getDirection: () => yt
                    }
                })(Ie.direction, Ie.threshold, Ie.maxAngle), I = r.G.createGesture({
                    name: M.gestureName,
                    priority: M.gesturePriority,
                    disableScroll: M.disableScroll
                }), g = () => {
                    !H || (ge = !1, Ce && Ce(Ee))
                },
                v = () => !(I && !I.capture() || (H = !0, oe = !1, Ee.startX = Ee.currentX, Ee.startY = Ee.currentY, Ee.startTime = Ee.currentTime, xe ? xe(Ee).then(P) : P(), 0)),
                P = () => {
                    Xe && (() => {
                        if ("undefined" != typeof document) {
                            const ze = document.activeElement;
                            (null == ze ? void 0 : ze.blur) && ze.blur()
                        }
                    })(), Ue && Ue(Ee), oe = !0
                }, B = () => {
                    H = !1, F = !1, ge = !1, oe = !0, I.release()
                }, O = ze => {
                    const Je = H, q = oe;
                    if (B(), q) {
                        if (me(Ee, ze), Je) return void (it && it(Ee));
                        yt && yt(Ee)
                    }
                }, E = ((M, H, F, oe, ge) => {
                    let Ie, he, xe, Ue, it, yt, Ce, $e = 0;
                    const rt = w => {
                        $e = Date.now() + 2e3, H(w) && (!he && F && (he = D(M, "touchmove", F, ge)), xe || (xe = D(w.target, "touchend", Ee, ge)), Ue || (Ue = D(w.target, "touchcancel", Ee, ge)))
                    }, Xe = w => {
                        $e > Date.now() || !H(w) || (!yt && F && (yt = D(Q(M), "mousemove", F, ge)), Ce || (Ce = D(Q(M), "mouseup", ce, ge)))
                    }, Ee = w => {
                        I(), oe && oe(w)
                    }, ce = w => {
                        l(), oe && oe(w)
                    }, I = () => {
                        he && he(), xe && xe(), Ue && Ue(), he = xe = Ue = void 0
                    }, l = () => {
                        yt && yt(), Ce && Ce(), yt = Ce = void 0
                    }, f = () => {
                        I(), l()
                    }, g = (w = !0) => {
                        w ? (Ie || (Ie = D(M, "touchstart", rt, ge)), it || (it = D(M, "mousedown", Xe, ge))) : (Ie && Ie(), it && it(), Ie = it = void 0, f())
                    };
                    return {
                        enable: g, stop: f, destroy: () => {
                            g(!1), oe = F = H = void 0
                        }
                    }
                })(Ie.el, ze => {
                    const Je = X(ze);
                    return !(F || !oe || (ae(ze, Ee), Ee.startX = Ee.currentX, Ee.startY = Ee.currentY, Ee.startTime = Ee.currentTime = Je, Ee.velocityX = Ee.velocityY = Ee.deltaX = Ee.deltaY = 0, Ee.event = ze, he && !1 === he(Ee)) || (I.release(), !I.start())) && (F = !0, 0 === $e ? v() : (ce.start(Ee.startX, Ee.startY), !0))
                }, ze => {
                    H ? !ge && oe && (ge = !0, me(Ee, ze), requestAnimationFrame(g)) : (me(Ee, ze), ce.detect(Ee.currentX, Ee.currentY) && (!ce.isGesture() || !v()) && Z())
                }, O, {capture: !1, passive: rt}), Z = () => {
                    B(), E.stop(), yt && yt(Ee)
                };
            return {
                enable(ze = !0) {
                    ze || (H && O(void 0), B()), E.enable(ze)
                }, destroy() {
                    I.destroy(), E.destroy()
                }
            }
        }, me = (M, H) => {
            if (!H) return;
            const F = M.currentX, oe = M.currentY, ge = M.currentTime;
            ae(H, M);
            const Ie = M.currentX, he = M.currentY, Ue = (M.currentTime = X(H)) - ge;
            if (Ue > 0 && Ue < 100) {
                const yt = (he - oe) / Ue;
                M.velocityX = (Ie - F) / Ue * .7 + .3 * M.velocityX, M.velocityY = .7 * yt + .3 * M.velocityY
            }
            M.deltaX = Ie - M.startX, M.deltaY = he - M.startY, M.event = H
        }, ae = (M, H) => {
            let F = 0, oe = 0;
            if (M) {
                const ge = M.changedTouches;
                if (ge && ge.length > 0) {
                    const Ie = ge[0];
                    F = Ie.clientX, oe = Ie.clientY
                } else void 0 !== M.pageX && (F = M.pageX, oe = M.pageY)
            }
            H.currentX = F, H.currentY = oe
        }, X = M => M.timeStamp || Date.now()
    }, 9753: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            L: () => te,
            a: () => j,
            b: () => W,
            c: () => Q,
            d: () => Ne,
            e: () => $e,
            g: () => Ee,
            l: () => yt,
            s: () => rt,
            t: () => ae
        });
        var r = R(5861), D = R(7205), ie = R(3756);
        const te = "ionViewWillEnter", j = "ionViewDidEnter", W = "ionViewWillLeave", Q = "ionViewDidLeave",
            Ne = "ionViewWillUnload", ae = ce => new Promise((I, l) => {
                (0, D.c)(() => {
                    X(ce), M(ce).then(f => {
                        f.animation && f.animation.destroy(), H(ce), I(f)
                    }, f => {
                        H(ce), l(f)
                    })
                })
            }), X = ce => {
                const I = ce.enteringEl, l = ce.leavingEl;
                Xe(I, l, ce.direction), ce.showGoBack ? I.classList.add("can-go-back") : I.classList.remove("can-go-back"), rt(I, !1), I.style.setProperty("pointer-events", "none"), l && (rt(l, !1), l.style.setProperty("pointer-events", "none"))
            }, M = function () {
                var ce = (0, r.Z)(function* (I) {
                    const l = yield F(I);
                    return l && D.B.isBrowser ? oe(l, I) : ge(I)
                });
                return function (l) {
                    return ce.apply(this, arguments)
                }
            }(), H = ce => {
                const I = ce.enteringEl, l = ce.leavingEl;
                I.classList.remove("ion-page-invisible"), I.style.removeProperty("pointer-events"), void 0 !== l && (l.classList.remove("ion-page-invisible"), l.style.removeProperty("pointer-events"))
            }, F = function () {
                var ce = (0, r.Z)(function* (I) {
                    return I.leavingEl && I.animated && 0 !== I.duration ? I.animationBuilder ? I.animationBuilder : "ios" === I.mode ? (yield Promise.resolve().then(R.bind(R, 4181))).iosTransitionAnimation : (yield Promise.resolve().then(R.bind(R, 5980))).mdTransitionAnimation : void 0
                });
                return function (l) {
                    return ce.apply(this, arguments)
                }
            }(), oe = function () {
                var ce = (0, r.Z)(function* (I, l) {
                    yield Ie(l, !0);
                    const f = I(l.baseEl, l);
                    Ue(l.enteringEl, l.leavingEl);
                    const g = yield xe(f, l);
                    return l.progressCallback && l.progressCallback(void 0), g && it(l.enteringEl, l.leavingEl), {
                        hasCompleted: g,
                        animation: f
                    }
                });
                return function (l, f) {
                    return ce.apply(this, arguments)
                }
            }(), ge = function () {
                var ce = (0, r.Z)(function* (I) {
                    const l = I.enteringEl, f = I.leavingEl;
                    return yield Ie(I, !1), Ue(l, f), it(l, f), {hasCompleted: !0}
                });
                return function (l) {
                    return ce.apply(this, arguments)
                }
            }(), Ie = function () {
                var ce = (0, r.Z)(function* (I, l) {
                    const g = (void 0 !== I.deepWait ? I.deepWait : l) ? [$e(I.enteringEl), $e(I.leavingEl)] : [Ce(I.enteringEl), Ce(I.leavingEl)];
                    yield Promise.all(g), yield he(I.viewIsReady, I.enteringEl)
                });
                return function (l, f) {
                    return ce.apply(this, arguments)
                }
            }(), he = function () {
                var ce = (0, r.Z)(function* (I, l) {
                    I && (yield I(l))
                });
                return function (l, f) {
                    return ce.apply(this, arguments)
                }
            }(), xe = (ce, I) => {
                const l = I.progressCallback, f = new Promise(g => {
                    ce.onFinish(v => g(1 === v))
                });
                return l ? (ce.progressStart(!0), l(ce)) : ce.play(), f
            }, Ue = (ce, I) => {
                yt(I, W), yt(ce, te)
            }, it = (ce, I) => {
                yt(ce, j), yt(I, Q)
            }, yt = (ce, I) => {
                if (ce) {
                    const l = new CustomEvent(I, {bubbles: !1, cancelable: !1});
                    ce.dispatchEvent(l)
                }
            }, Ce = ce => ce ? new Promise(I => (0, ie.c)(ce, I)) : Promise.resolve(), $e = function () {
                var ce = (0, r.Z)(function* (I) {
                    const l = I;
                    if (l) {
                        if (null != l.componentOnReady) {
                            if (null != (yield l.componentOnReady())) return
                        } else if (null != l.__registerHost) return void (yield new Promise(g => (0, ie.r)(g)));
                        yield Promise.all(Array.from(l.children).map($e))
                    }
                });
                return function (l) {
                    return ce.apply(this, arguments)
                }
            }(), rt = (ce, I) => {
                I ? (ce.setAttribute("aria-hidden", "true"), ce.classList.add("ion-page-hidden")) : (ce.hidden = !1, ce.removeAttribute("aria-hidden"), ce.classList.remove("ion-page-hidden"))
            }, Xe = (ce, I, l) => {
                void 0 !== ce && (ce.style.zIndex = "back" === l ? "99" : "101"), void 0 !== I && (I.style.zIndex = "100")
            },
            Ee = ce => ce.classList.contains("ion-page") ? ce : ce.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs") || ce
    }, 7205: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            B: () => _r,
            H: () => Pt,
            a: () => Z,
            b: () => Pn,
            c: () => Br,
            e: () => bn,
            f: () => $n,
            g: () => ze,
            h: () => Mt,
            i: () => Ht,
            j: () => Yn,
            k: () => mn,
            p: () => oe,
            r: () => En,
            s: () => H
        });
        var r = R(5861);
        let ie, te, j, W = !1, Q = !1, Ne = !1, ve = !1, me = !1;
        const ae = "undefined" != typeof window ? window : {}, X = ae.document || {head: {}}, M = {
                $flags$: 0,
                $resourcesUrl$: "",
                jmp: Pe => Pe(),
                raf: Pe => requestAnimationFrame(Pe),
                ael: (Pe, We, Et, Ot) => Pe.addEventListener(We, Et, Ot),
                rel: (Pe, We, Et, Ot) => Pe.removeEventListener(We, Et, Ot),
                ce: (Pe, We) => new CustomEvent(Pe, We)
            }, H = Pe => {
                Object.assign(M, Pe)
            }, oe = Pe => Promise.resolve(Pe), ge = (() => {
                try {
                    return new CSSStyleSheet, "function" == typeof (new CSSStyleSheet).replace
                } catch (Pe) {
                }
                return !1
            })(), Ie = (Pe, We, Et, Ot) => {
                Et && Et.map(([Ke, at, Ct]) => {
                    const Kt = xe(Pe, Ke), qt = he(We, Ct), Zt = Ue(Ke);
                    M.ael(Kt, at, qt, Zt), (We.$rmListeners$ = We.$rmListeners$ || []).push(() => M.rel(Kt, at, qt, Zt))
                })
            }, he = (Pe, We) => Et => {
                try {
                    256 & Pe.$flags$ ? Pe.$lazyInstance$[We](Et) : (Pe.$queuedListeners$ = Pe.$queuedListeners$ || []).push([We, Et])
                } catch (Ot) {
                    Un(Ot)
                }
            }, xe = (Pe, We) => 4 & We ? X : 8 & We ? ae : 16 & We ? X.body : Pe, Ue = Pe => 0 != (2 & Pe), rt = "s-id",
            Xe = "sty-id", I = "http://www.w3.org/1999/xlink", g = new WeakMap, v = (Pe, We, Et) => {
                let Ot = tr.get(Pe);
                ge && Et ? (Ot = Ot || new CSSStyleSheet, Ot.replace(We)) : Ot = We, tr.set(Pe, Ot)
            }, w = (Pe, We, Et, Ot) => {
                let Ke = B(We, Et);
                const at = tr.get(Ke);
                if (Pe = 11 === Pe.nodeType ? Pe : X, at) if ("string" == typeof at) {
                    let Kt, Ct = g.get(Pe = Pe.head || Pe);
                    Ct || g.set(Pe, Ct = new Set), Ct.has(Ke) || (Pe.host && (Kt = Pe.querySelector(`[${Xe}="${Ke}"]`)) ? Kt.innerHTML = at : (Kt = X.createElement("style"), Kt.innerHTML = at, Pe.insertBefore(Kt, Pe.querySelector("link"))), Ct && Ct.add(Ke))
                } else Pe.adoptedStyleSheets.includes(at) || (Pe.adoptedStyleSheets = [...Pe.adoptedStyleSheets, at]);
                return Ke
            }, B = (Pe, We) => "sc-" + (We && 32 & Pe.$flags$ ? Pe.$tagName$ + "-" + We : Pe.$tagName$),
            O = Pe => Pe.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, "$1{"), Z = Pe => nr.push(Pe),
            ze = Pe => an(Pe).$modeName$, Je = {}, Ye = Pe => "object" == (Pe = typeof Pe) || "function" === Pe,
            Mt = (Pe, We, ...Et) => {
                let Ot = null, Ke = null, at = null, Ct = !1, Kt = !1;
                const qt = [], Zt = Bn => {
                    for (let Zn = 0; Zn < Bn.length; Zn++) Ot = Bn[Zn], Array.isArray(Ot) ? Zt(Ot) : null != Ot && "boolean" != typeof Ot && ((Ct = "function" != typeof Pe && !Ye(Ot)) && (Ot = String(Ot)), Ct && Kt ? qt[qt.length - 1].$text$ += Ot : qt.push(Ct ? _t(null, Ot) : Ot), Kt = Ct)
                };
                if (Zt(Et), We) {
                    We.key && (Ke = We.key), We.name && (at = We.name);
                    {
                        const Bn = We.className || We.class;
                        Bn && (We.class = "object" != typeof Bn ? Bn : Object.keys(Bn).filter(Zn => Bn[Zn]).join(" "))
                    }
                }
                if ("function" == typeof Pe) return Pe(null === We ? {} : We, qt, yn);
                const hn = _t(Pe, null);
                return hn.$attrs$ = We, qt.length > 0 && (hn.$children$ = qt), hn.$key$ = Ke, hn.$name$ = at, hn
            }, _t = (Pe, We) => ({
                $flags$: 0,
                $tag$: Pe,
                $text$: We,
                $elm$: null,
                $children$: null,
                $attrs$: null,
                $key$: null,
                $name$: null
            }), Pt = {}, yn = {forEach: (Pe, We) => Pe.map(Xt).forEach(We), map: (Pe, We) => Pe.map(Xt).map(We).map(xn)},
            Xt = Pe => ({
                vattrs: Pe.$attrs$,
                vchildren: Pe.$children$,
                vkey: Pe.$key$,
                vname: Pe.$name$,
                vtag: Pe.$tag$,
                vtext: Pe.$text$
            }), xn = Pe => {
                if ("function" == typeof Pe.vtag) {
                    const Et = Object.assign({}, Pe.vattrs);
                    return Pe.vkey && (Et.key = Pe.vkey), Pe.vname && (Et.name = Pe.vname), Mt(Pe.vtag, Et, ...Pe.vchildren || [])
                }
                const We = _t(Pe.vtag, Pe.vtext);
                return We.$attrs$ = Pe.vattrs, We.$children$ = Pe.vchildren, We.$key$ = Pe.vkey, We.$name$ = Pe.vname, We
            }, Fn = (Pe, We, Et, Ot, Ke, at) => {
                if (Et !== Ot) {
                    let Ct = ar(Pe, We), Kt = We.toLowerCase();
                    if ("class" === We) {
                        const qt = Pe.classList, Zt = Nn(Et), hn = Nn(Ot);
                        qt.remove(...Zt.filter(Bn => Bn && !hn.includes(Bn))), qt.add(...hn.filter(Bn => Bn && !Zt.includes(Bn)))
                    } else if ("style" === We) {
                        for (const qt in Et) (!Ot || null == Ot[qt]) && (qt.includes("-") ? Pe.style.removeProperty(qt) : Pe.style[qt] = "");
                        for (const qt in Ot) (!Et || Ot[qt] !== Et[qt]) && (qt.includes("-") ? Pe.style.setProperty(qt, Ot[qt]) : Pe.style[qt] = Ot[qt])
                    } else if ("key" !== We) if ("ref" === We) Ot && Ot(Pe); else if (Ct || "o" !== We[0] || "n" !== We[1]) {
                        const qt = Ye(Ot);
                        if ((Ct || qt && null !== Ot) && !Ke) try {
                            if (Pe.tagName.includes("-")) Pe[We] = Ot; else {
                                const hn = null == Ot ? "" : Ot;
                                "list" === We ? Ct = !1 : (null == Et || Pe[We] != hn) && (Pe[We] = hn)
                            }
                        } catch (hn) {
                        }
                        let Zt = !1;
                        Kt !== (Kt = Kt.replace(/^xlink\:?/, "")) && (We = Kt, Zt = !0), null == Ot || !1 === Ot ? (!1 !== Ot || "" === Pe.getAttribute(We)) && (Zt ? Pe.removeAttributeNS(I, We) : Pe.removeAttribute(We)) : (!Ct || 4 & at || Ke) && !qt && (Ot = !0 === Ot ? "" : Ot, Zt ? Pe.setAttributeNS(I, We, Ot) : Pe.setAttribute(We, Ot))
                    } else We = "-" === We[2] ? We.slice(3) : ar(ae, Kt) ? Kt.slice(2) : Kt[2] + We.slice(3), Et && M.rel(Pe, We, Et, !1), Ot && M.ael(Pe, We, Ot, !1)
                }
            }, wn = /\s/, Nn = Pe => Pe ? Pe.split(wn) : [], On = (Pe, We, Et, Ot) => {
                const Ke = 11 === We.$elm$.nodeType && We.$elm$.host ? We.$elm$.host : We.$elm$,
                    at = Pe && Pe.$attrs$ || Je, Ct = We.$attrs$ || Je;
                for (Ot in at) Ot in Ct || Fn(Ke, Ot, at[Ot], void 0, Et, We.$flags$);
                for (Ot in Ct) Fn(Ke, Ot, at[Ot], Ct[Ot], Et, We.$flags$)
            }, Me = (Pe, We, Et, Ot) => {
                const Ke = We.$children$[Et];
                let Ct, Kt, qt, at = 0;
                if (W || (Ne = !0, "slot" === Ke.$tag$ && (ie && Ot.classList.add(ie + "-s"), Ke.$flags$ |= Ke.$children$ ? 2 : 1)), null !== Ke.$text$) Ct = Ke.$elm$ = X.createTextNode(Ke.$text$); else if (1 & Ke.$flags$) Ct = Ke.$elm$ = X.createTextNode(""); else {
                    if (ve || (ve = "svg" === Ke.$tag$), Ct = Ke.$elm$ = X.createElementNS(ve ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", 2 & Ke.$flags$ ? "slot-fb" : Ke.$tag$), ve && "foreignObject" === Ke.$tag$ && (ve = !1), On(null, Ke, ve), (Pe => null != Pe)(ie) && Ct["s-si"] !== ie && Ct.classList.add(Ct["s-si"] = ie), Ke.$children$) for (at = 0; at < Ke.$children$.length; ++at) Kt = Me(Pe, Ke, at, Ct), Kt && Ct.appendChild(Kt);
                    "svg" === Ke.$tag$ ? ve = !1 : "foreignObject" === Ct.tagName && (ve = !0)
                }
                return Ct["s-hn"] = j, 3 & Ke.$flags$ && (Ct["s-sr"] = !0, Ct["s-cr"] = te, Ct["s-sn"] = Ke.$name$ || "", qt = Pe && Pe.$children$ && Pe.$children$[Et], qt && qt.$tag$ === Ke.$tag$ && Pe.$elm$ && ne(Pe.$elm$, !1)), Ct
            }, ne = (Pe, We) => {
                M.$flags$ |= 1;
                const Et = Pe.childNodes;
                for (let Ot = Et.length - 1; Ot >= 0; Ot--) {
                    const Ke = Et[Ot];
                    Ke["s-hn"] !== j && Ke["s-ol"] && (Te(Ke).insertBefore(Ke, ye(Ke)), Ke["s-ol"].remove(), Ke["s-ol"] = void 0, Ne = !0), We && ne(Ke, We)
                }
                M.$flags$ &= -2
            }, U = (Pe, We, Et, Ot, Ke, at) => {
                let Kt, Ct = Pe["s-cr"] && Pe["s-cr"].parentNode || Pe;
                for (Ct.shadowRoot && Ct.tagName === j && (Ct = Ct.shadowRoot); Ke <= at; ++Ke) Ot[Ke] && (Kt = Me(null, Et, Ke, Pe), Kt && (Ot[Ke].$elm$ = Kt, Ct.insertBefore(Kt, ye(We))))
            }, de = (Pe, We, Et, Ot, Ke) => {
                for (; We <= Et; ++We) (Ot = Pe[We]) && (Ke = Ot.$elm$, dn(Ot), Q = !0, Ke["s-ol"] ? Ke["s-ol"].remove() : ne(Ke, !0), Ke.remove())
            },
            Ge = (Pe, We) => Pe.$tag$ === We.$tag$ && ("slot" === Pe.$tag$ ? Pe.$name$ === We.$name$ : Pe.$key$ === We.$key$),
            ye = Pe => Pe && Pe["s-ol"] || Pe, Te = Pe => (Pe["s-ol"] ? Pe["s-ol"] : Pe).parentNode, Be = (Pe, We) => {
                const Et = We.$elm$ = Pe.$elm$, Ot = Pe.$children$, Ke = We.$children$, at = We.$tag$, Ct = We.$text$;
                let Kt;
                null === Ct ? (ve = "svg" === at || "foreignObject" !== at && ve, "slot" === at || On(Pe, We, ve), null !== Ot && null !== Ke ? ((Pe, We, Et, Ot) => {
                    let xr, $r, Ke = 0, at = 0, Ct = 0, Kt = 0, qt = We.length - 1, Zt = We[0], hn = We[qt],
                        Bn = Ot.length - 1, Zn = Ot[0], lr = Ot[Bn];
                    for (; Ke <= qt && at <= Bn;) if (null == Zt) Zt = We[++Ke]; else if (null == hn) hn = We[--qt]; else if (null == Zn) Zn = Ot[++at]; else if (null == lr) lr = Ot[--Bn]; else if (Ge(Zt, Zn)) Be(Zt, Zn), Zt = We[++Ke], Zn = Ot[++at]; else if (Ge(hn, lr)) Be(hn, lr), hn = We[--qt], lr = Ot[--Bn]; else if (Ge(Zt, lr)) ("slot" === Zt.$tag$ || "slot" === lr.$tag$) && ne(Zt.$elm$.parentNode, !1), Be(Zt, lr), Pe.insertBefore(Zt.$elm$, hn.$elm$.nextSibling), Zt = We[++Ke], lr = Ot[--Bn]; else if (Ge(hn, Zn)) ("slot" === Zt.$tag$ || "slot" === lr.$tag$) && ne(hn.$elm$.parentNode, !1), Be(hn, Zn), Pe.insertBefore(hn.$elm$, Zt.$elm$), hn = We[--qt], Zn = Ot[++at]; else {
                        for (Ct = -1, Kt = Ke; Kt <= qt; ++Kt) if (We[Kt] && null !== We[Kt].$key$ && We[Kt].$key$ === Zn.$key$) {
                            Ct = Kt;
                            break
                        }
                        Ct >= 0 ? ($r = We[Ct], $r.$tag$ !== Zn.$tag$ ? xr = Me(We && We[at], Et, Ct, Pe) : (Be($r, Zn), We[Ct] = void 0, xr = $r.$elm$), Zn = Ot[++at]) : (xr = Me(We && We[at], Et, at, Pe), Zn = Ot[++at]), xr && Te(Zt.$elm$).insertBefore(xr, ye(Zt.$elm$))
                    }
                    Ke > qt ? U(Pe, null == Ot[Bn + 1] ? null : Ot[Bn + 1].$elm$, Et, Ot, at, Bn) : at > Bn && de(We, Ke, qt)
                })(Et, Ot, We, Ke) : null !== Ke ? (null !== Pe.$text$ && (Et.textContent = ""), U(Et, null, We, Ke, 0, Ke.length - 1)) : null !== Ot && de(Ot, 0, Ot.length - 1), ve && "svg" === at && (ve = !1)) : (Kt = Et["s-cr"]) ? Kt.parentNode.textContent = Ct : Pe.$text$ !== Ct && (Et.data = Ct)
            }, tt = Pe => {
                const We = Pe.childNodes;
                let Et, Ot, Ke, at, Ct, Kt;
                for (Ot = 0, Ke = We.length; Ot < Ke; Ot++) if (Et = We[Ot], 1 === Et.nodeType) {
                    if (Et["s-sr"]) for (Ct = Et["s-sn"], Et.hidden = !1, at = 0; at < Ke; at++) if (Kt = We[at].nodeType, We[at]["s-hn"] !== Et["s-hn"] || "" !== Ct) {
                        if (1 === Kt && Ct === We[at].getAttribute("slot")) {
                            Et.hidden = !0;
                            break
                        }
                    } else if (1 === Kt || 3 === Kt && "" !== We[at].textContent.trim()) {
                        Et.hidden = !0;
                        break
                    }
                    tt(Et)
                }
            }, Dt = [], Ft = Pe => {
                let We, Et, Ot, Ke, at, Ct, Kt = 0;
                const qt = Pe.childNodes, Zt = qt.length;
                for (; Kt < Zt; Kt++) {
                    if (We = qt[Kt], We["s-sr"] && (Et = We["s-cr"]) && Et.parentNode) for (Ot = Et.parentNode.childNodes, Ke = We["s-sn"], Ct = Ot.length - 1; Ct >= 0; Ct--) Et = Ot[Ct], !Et["s-cn"] && !Et["s-nr"] && Et["s-hn"] !== We["s-hn"] && (zt(Et, Ke) ? (at = Dt.find(hn => hn.$nodeToRelocate$ === Et), Q = !0, Et["s-sn"] = Et["s-sn"] || Ke, at ? at.$slotRefNode$ = We : Dt.push({
                        $slotRefNode$: We,
                        $nodeToRelocate$: Et
                    }), Et["s-sr"] && Dt.map(hn => {
                        zt(hn.$nodeToRelocate$, Et["s-sn"]) && (at = Dt.find(Bn => Bn.$nodeToRelocate$ === Et), at && !hn.$slotRefNode$ && (hn.$slotRefNode$ = at.$slotRefNode$))
                    })) : Dt.some(hn => hn.$nodeToRelocate$ === Et) || Dt.push({$nodeToRelocate$: Et}));
                    1 === We.nodeType && Ft(We)
                }
            },
            zt = (Pe, We) => 1 === Pe.nodeType ? null === Pe.getAttribute("slot") && "" === We || Pe.getAttribute("slot") === We : Pe["s-sn"] === We || "" === We,
            dn = Pe => {
                Pe.$attrs$ && Pe.$attrs$.ref && Pe.$attrs$.ref(null), Pe.$children$ && Pe.$children$.map(dn)
            }, Ht = Pe => an(Pe).$hostElement$, bn = (Pe, We, Et) => {
                const Ot = Ht(Pe);
                return {
                    emit: Ke => fn(Ot, We, {
                        bubbles: !!(4 & Et),
                        composed: !!(2 & Et),
                        cancelable: !!(1 & Et),
                        detail: Ke
                    })
                }
            }, fn = (Pe, We, Et) => {
                const Ot = M.ce(We, Et);
                return Pe.dispatchEvent(Ot), Ot
            }, rn = (Pe, We) => {
                We && !Pe.$onRenderResolve$ && We["s-p"] && We["s-p"].push(new Promise(Et => Pe.$onRenderResolve$ = Et))
            }, gn = (Pe, We) => {
                if (Pe.$flags$ |= 16, !(4 & Pe.$flags$)) return rn(Pe, Pe.$ancestorComponent$), Br(() => Hn(Pe, We));
                Pe.$flags$ |= 512
            }, Hn = (Pe, We) => {
                const Ot = Pe.$lazyInstance$;
                let Ke;
                return We && (Pe.$flags$ |= 256, Pe.$queuedListeners$ && (Pe.$queuedListeners$.map(([at, Ct]) => Wn(Ot, at, Ct)), Pe.$queuedListeners$ = null), Ke = Wn(Ot, "componentWillLoad")), Ke = Xn(Ke, () => Wn(Ot, "componentWillRender")), Xn(Ke, () => jn(Pe, Ot, We))
            }, jn = function () {
                var Pe = (0, r.Z)(function* (We, Et, Ot) {
                    const Ke = We.$hostElement$, Ct = Ke["s-rc"];
                    Ot && (Pe => {
                        const We = Pe.$cmpMeta$, Et = Pe.$hostElement$, Ot = We.$flags$,
                            at = w(Et.shadowRoot ? Et.shadowRoot : Et.getRootNode(), We, Pe.$modeName$);
                        10 & Ot && (Et["s-sc"] = at, Et.classList.add(at + "-h"), 2 & Ot && Et.classList.add(at + "-s"))
                    })(We);
                    fr(We, Et), Ct && (Ct.map(qt => qt()), Ke["s-rc"] = void 0);
                    {
                        const qt = Ke["s-p"], Zt = () => qn(We);
                        0 === qt.length ? Zt() : (Promise.all(qt).then(Zt), We.$flags$ |= 4, qt.length = 0)
                    }
                });
                return function (Et, Ot, Ke) {
                    return Pe.apply(this, arguments)
                }
            }(), fr = (Pe, We, Et) => {
                try {
                    We = We.render && We.render(), Pe.$flags$ &= -17, Pe.$flags$ |= 2, ((Pe, We) => {
                        const Et = Pe.$hostElement$, Ot = Pe.$cmpMeta$, Ke = Pe.$vnode$ || _t(null, null),
                            at = (Pe => Pe && Pe.$tag$ === Pt)(We) ? We : Mt(null, null, We);
                        if (j = Et.tagName, Ot.$attrsToReflect$ && (at.$attrs$ = at.$attrs$ || {}, Ot.$attrsToReflect$.map(([Ct, Kt]) => at.$attrs$[Kt] = Et[Ct])), at.$tag$ = null, at.$flags$ |= 4, Pe.$vnode$ = at, at.$elm$ = Ke.$elm$ = Et.shadowRoot || Et, ie = Et["s-sc"], te = Et["s-cr"], W = 0 != (1 & Ot.$flags$), Q = !1, Be(Ke, at), M.$flags$ |= 1, Ne) {
                            Ft(at.$elm$);
                            let Ct, Kt, qt, Zt, hn, Bn, Zn = 0;
                            for (; Zn < Dt.length; Zn++) Ct = Dt[Zn], Kt = Ct.$nodeToRelocate$, Kt["s-ol"] || (qt = X.createTextNode(""), qt["s-nr"] = Kt, Kt.parentNode.insertBefore(Kt["s-ol"] = qt, Kt));
                            for (Zn = 0; Zn < Dt.length; Zn++) if (Ct = Dt[Zn], Kt = Ct.$nodeToRelocate$, Ct.$slotRefNode$) {
                                for (Zt = Ct.$slotRefNode$.parentNode, hn = Ct.$slotRefNode$.nextSibling, qt = Kt["s-ol"]; qt = qt.previousSibling;) if (Bn = qt["s-nr"], Bn && Bn["s-sn"] === Kt["s-sn"] && Zt === Bn.parentNode && (Bn = Bn.nextSibling, !Bn || !Bn["s-nr"])) {
                                    hn = Bn;
                                    break
                                }
                                (!hn && Zt !== Kt.parentNode || Kt.nextSibling !== hn) && Kt !== hn && (!Kt["s-hn"] && Kt["s-ol"] && (Kt["s-hn"] = Kt["s-ol"].parentNode.nodeName), Zt.insertBefore(Kt, hn))
                            } else 1 === Kt.nodeType && (Kt.hidden = !0)
                        }
                        Q && tt(at.$elm$), M.$flags$ &= -2, Dt.length = 0
                    })(Pe, We)
                } catch (Ot) {
                    Un(Ot, Pe.$hostElement$)
                }
                return null
            }, qn = Pe => {
                const Et = Pe.$hostElement$, Ke = Pe.$lazyInstance$, at = Pe.$ancestorComponent$;
                Wn(Ke, "componentDidRender"), 64 & Pe.$flags$ ? Wn(Ke, "componentDidUpdate") : (Pe.$flags$ |= 64, Dr(Et), Wn(Ke, "componentDidLoad"), Pe.$onReadyResolve$(Et), at || Qn()), Pe.$onInstanceResolve$(Et), Pe.$onRenderResolve$ && (Pe.$onRenderResolve$(), Pe.$onRenderResolve$ = void 0), 512 & Pe.$flags$ && Vn(() => gn(Pe, !1)), Pe.$flags$ &= -517
            }, Yn = Pe => {
                {
                    const We = an(Pe), Et = We.$hostElement$.isConnected;
                    return Et && 2 == (18 & We.$flags$) && gn(We, !1), Et
                }
            }, Qn = Pe => {
                Dr(X.documentElement), Vn(() => fn(ae, "appload", {detail: {namespace: "ionic"}}))
            }, Wn = (Pe, We, Et) => {
                if (Pe && Pe[We]) try {
                    return Pe[We](Et)
                } catch (Ot) {
                    Un(Ot)
                }
            }, Xn = (Pe, We) => Pe && Pe.then ? Pe.then(We) : We(), Dr = Pe => Pe.classList.add("hydrated"),
            vt = (Pe, We, Et, Ot, Ke, at, Ct) => {
                let Kt, qt, Zt, hn;
                if (1 === at.nodeType) {
                    for (Kt = at.getAttribute("c-id"), Kt && (qt = Kt.split("."), (qt[0] === Ct || "0" === qt[0]) && (Zt = {
                        $flags$: 0,
                        $hostId$: qt[0],
                        $nodeId$: qt[1],
                        $depth$: qt[2],
                        $index$: qt[3],
                        $tag$: at.tagName.toLowerCase(),
                        $elm$: at,
                        $attrs$: null,
                        $children$: null,
                        $key$: null,
                        $name$: null,
                        $text$: null
                    }, We.push(Zt), at.removeAttribute("c-id"), Pe.$children$ || (Pe.$children$ = []), Pe.$children$[Zt.$index$] = Zt, Pe = Zt, Ot && "0" === Zt.$depth$ && (Ot[Zt.$index$] = Zt.$elm$))), hn = at.childNodes.length - 1; hn >= 0; hn--) vt(Pe, We, Et, Ot, Ke, at.childNodes[hn], Ct);
                    if (at.shadowRoot) for (hn = at.shadowRoot.childNodes.length - 1; hn >= 0; hn--) vt(Pe, We, Et, Ot, Ke, at.shadowRoot.childNodes[hn], Ct)
                } else if (8 === at.nodeType) qt = at.nodeValue.split("."), (qt[1] === Ct || "0" === qt[1]) && (Kt = qt[0], Zt = {
                    $flags$: 0,
                    $hostId$: qt[1],
                    $nodeId$: qt[2],
                    $depth$: qt[3],
                    $index$: qt[4],
                    $elm$: at,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $tag$: null,
                    $text$: null
                }, "t" === Kt ? (Zt.$elm$ = at.nextSibling, Zt.$elm$ && 3 === Zt.$elm$.nodeType && (Zt.$text$ = Zt.$elm$.textContent, We.push(Zt), at.remove(), Pe.$children$ || (Pe.$children$ = []), Pe.$children$[Zt.$index$] = Zt, Ot && "0" === Zt.$depth$ && (Ot[Zt.$index$] = Zt.$elm$))) : Zt.$hostId$ === Ct && ("s" === Kt ? (Zt.$tag$ = "slot", at["s-sn"] = qt[5] ? Zt.$name$ = qt[5] : "", at["s-sr"] = !0, Ot && (Zt.$elm$ = X.createElement(Zt.$tag$), Zt.$name$ && Zt.$elm$.setAttribute("name", Zt.$name$), at.parentNode.insertBefore(Zt.$elm$, at), at.remove(), "0" === Zt.$depth$ && (Ot[Zt.$index$] = Zt.$elm$)), Et.push(Zt), Pe.$children$ || (Pe.$children$ = []), Pe.$children$[Zt.$index$] = Zt) : "r" === Kt && (Ot ? at.remove() : (Ke["s-cr"] = at, at["s-cn"] = !0)))); else if (Pe && "style" === Pe.$tag$) {
                    const Bn = _t(null, at.textContent);
                    Bn.$elm$ = at, Bn.$index$ = "0", Pe.$children$ = [Bn]
                }
            }, Qe = (Pe, We) => {
                if (1 === Pe.nodeType) {
                    let Et = 0;
                    for (; Et < Pe.childNodes.length; Et++) Qe(Pe.childNodes[Et], We);
                    if (Pe.shadowRoot) for (Et = 0; Et < Pe.shadowRoot.childNodes.length; Et++) Qe(Pe.shadowRoot.childNodes[Et], We)
                } else if (8 === Pe.nodeType) {
                    const Et = Pe.nodeValue.split(".");
                    "o" === Et[0] && (We.set(Et[1] + "." + Et[2], Pe), Pe.nodeValue = "", Pe["s-en"] = Et[3])
                }
            }, dt = (Pe, We, Et) => {
                if (We.$members$) {
                    Pe.watchers && (We.$watchers$ = Pe.watchers);
                    const Ot = Object.entries(We.$members$), Ke = Pe.prototype;
                    if (Ot.map(([at, [Ct]]) => {
                        31 & Ct || 2 & Et && 32 & Ct ? Object.defineProperty(Ke, at, {
                            get() {
                                return ((Pe, We) => an(this).$instanceValues$.get(We))(0, at)
                            }, set(Kt) {
                                ((Pe, We, Et, Ot) => {
                                    const Ke = an(Pe), at = Ke.$hostElement$, Ct = Ke.$instanceValues$.get(We),
                                        Kt = Ke.$flags$, qt = Ke.$lazyInstance$;
                                    Et = ((Pe, We) => null == Pe || Ye(Pe) ? Pe : 4 & We ? "false" !== Pe && ("" === Pe || !!Pe) : 2 & We ? parseFloat(Pe) : 1 & We ? String(Pe) : Pe)(Et, Ot.$members$[We][0]);
                                    const Zt = Number.isNaN(Ct) && Number.isNaN(Et);
                                    if ((!(8 & Kt) || void 0 === Ct) && Et !== Ct && !Zt && (Ke.$instanceValues$.set(We, Et), qt)) {
                                        if (Ot.$watchers$ && 128 & Kt) {
                                            const Bn = Ot.$watchers$[We];
                                            Bn && Bn.map(Zn => {
                                                try {
                                                    qt[Zn](Et, Ct, We)
                                                } catch (lr) {
                                                    Un(lr, at)
                                                }
                                            })
                                        }
                                        2 == (18 & Kt) && gn(Ke, !1)
                                    }
                                })(this, at, Kt, We)
                            }, configurable: !0, enumerable: !0
                        }) : 1 & Et && 64 & Ct && Object.defineProperty(Ke, at, {
                            value(...Kt) {
                                const qt = an(this);
                                return qt.$onInstancePromise$.then(() => qt.$lazyInstance$[at](...Kt))
                            }
                        })
                    }), 1 & Et) {
                        const at = new Map;
                        Ke.attributeChangedCallback = function (Ct, Kt, qt) {
                            M.jmp(() => {
                                const Zt = at.get(Ct);
                                if (this.hasOwnProperty(Zt)) qt = this[Zt], delete this[Zt]; else if (Ke.hasOwnProperty(Zt) && "number" == typeof this[Zt] && this[Zt] == qt) return;
                                this[Zt] = (null !== qt || "boolean" != typeof this[Zt]) && qt
                            })
                        }, Pe.observedAttributes = Ot.filter(([Ct, Kt]) => 15 & Kt[0]).map(([Ct, Kt]) => {
                            const qt = Kt[1] || Ct;
                            return at.set(qt, Ct), 512 & Kt[0] && We.$attrsToReflect$.push([Ct, qt]), qt
                        })
                    }
                }
                return Pe
            }, wt = function () {
                var Pe = (0, r.Z)(function* (We, Et, Ot, Ke, at) {
                    if (0 == (32 & Et.$flags$)) {
                        {
                            if (Et.$flags$ |= 32, (at = _n(Ot)).then) {
                                const Zt = () => {
                                };
                                at = yield at, Zt()
                            }
                            at.isProxied || (Ot.$watchers$ = at.watchers, dt(at, Ot, 2), at.isProxied = !0);
                            const qt = () => {
                            };
                            Et.$flags$ |= 8;
                            try {
                                new at(Et)
                            } catch (Zt) {
                                Un(Zt)
                            }
                            Et.$flags$ &= -9, Et.$flags$ |= 128, qt(), Ut(Et.$lazyInstance$)
                        }
                        if (at.style) {
                            let qt = at.style;
                            "string" != typeof qt && (qt = qt[Et.$modeName$ = (Pe => nr.map(We => We(Pe)).find(We => !!We))(We)]);
                            const Zt = B(Ot, Et.$modeName$);
                            if (!tr.has(Zt)) {
                                const hn = () => {
                                };
                                v(Zt, qt, !!(1 & Ot.$flags$)), hn()
                            }
                        }
                    }
                    const Ct = Et.$ancestorComponent$, Kt = () => gn(Et, !0);
                    Ct && Ct["s-rc"] ? Ct["s-rc"].push(Kt) : Kt()
                });
                return function (Et, Ot, Ke, at, Ct) {
                    return Pe.apply(this, arguments)
                }
            }(), Ut = Pe => {
                Wn(Pe, "connectedCallback")
            }, sn = Pe => {
                const We = Pe["s-cr"] = X.createComment("");
                We["s-cn"] = !0, Pe.insertBefore(We, Pe.firstChild)
            }, Pn = (Pe, We = {}) => {
                const Ot = [], Ke = We.exclude || [], at = ae.customElements, Ct = X.head,
                    Kt = Ct.querySelector("meta[charset]"), qt = X.createElement("style"), Zt = [],
                    hn = X.querySelectorAll(`[${Xe}]`);
                let Bn, Zn = !0, lr = 0;
                for (Object.assign(M, We), M.$resourcesUrl$ = new URL(We.resourcesUrl || "./", X.baseURI).href, M.$flags$ |= 2; lr < hn.length; lr++) v(hn[lr].getAttribute(Xe), O(hn[lr].innerHTML), !0);
                Pe.map(xr => {
                    xr[1].map($r => {
                        const Nr = {$flags$: $r[0], $tagName$: $r[1], $members$: $r[2], $listeners$: $r[3]};
                        Nr.$members$ = $r[2], Nr.$listeners$ = $r[3], Nr.$attrsToReflect$ = [], Nr.$watchers$ = {};
                        const li = Nr.$tagName$, Ci = class extends HTMLElement {
                            constructor(hi) {
                                super(hi), Sn(hi = this, Nr), 1 & Nr.$flags$ && hi.attachShadow({
                                    mode: "open",
                                    delegatesFocus: !!(16 & Nr.$flags$)
                                })
                            }

                            connectedCallback() {
                                Bn && (clearTimeout(Bn), Bn = null), Zn ? Zt.push(this) : M.jmp(() => (Pe => {
                                    if (0 == (1 & M.$flags$)) {
                                        const We = an(Pe), Et = We.$cmpMeta$, Ot = () => {
                                        };
                                        if (1 & We.$flags$) Ie(Pe, We, Et.$listeners$), Ut(We.$lazyInstance$); else {
                                            let Ke;
                                            if (We.$flags$ |= 1, Ke = Pe.getAttribute(rt), Ke) {
                                                if (1 & Et.$flags$) {
                                                    const at = w(Pe.shadowRoot, Et, Pe.getAttribute("s-mode"));
                                                    Pe.classList.remove(at + "-h", at + "-s")
                                                }
                                                ((Pe, We, Et, Ot) => {
                                                    const at = Pe.shadowRoot, Ct = [], qt = at ? [] : null,
                                                        Zt = Ot.$vnode$ = _t(We, null);
                                                    M.$orgLocNodes$ || Qe(X.body, M.$orgLocNodes$ = new Map), Pe[rt] = Et, Pe.removeAttribute(rt), vt(Zt, Ct, [], qt, Pe, Pe, Et), Ct.map(hn => {
                                                        const Bn = hn.$hostId$ + "." + hn.$nodeId$,
                                                            Zn = M.$orgLocNodes$.get(Bn), lr = hn.$elm$;
                                                        Zn && "" === Zn["s-en"] && Zn.parentNode.insertBefore(lr, Zn.nextSibling), at || (lr["s-hn"] = We, Zn && (lr["s-ol"] = Zn, lr["s-ol"]["s-nr"] = lr)), M.$orgLocNodes$.delete(Bn)
                                                    }), at && qt.map(hn => {
                                                        hn && at.appendChild(hn)
                                                    })
                                                })(Pe, Et.$tagName$, Ke, We)
                                            }
                                            Ke || 12 & Et.$flags$ && sn(Pe);
                                            {
                                                let at = Pe;
                                                for (; at = at.parentNode || at.host;) if (1 === at.nodeType && at.hasAttribute("s-id") && at["s-p"] || at["s-p"]) {
                                                    rn(We, We.$ancestorComponent$ = at);
                                                    break
                                                }
                                            }
                                            Et.$members$ && Object.entries(Et.$members$).map(([at, [Ct]]) => {
                                                if (31 & Ct && Pe.hasOwnProperty(at)) {
                                                    const Kt = Pe[at];
                                                    delete Pe[at], Pe[at] = Kt
                                                }
                                            }), Vn(() => wt(Pe, We, Et))
                                        }
                                        Ot()
                                    }
                                })(this))
                            }

                            disconnectedCallback() {
                                M.jmp(() => (Pe => {
                                    if (0 == (1 & M.$flags$)) {
                                        const We = an(this), Et = We.$lazyInstance$;
                                        We.$rmListeners$ && (We.$rmListeners$.map(Ot => Ot()), We.$rmListeners$ = void 0), Wn(Et, "disconnectedCallback")
                                    }
                                })())
                            }

                            componentOnReady() {
                                return an(this).$onReadyPromise$
                            }
                        };
                        Nr.$lazyBundleId$ = xr[0], !Ke.includes(li) && !at.get(li) && (Ot.push(li), at.define(li, dt(Ci, Nr, 1)))
                    })
                }), qt.innerHTML = Ot + "{visibility:hidden}.hydrated{visibility:inherit}", qt.setAttribute("data-styles", ""), Ct.insertBefore(qt, Kt ? Kt.nextSibling : Ct.firstChild), Zn = !1, Zt.length ? Zt.map(xr => xr.connectedCallback()) : M.jmp(() => Bn = setTimeout(Qn, 30))
            }, mn = Pe => {
                const We = new URL(Pe, M.$resourcesUrl$);
                return We.origin !== ae.location.origin ? We.href : We.pathname
            }, Mn = new WeakMap, an = Pe => Mn.get(Pe), En = (Pe, We) => Mn.set(We.$lazyInstance$ = Pe, We),
            Sn = (Pe, We) => {
                const Et = {$flags$: 0, $hostElement$: Pe, $cmpMeta$: We, $instanceValues$: new Map};
                return Et.$onInstancePromise$ = new Promise(Ot => Et.$onInstanceResolve$ = Ot), Et.$onReadyPromise$ = new Promise(Ot => Et.$onReadyResolve$ = Ot), Pe["s-p"] = [], Pe["s-rc"] = [], Ie(Pe, Et, We.$listeners$), Mn.set(Pe, Et)
            }, ar = (Pe, We) => We in Pe, Un = (Pe, We) => (0, console.error)(Pe, We), nn = new Map,
            _n = (Pe, We, Et) => {
                const Ot = Pe.$tagName$.replace(/-/g, "_"), Ke = Pe.$lazyBundleId$, at = nn.get(Ke);
                return at ? at[Ot] : R(863)(`./${Ke}.entry.js`).then(Ct => (nn.set(Ke, Ct), Ct[Ot]), Un)
            }, tr = new Map, nr = [], Er = [], gr = [], Ir = (Pe, We) => Et => {
                Pe.push(Et), me || (me = !0, We && 4 & M.$flags$ ? Vn(br) : M.raf(br))
            }, rr = Pe => {
                for (let We = 0; We < Pe.length; We++) try {
                    Pe[We](performance.now())
                } catch (Et) {
                    Un(Et)
                }
                Pe.length = 0
            }, br = () => {
                rr(Er), rr(gr), (me = Er.length > 0) && M.raf(br)
            }, Vn = Pe => oe().then(Pe), $n = Ir(Er, !1), Br = Ir(gr, !0),
            _r = {isDev: !1, isBrowser: !0, isServer: !1, isTesting: !1}
    }, 97: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {m: () => ae});
        var r = R(5861), D = R(7593), ie = R(3756), te = R(5729), j = R(9442);
        const W = X => (0, j.c)().duration(X ? 400 : 300), Q = X => {
            let M, H;
            const F = X.width + 8, oe = (0, j.c)(), ge = (0, j.c)();
            X.isEndSide ? (M = F + "px", H = "0px") : (M = -F + "px", H = "0px"), oe.addElement(X.menuInnerEl).fromTo("transform", `translateX(${M})`, `translateX(${H})`);
            const he = "ios" === (0, te.b)(X), xe = he ? .2 : .25;
            return ge.addElement(X.backdropEl).fromTo("opacity", .01, xe), W(he).addAnimation([oe, ge])
        }, Ne = X => {
            let M, H;
            const F = (0, te.b)(X), oe = X.width;
            X.isEndSide ? (M = -oe + "px", H = oe + "px") : (M = oe + "px", H = -oe + "px");
            const ge = (0, j.c)().addElement(X.menuInnerEl).fromTo("transform", `translateX(${H})`, "translateX(0px)"),
                Ie = (0, j.c)().addElement(X.contentEl).fromTo("transform", "translateX(0px)", `translateX(${M})`),
                he = (0, j.c)().addElement(X.backdropEl).fromTo("opacity", .01, .32);
            return W("ios" === F).addAnimation([ge, Ie, he])
        }, ve = X => {
            const M = (0, te.b)(X), H = X.width * (X.isEndSide ? -1 : 1) + "px",
                F = (0, j.c)().addElement(X.contentEl).fromTo("transform", "translateX(0px)", `translateX(${H})`);
            return W("ios" === M).addAnimation(F)
        }, ae = (() => {
            const X = new Map, M = [], H = function () {
                    var P = (0, r.Z)(function* (B) {
                        const O = yield Ue(B);
                        return !!O && O.open()
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), F = function () {
                    var P = (0, r.Z)(function* (B) {
                        const O = yield void 0 !== B ? Ue(B) : it();
                        return void 0 !== O && O.close()
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), oe = function () {
                    var P = (0, r.Z)(function* (B) {
                        const O = yield Ue(B);
                        return !!O && O.toggle()
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), ge = function () {
                    var P = (0, r.Z)(function* (B, O) {
                        const E = yield Ue(O);
                        return E && (E.disabled = !B), E
                    });
                    return function (O, E) {
                        return P.apply(this, arguments)
                    }
                }(), Ie = function () {
                    var P = (0, r.Z)(function* (B, O) {
                        const E = yield Ue(O);
                        return E && (E.swipeGesture = B), E
                    });
                    return function (O, E) {
                        return P.apply(this, arguments)
                    }
                }(), he = function () {
                    var P = (0, r.Z)(function* (B) {
                        if (null != B) {
                            const O = yield Ue(B);
                            return void 0 !== O && O.isOpen()
                        }
                        return void 0 !== (yield it())
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), xe = function () {
                    var P = (0, r.Z)(function* (B) {
                        const O = yield Ue(B);
                        return !!O && !O.disabled
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), Ue = function () {
                    var P = (0, r.Z)(function* (B) {
                        return yield w(), "start" === B || "end" === B ? v(Z => Z.side === B && !Z.disabled) || v(Z => Z.side === B) : null != B ? v(E => E.menuId === B) : v(E => !E.disabled) || (M.length > 0 ? M[0].el : void 0)
                    });
                    return function (O) {
                        return P.apply(this, arguments)
                    }
                }(), it = function () {
                    var P = (0, r.Z)(function* () {
                        return yield w(), l()
                    });
                    return function () {
                        return P.apply(this, arguments)
                    }
                }(), yt = function () {
                    var P = (0, r.Z)(function* () {
                        return yield w(), f()
                    });
                    return function () {
                        return P.apply(this, arguments)
                    }
                }(), Ce = function () {
                    var P = (0, r.Z)(function* () {
                        return yield w(), g()
                    });
                    return function () {
                        return P.apply(this, arguments)
                    }
                }(), $e = (P, B) => {
                    X.set(P, B)
                }, Ee = P => {
                    const B = P.side;
                    M.filter(O => O.side === B && O !== P).forEach(O => O.disabled = !0)
                }, ce = function () {
                    var P = (0, r.Z)(function* (B, O, E) {
                        if (g()) return !1;
                        if (O) {
                            const Z = yield it();
                            Z && B.el !== Z && (yield Z.setOpen(!1, !1))
                        }
                        return B._setOpen(O, E)
                    });
                    return function (O, E, Z) {
                        return P.apply(this, arguments)
                    }
                }(), l = () => v(P => P._isOpen), f = () => M.map(P => P.el), g = () => M.some(P => P.isAnimating),
                v = P => {
                    const B = M.find(P);
                    if (void 0 !== B) return B.el
                },
                w = () => Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(P => new Promise(B => (0, ie.c)(P, B))));
            return $e("reveal", ve), $e("push", Ne), $e("overlay", Q), "undefined" != typeof document && document.addEventListener("ionBackButton", P => {
                const B = l();
                B && P.detail.register(D.MENU_BACK_BUTTON_PRIORITY, () => B.close())
            }), {
                registerAnimation: $e,
                get: Ue,
                getMenus: yt,
                getOpen: it,
                isEnabled: xe,
                swipeGesture: Ie,
                isAnimating: Ce,
                isOpen: he,
                enable: ge,
                toggle: oe,
                close: F,
                open: H,
                _getOpenSync: l,
                _createAnimation: (P, B) => {
                    const O = X.get(P);
                    if (!O) throw new Error("animation not registered");
                    return O(B)
                },
                _register: P => {
                    M.indexOf(P) < 0 && (P.disabled || Ee(P), M.push(P))
                },
                _unregister: P => {
                    const B = M.indexOf(P);
                    B > -1 && M.splice(B, 1)
                },
                _setOpen: ce,
                _setActiveMenu: Ee
            }
        })()
    }, 5729: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {a: () => ae, b: () => g, c: () => ie, g: () => me, i: () => v});
        var r = R(7205);

        class D {
            constructor() {
                this.m = new Map
            }

            reset(P) {
                this.m = new Map(Object.entries(P))
            }

            get(P, B) {
                const O = this.m.get(P);
                return void 0 !== O ? O : B
            }

            getBoolean(P, B = !1) {
                const O = this.m.get(P);
                return void 0 === O ? B : "string" == typeof O ? "true" === O : !!O
            }

            getNumber(P, B) {
                const O = parseFloat(this.m.get(P));
                return isNaN(O) ? void 0 !== B ? B : NaN : O
            }

            set(P, B) {
                this.m.set(P, B)
            }
        }

        const ie = new D, ve = "ionic-persist-config", me = w => X(w),
            ae = (w, P) => ("string" == typeof w && (P = w, w = void 0), me(w).includes(P)), X = (w = window) => {
                if (void 0 === w) return [];
                w.Ionic = w.Ionic || {};
                let P = w.Ionic.platforms;
                return null == P && (P = w.Ionic.platforms = M(w), P.forEach(B => w.document.documentElement.classList.add(`plt-${B}`))), P
            }, M = w => {
                const P = ie.get("platform");
                return Object.keys(l).filter(B => {
                    const O = null == P ? void 0 : P[B];
                    return "function" == typeof O ? O(w) : l[B](w)
                })
            }, F = w => !!(ce(w, /iPad/i) || ce(w, /Macintosh/i) && it(w)), Ie = w => ce(w, /android|sink/i),
            it = w => I(w, "(any-pointer:coarse)"), Ce = w => $e(w) || rt(w),
            $e = w => !!(w.cordova || w.phonegap || w.PhoneGap), rt = w => {
                const P = w.Capacitor;
                return !!(null == P ? void 0 : P.isNative)
            }, ce = (w, P) => P.test(w.navigator.userAgent), I = (w, P) => {
                var B;
                return null === (B = w.matchMedia) || void 0 === B ? void 0 : B.call(w, P).matches
            }, l = {
                ipad: F,
                iphone: w => ce(w, /iPhone/i),
                ios: w => ce(w, /iPhone|iPod/i) || F(w),
                android: Ie,
                phablet: w => {
                    const P = w.innerWidth, B = w.innerHeight, O = Math.min(P, B), E = Math.max(P, B);
                    return O > 390 && O < 520 && E > 620 && E < 800
                },
                tablet: w => {
                    const P = w.innerWidth, B = w.innerHeight, O = Math.min(P, B), E = Math.max(P, B);
                    return F(w) || (w => Ie(w) && !ce(w, /mobile/i))(w) || O > 460 && O < 820 && E > 780 && E < 1400
                },
                cordova: $e,
                capacitor: rt,
                electron: w => ce(w, /electron/i),
                pwa: w => {
                    var P;
                    return !(!(null === (P = w.matchMedia) || void 0 === P ? void 0 : P.call(w, "(display-mode: standalone)").matches) && !w.navigator.standalone)
                },
                mobile: it,
                mobileweb: w => it(w) && !Ce(w),
                desktop: w => !it(w),
                hybrid: Ce
            };
        let f;
        const g = w => w && (0, r.g)(w) || f, v = (w = {}) => {
            if ("undefined" == typeof window) return;
            const P = window.document, B = window, O = B.Ionic = B.Ionic || {}, E = {};
            w._ael && (E.ael = w._ael), w._rel && (E.rel = w._rel), w._ce && (E.ce = w._ce), (0, r.s)(E);
            const Z = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (w => {
                try {
                    const P = w.sessionStorage.getItem(ve);
                    return null !== P ? JSON.parse(P) : {}
                } catch (P) {
                    return {}
                }
            })(B)), {persistConfig: !1}), O.config), (w => {
                const P = {};
                return w.location.search.slice(1).split("&").map(B => B.split("=")).map(([B, O]) => [decodeURIComponent(B), decodeURIComponent(O)]).filter(([B]) => ((w, P) => w.substr(0, P.length) === P)(B, "ionic:")).map(([B, O]) => [B.slice("ionic:".length), O]).forEach(([B, O]) => {
                    P[B] = O
                }), P
            })(B)), w);
            ie.reset(Z), ie.getBoolean("persistConfig") && ((w, P) => {
                try {
                    w.sessionStorage.setItem(ve, JSON.stringify(P))
                } catch (B) {
                    return
                }
            })(B, Z), X(B), O.config = ie, O.mode = f = ie.get("mode", P.documentElement.getAttribute("mode") || (ae(B, "ios") ? "ios" : "md")), ie.set("mode", f), P.documentElement.setAttribute("mode", f), P.documentElement.classList.add(f), ie.getBoolean("_testing") && ie.set("animated", !1);
            const ze = q => {
                var Le;
                return null === (Le = q.tagName) || void 0 === Le ? void 0 : Le.startsWith("ION-")
            }, Je = q => ["ios", "md"].includes(q);
            (0, r.a)(q => {
                for (; q;) {
                    const Le = q.mode || q.getAttribute("mode");
                    if (Le) {
                        if (Je(Le)) return Le;
                        ze(q) && console.warn('Invalid ionic mode: "' + Le + '", expected: "ios" or "md"')
                    }
                    q = q.parentElement
                }
                return f
            })
        }
    }, 4181: (Jt, lt, R) => {
        "use strict";
        R.r(lt), R.d(lt, {iosTransitionAnimation: () => X, shadow: () => W});
        var r = R(9442), D = R(9753);
        R(7205);
        const j = M => document.querySelector(`${M}.ion-cloned-element`), W = M => M.shadowRoot || M, Q = M => {
            const H = "ION-TABS" === M.tagName ? M : M.querySelector("ion-tabs"),
                F = "ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large";
            if (null != H) {
                const oe = H.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");
                return null != oe ? oe.querySelector(F) : null
            }
            return M.querySelector(F)
        }, Ne = (M, H) => {
            const F = "ION-TABS" === M.tagName ? M : M.querySelector("ion-tabs");
            let oe = [];
            if (null != F) {
                const ge = F.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");
                null != ge && (oe = ge.querySelectorAll("ion-buttons"))
            } else oe = M.querySelectorAll("ion-buttons");
            for (const ge of oe) {
                const Ie = ge.closest("ion-header"),
                    he = Ie && !Ie.classList.contains("header-collapse-condense-inactive"),
                    xe = ge.querySelector("ion-back-button"), Ue = ge.classList.contains("buttons-collapse"),
                    it = "start" === ge.slot || "" === ge.slot;
                if (null !== xe && it && (Ue && he && H || !Ue)) return xe
            }
            return null
        }, me = (M, H, F, oe, ge, Ie) => {
            const he = H ? `calc(100% - ${Ie.right + 4}px)` : Ie.left - 4 + "px", xe = H ? "7px" : "-7px",
                Ue = H ? "-4px" : "4px", it = H ? "-4px" : "4px", yt = H ? "right" : "left", Ce = H ? "left" : "right",
                Xe = F ? [{
                    offset: 0,
                    opacity: 1,
                    transform: `translate3d(${Ue}, ${Ie.top - 46}px, 0) scale(1)`
                }, {offset: .6, opacity: 0}, {
                    offset: 1,
                    opacity: 0,
                    transform: `translate3d(${xe}, ${ge.top - 40}px, 0) scale(2.1)`
                }] : [{
                    offset: 0,
                    opacity: 0,
                    transform: `translate3d(${xe}, ${ge.top - 40}px, 0) scale(2.1)`
                }, {offset: 1, opacity: 1, transform: `translate3d(${Ue}, ${Ie.top - 46}px, 0) scale(1)`}], I = F ? [{
                    offset: 0,
                    opacity: 1,
                    transform: `translate3d(${it}, ${Ie.top - 46}px, 0) scale(1)`
                }, {offset: .2, opacity: 0, transform: `translate3d(${it}, ${Ie.top - 41}px, 0) scale(0.6)`}, {
                    offset: 1,
                    opacity: 0,
                    transform: `translate3d(${it}, ${Ie.top - 41}px, 0) scale(0.6)`
                }] : [{offset: 0, opacity: 0, transform: `translate3d(${it}, ${Ie.top - 41}px, 0) scale(0.6)`}, {
                    offset: 1,
                    opacity: 1,
                    transform: `translate3d(${it}, ${Ie.top - 46}px, 0) scale(1)`
                }], l = (0, r.c)(), f = (0, r.c)(), g = j("ion-back-button"), v = W(g).querySelector(".button-text"),
                w = W(g).querySelector("ion-icon");
            g.text = oe.text, g.mode = oe.mode, g.icon = oe.icon, g.color = oe.color, g.disabled = oe.disabled, g.style.setProperty("display", "block"), g.style.setProperty("position", "fixed"), f.addElement(w), l.addElement(v), l.beforeStyles({"transform-origin": `${yt} center`}).beforeAddWrite(() => {
                oe.style.setProperty("display", "none"), g.style.setProperty(yt, he)
            }).afterAddWrite(() => {
                oe.style.setProperty("display", ""), g.style.setProperty("display", "none"), g.style.removeProperty(yt)
            }).keyframes(Xe), f.beforeStyles({"transform-origin": `${Ce} center`}).keyframes(I), M.addAnimation([l, f])
        }, ae = (M, H, F, oe, ge, Ie) => {
            const he = H ? `calc(100% - ${ge.right}px)` : `${ge.left}px`, xe = H ? "-18px" : "18px",
                Ue = H ? "right" : "left", Ce = F ? [{
                    offset: 0,
                    opacity: 0,
                    transform: `translate3d(${xe}, ${Ie.top - 4}px, 0) scale(0.49)`
                }, {offset: .1, opacity: 0}, {
                    offset: 1,
                    opacity: 1,
                    transform: `translate3d(0, ${ge.top - 2}px, 0) scale(1)`
                }] : [{offset: 0, opacity: .99, transform: `translate3d(0, ${ge.top - 2}px, 0) scale(1)`}, {
                    offset: .6,
                    opacity: 0
                }, {offset: 1, opacity: 0, transform: `translate3d(${xe}, ${Ie.top - 4}px, 0) scale(0.5)`}],
                $e = j("ion-title"), rt = (0, r.c)();
            $e.innerText = oe.innerText, $e.size = oe.size, $e.color = oe.color, rt.addElement($e), rt.beforeStyles({
                "transform-origin": `${Ue} center`,
                height: "46px",
                display: "",
                position: "relative",
                [Ue]: he
            }).beforeAddWrite(() => {
                oe.style.setProperty("display", "none")
            }).afterAddWrite(() => {
                oe.style.setProperty("display", ""), $e.style.setProperty("display", "none")
            }).keyframes(Ce), M.addAnimation(rt)
        }, X = (M, H) => {
            try {
                const F = "cubic-bezier(0.32,0.72,0,1)", oe = "opacity", ge = "transform", Ie = "0%",
                    xe = "rtl" === M.ownerDocument.dir, Ue = xe ? "-99.5%" : "99.5%", it = xe ? "33%" : "-33%",
                    yt = H.enteringEl, Ce = H.leavingEl, $e = "back" === H.direction,
                    rt = yt.querySelector(":scope > ion-content"),
                    Xe = yt.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *"),
                    Ee = yt.querySelectorAll(":scope > ion-header > ion-toolbar"), ce = (0, r.c)(), I = (0, r.c)();
                if (ce.addElement(yt).duration(H.duration || 540).easing(H.easing || F).fill("both").beforeRemoveClass("ion-page-invisible"), Ce && M) {
                    const v = (0, r.c)();
                    v.addElement(M), ce.addAnimation(v)
                }
                if (rt || 0 !== Ee.length || 0 !== Xe.length ? (I.addElement(rt), I.addElement(Xe)) : I.addElement(yt.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs")), ce.addAnimation(I), $e ? I.beforeClearStyles([oe]).fromTo("transform", `translateX(${it})`, `translateX(${Ie})`).fromTo(oe, .8, 1) : I.beforeClearStyles([oe]).fromTo("transform", `translateX(${Ue})`, `translateX(${Ie})`), rt) {
                    const v = W(rt).querySelector(".transition-effect");
                    if (v) {
                        const w = v.querySelector(".transition-cover"), P = v.querySelector(".transition-shadow"),
                            B = (0, r.c)(), O = (0, r.c)(), E = (0, r.c)();
                        B.addElement(v).beforeStyles({opacity: "1", display: "block"}).afterStyles({
                            opacity: "",
                            display: ""
                        }), O.addElement(w).beforeClearStyles([oe]).fromTo(oe, 0, .1), E.addElement(P).beforeClearStyles([oe]).fromTo(oe, .03, .7), B.addAnimation([O, E]), I.addAnimation([B])
                    }
                }
                const l = yt.querySelector("ion-header.header-collapse-condense"), {
                    forward: f,
                    backward: g
                } = ((M, H, F, oe, ge) => {
                    const Ie = Ne(oe, F), he = Q(ge), xe = Q(oe), Ue = Ne(ge, F), it = null !== Ie && null !== he && !F,
                        yt = null !== xe && null !== Ue && F;
                    if (it) {
                        const Ce = he.getBoundingClientRect(), $e = Ie.getBoundingClientRect();
                        ae(M, H, F, he, Ce, $e), me(M, H, F, Ie, Ce, $e)
                    } else if (yt) {
                        const Ce = xe.getBoundingClientRect(), $e = Ue.getBoundingClientRect();
                        ae(M, H, F, xe, Ce, $e), me(M, H, F, Ue, Ce, $e)
                    }
                    return {forward: it, backward: yt}
                })(ce, xe, $e, yt, Ce);
                if (Ee.forEach(v => {
                    const w = (0, r.c)();
                    w.addElement(v), ce.addAnimation(w);
                    const P = (0, r.c)();
                    P.addElement(v.querySelector("ion-title"));
                    const B = (0, r.c)(), O = Array.from(v.querySelectorAll("ion-buttons,[menuToggle]")),
                        E = v.closest("ion-header"),
                        Z = null == E ? void 0 : E.classList.contains("header-collapse-condense-inactive");
                    let ze;
                    ze = O.filter($e ? Ye => {
                        const Mt = Ye.classList.contains("buttons-collapse");
                        return Mt && !Z || !Mt
                    } : Ye => !Ye.classList.contains("buttons-collapse")), B.addElement(ze);
                    const Je = (0, r.c)();
                    Je.addElement(v.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"));
                    const q = (0, r.c)();
                    q.addElement(W(v).querySelector(".toolbar-background"));
                    const Le = (0, r.c)(), ut = v.querySelector("ion-back-button");
                    if (ut && Le.addElement(ut), w.addAnimation([P, B, Je, q, Le]), B.fromTo(oe, .01, 1), Je.fromTo(oe, .01, 1), $e) Z || P.fromTo("transform", `translateX(${it})`, `translateX(${Ie})`).fromTo(oe, .01, 1), Je.fromTo("transform", `translateX(${it})`, `translateX(${Ie})`), Le.fromTo(oe, .01, 1); else if (l || P.fromTo("transform", `translateX(${Ue})`, `translateX(${Ie})`).fromTo(oe, .01, 1), Je.fromTo("transform", `translateX(${Ue})`, `translateX(${Ie})`), q.beforeClearStyles([oe, "transform"]), (null == E ? void 0 : E.translucent) ? q.fromTo("transform", xe ? "translateX(-100%)" : "translateX(100%)", "translateX(0px)") : q.fromTo(oe, .01, "var(--opacity)"), f || Le.fromTo(oe, .01, 1), ut && !f) {
                        const Mt = (0, r.c)();
                        Mt.addElement(W(ut).querySelector(".button-text")).fromTo("transform", xe ? "translateX(-100px)" : "translateX(100px)", "translateX(0px)"), w.addAnimation(Mt)
                    }
                }), Ce) {
                    const v = (0, r.c)(), w = Ce.querySelector(":scope > ion-content"),
                        P = Ce.querySelectorAll(":scope > ion-header > ion-toolbar"),
                        B = Ce.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");
                    if (w || 0 !== P.length || 0 !== B.length ? (v.addElement(w), v.addElement(B)) : v.addElement(Ce.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs")), ce.addAnimation(v), $e) {
                        v.beforeClearStyles([oe]).fromTo("transform", `translateX(${Ie})`, xe ? "translateX(-100%)" : "translateX(100%)");
                        const O = (0, D.g)(Ce);
                        ce.afterAddWrite(() => {
                            "normal" === ce.getDirection() && O.style.setProperty("display", "none")
                        })
                    } else v.fromTo("transform", `translateX(${Ie})`, `translateX(${it})`).fromTo(oe, 1, .8);
                    if (w) {
                        const O = W(w).querySelector(".transition-effect");
                        if (O) {
                            const E = O.querySelector(".transition-cover"), Z = O.querySelector(".transition-shadow"),
                                ze = (0, r.c)(), Je = (0, r.c)(), q = (0, r.c)();
                            ze.addElement(O).beforeStyles({opacity: "1", display: "block"}).afterStyles({
                                opacity: "",
                                display: ""
                            }), Je.addElement(E).beforeClearStyles([oe]).fromTo(oe, .1, 0), q.addElement(Z).beforeClearStyles([oe]).fromTo(oe, .7, .03), ze.addAnimation([Je, q]), v.addAnimation([ze])
                        }
                    }
                    P.forEach(O => {
                        const E = (0, r.c)();
                        E.addElement(O);
                        const Z = (0, r.c)();
                        Z.addElement(O.querySelector("ion-title"));
                        const ze = (0, r.c)(), Je = O.querySelectorAll("ion-buttons,[menuToggle]"),
                            q = O.closest("ion-header"),
                            Le = null == q ? void 0 : q.classList.contains("header-collapse-condense-inactive"),
                            ut = Array.from(Je).filter(yn => {
                                const Xt = yn.classList.contains("buttons-collapse");
                                return Xt && !Le || !Xt
                            });
                        ze.addElement(ut);
                        const Ye = (0, r.c)(),
                            Mt = O.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])");
                        Mt.length > 0 && Ye.addElement(Mt);
                        const _t = (0, r.c)();
                        _t.addElement(W(O).querySelector(".toolbar-background"));
                        const Pt = (0, r.c)(), Gt = O.querySelector("ion-back-button");
                        if (Gt && Pt.addElement(Gt), E.addAnimation([Z, ze, Ye, Pt, _t]), ce.addAnimation(E), Pt.fromTo(oe, .99, 0), ze.fromTo(oe, .99, 0), Ye.fromTo(oe, .99, 0), $e) {
                            if (Le || Z.fromTo("transform", `translateX(${Ie})`, xe ? "translateX(-100%)" : "translateX(100%)").fromTo(oe, .99, 0), Ye.fromTo("transform", `translateX(${Ie})`, xe ? "translateX(-100%)" : "translateX(100%)"), _t.beforeClearStyles([oe, "transform"]), (null == q ? void 0 : q.translucent) ? _t.fromTo("transform", "translateX(0px)", xe ? "translateX(-100%)" : "translateX(100%)") : _t.fromTo(oe, "var(--opacity)", 0), Gt && !g) {
                                const Xt = (0, r.c)();
                                Xt.addElement(W(Gt).querySelector(".button-text")).fromTo("transform", `translateX(${Ie})`, `translateX(${(xe ? -124 : 124) + "px"})`), E.addAnimation(Xt)
                            }
                        } else Le || Z.fromTo("transform", `translateX(${Ie})`, `translateX(${it})`).fromTo(oe, .99, 0).afterClearStyles([ge, oe]), Ye.fromTo("transform", `translateX(${Ie})`, `translateX(${it})`).afterClearStyles([ge, oe]), Pt.afterClearStyles([oe]), Z.afterClearStyles([oe]), ze.afterClearStyles([oe])
                    })
                }
                return ce
            } catch (F) {
                throw F
            }
        }
    }, 5980: (Jt, lt, R) => {
        "use strict";
        R.r(lt), R.d(lt, {mdTransitionAnimation: () => te});
        var r = R(9442), D = R(9753);
        R(7205);
        const te = (j, W) => {
            const ve = "back" === W.direction, ae = W.leavingEl, X = (0, D.g)(W.enteringEl),
                M = X.querySelector("ion-toolbar"), H = (0, r.c)();
            if (H.addElement(X).fill("both").beforeRemoveClass("ion-page-invisible"), ve ? H.duration(W.duration || 200).easing("cubic-bezier(0.47,0,0.745,0.715)") : H.duration(W.duration || 280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform", "translateY(40px)", "translateY(0px)").fromTo("opacity", .01, 1), M) {
                const F = (0, r.c)();
                F.addElement(M), H.addAnimation(F)
            }
            if (ae && ve) {
                H.duration(W.duration || 200).easing("cubic-bezier(0.47,0,0.745,0.715)");
                const F = (0, r.c)();
                F.addElement((0, D.g)(ae)).onFinish(oe => {
                    1 === oe && F.elements.length > 0 && F.elements[0].style.setProperty("display", "none")
                }).fromTo("transform", "translateY(0px)", "translateY(40px)").fromTo("opacity", 1, 0), H.addAnimation(F)
            }
            return H
        }
    }, 3280: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            B: () => B,
            a: () => Ne,
            b: () => ve,
            c: () => M,
            d: () => Xe,
            e: () => F,
            f: () => ce,
            g: () => f,
            h: () => W,
            i: () => v,
            j: () => Ie,
            k: () => $e,
            m: () => ae,
            s: () => P,
            t: () => H
        });
        var r = R(5861), D = R(5729), ie = R(7593), te = R(3756);
        let j = 0;
        const W = new WeakMap, Q = O => ({
                create: E => oe(O, E),
                dismiss: (E, Z, ze) => yt(document, E, Z, O, ze),
                getTop: () => (0, r.Z)(function* () {
                    return $e(document, O)
                })()
            }), Ne = Q("ion-alert"), ve = Q("ion-action-sheet"), ae = Q("ion-modal"), M = Q("ion-popover"),
            H = Q("ion-toast"), F = O => {
                "undefined" != typeof document && it(document);
                const E = j++;
                O.overlayIndex = E, O.hasAttribute("id") || (O.id = `ion-overlay-${E}`)
            },
            oe = (O, E) => "undefined" != typeof window && void 0 !== window.customElements ? window.customElements.whenDefined(O).then(() => {
                const Z = document.createElement(O);
                return Z.classList.add("overlay-hidden"), Object.assign(Z, Object.assign(Object.assign({}, E), {hasController: !0})), I(document).appendChild(Z), new Promise(ze => (0, te.c)(Z, ze))
            }) : Promise.resolve(),
            ge = '[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])',
            Ie = (O, E) => {
                let Z = O.querySelector(ge);
                const ze = null == Z ? void 0 : Z.shadowRoot;
                ze && (Z = ze.querySelector(ge) || Z), Z ? (0, te.f)(Z) : E.focus()
            }, xe = (O, E) => {
                const Z = Array.from(O.querySelectorAll(ge));
                let ze = Z.length > 0 ? Z[Z.length - 1] : null;
                const Je = null == ze ? void 0 : ze.shadowRoot;
                Je && (ze = Je.querySelector(ge) || ze), ze ? ze.focus() : E.focus()
            }, it = O => {
                0 === j && (j = 1, O.addEventListener("focus", E => {
                    ((O, E) => {
                        const Z = $e(E, "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover"),
                            ze = O.target;
                        Z && ze && !Z.classList.contains("ion-disable-focus-trap") && (Z.shadowRoot ? (() => {
                            if (Z.contains(ze)) Z.lastFocus = ze; else {
                                const Le = Z.lastFocus;
                                Ie(Z, Z), Le === E.activeElement && xe(Z, Z), Z.lastFocus = E.activeElement
                            }
                        })() : (() => {
                            if (Z === ze) Z.lastFocus = void 0; else {
                                const Le = (0, te.g)(Z);
                                if (!Le.contains(ze)) return;
                                const ut = Le.querySelector(".ion-overlay-wrapper");
                                if (!ut) return;
                                if (ut.contains(ze)) Z.lastFocus = ze; else {
                                    const Ye = Z.lastFocus;
                                    Ie(ut, Z), Ye === E.activeElement && xe(ut, Z), Z.lastFocus = E.activeElement
                                }
                            }
                        })())
                    })(E, O)
                }, !0), O.addEventListener("ionBackButton", E => {
                    const Z = $e(O);
                    (null == Z ? void 0 : Z.backdropDismiss) && E.detail.register(ie.OVERLAY_BACK_BUTTON_PRIORITY, () => Z.dismiss(void 0, B))
                }), O.addEventListener("keyup", E => {
                    if ("Escape" === E.key) {
                        const Z = $e(O);
                        (null == Z ? void 0 : Z.backdropDismiss) && Z.dismiss(void 0, B)
                    }
                }))
            }, yt = (O, E, Z, ze, Je) => {
                const q = $e(O, ze, Je);
                return q ? q.dismiss(E, Z) : Promise.reject("overlay does not exist")
            }, $e = (O, E, Z) => {
                const ze = ((O, E) => (void 0 === E && (E = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast"), Array.from(O.querySelectorAll(E)).filter(Z => Z.overlayIndex > 0)))(O, E).filter(Je => !(O => O.classList.contains("overlay-hidden"))(Je));
                return void 0 === Z ? ze[ze.length - 1] : ze.find(Je => Je.id === Z)
            }, rt = (O = !1) => {
                const Z = I(document).querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");
                !Z || (O ? Z.setAttribute("aria-hidden", "true") : Z.removeAttribute("aria-hidden"))
            }, Xe = function () {
                var O = (0, r.Z)(function* (E, Z, ze, Je, q) {
                    var Le, ut;
                    if (E.presented) return;
                    rt(!0), E.presented = !0, E.willPresent.emit(), null === (Le = E.willPresentShorthand) || void 0 === Le || Le.emit();
                    const Ye = (0, D.b)(E), Mt = E.enterAnimation ? E.enterAnimation : D.c.get(Z, "ios" === Ye ? ze : Je);
                    (yield l(E, Mt, E.el, q)) && (E.didPresent.emit(), null === (ut = E.didPresentShorthand) || void 0 === ut || ut.emit()), "ION-TOAST" !== E.el.tagName && Ee(E.el), E.keyboardClose && (null === document.activeElement || !E.el.contains(document.activeElement)) && E.el.focus()
                });
                return function (Z, ze, Je, q, Le) {
                    return O.apply(this, arguments)
                }
            }(), Ee = function () {
                var O = (0, r.Z)(function* (E) {
                    let Z = document.activeElement;
                    if (!Z) return;
                    const ze = null == Z ? void 0 : Z.shadowRoot;
                    ze && (Z = ze.querySelector(ge) || Z), yield E.onDidDismiss(), Z.focus()
                });
                return function (Z) {
                    return O.apply(this, arguments)
                }
            }(), ce = function () {
                var O = (0, r.Z)(function* (E, Z, ze, Je, q, Le, ut) {
                    var Ye, Mt;
                    if (!E.presented) return !1;
                    rt(!1), E.presented = !1;
                    try {
                        E.el.style.setProperty("pointer-events", "none"), E.willDismiss.emit({
                            data: Z,
                            role: ze
                        }), null === (Ye = E.willDismissShorthand) || void 0 === Ye || Ye.emit({data: Z, role: ze});
                        const _t = (0, D.b)(E),
                            Pt = E.leaveAnimation ? E.leaveAnimation : D.c.get(Je, "ios" === _t ? q : Le);
                        "gesture" !== ze && (yield l(E, Pt, E.el, ut)), E.didDismiss.emit({
                            data: Z,
                            role: ze
                        }), null === (Mt = E.didDismissShorthand) || void 0 === Mt || Mt.emit({
                            data: Z,
                            role: ze
                        }), W.delete(E), E.el.classList.add("overlay-hidden"), E.el.style.removeProperty("pointer-events")
                    } catch (_t) {
                        console.error(_t)
                    }
                    return E.el.remove(), !0
                });
                return function (Z, ze, Je, q, Le, ut, Ye) {
                    return O.apply(this, arguments)
                }
            }(), I = O => O.querySelector("ion-app") || O.body, l = function () {
                var O = (0, r.Z)(function* (E, Z, ze, Je) {
                    ze.classList.remove("overlay-hidden");
                    const Le = Z(E.el, Je);
                    (!E.animated || !D.c.getBoolean("animated", !0)) && Le.duration(0), E.keyboardClose && Le.beforeAddWrite(() => {
                        const Ye = ze.ownerDocument.activeElement;
                        (null == Ye ? void 0 : Ye.matches("input,ion-input, ion-textarea")) && Ye.blur()
                    });
                    const ut = W.get(E) || [];
                    return W.set(E, [...ut, Le]), yield Le.play(), !0
                });
                return function (Z, ze, Je, q) {
                    return O.apply(this, arguments)
                }
            }(), f = (O, E) => {
                let Z;
                const ze = new Promise(Je => Z = Je);
                return g(O, E, Je => {
                    Z(Je.detail)
                }), ze
            }, g = (O, E, Z) => {
                const ze = Je => {
                    (0, te.b)(O, E, ze), Z(Je)
                };
                (0, te.a)(O, E, ze)
            }, v = O => "cancel" === O || O === B, w = O => O(), P = (O, E) => {
                if ("function" == typeof O) return D.c.get("_zoneGate", w)(() => {
                    try {
                        return O(E)
                    } catch (ze) {
                        throw ze
                    }
                })
            }, B = "backdrop"
    }, 8349: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {Z: () => r});

        class r {
            constructor() {
                this.THEME = !1, this.technicalBreak = !1, this.slowInternet = !1, this.mine = !1, this.intro = !0, this.token = "", this.coins = 0, this.asset = "lock.glb", this.userAsset = "lock.glb", this.membership = {}, this.nftError = !1, this.nftLoading = !1, this.disableFeatures = !1, this.api = [], this.wallets = [], this.chartData = [], this.withdrawHistory = [], this.version = 20, this.privacy = "https://wlunarichgang.com/privacy", this.terms = "https://wlunarichgang.com/terms", this.hashRate = 60, this.minerSpeeds = 1, this.minerRate = 0, this.experience = 0, this.xpProgress = 0, this.level = 0, this.highNetwork = !1, this.proNetwork = !1, this.experiencePop = !1, this.infoPop = !1, this.giftPop = !1, this.openGift = !1, this.shakeGift = !0, this.hideGift = !1, this.giftReward = 0, this.usersNFT = [], this.appIcon = "41", this.usersCards = [], this.cards = [{
                    name: "Paper Graphic Card",
                    gif: "assets/engine/paper.gif",
                    price: 1,
                    textPrice: "1",
                    sellPrice: .5,
                    hashRate: 60,
                    level: 0,
                    description: "This old graphic card you found in trash. It's good for nothing, but there is no other."
                }, {
                    name: "Scratched Aluminum Graphic Card",
                    gif: "assets/engine/scratched-aluminum.gif",
                    price: 100,
                    textPrice: "100",
                    sellPrice: 56,
                    hashRate: 150,
                    level: 0,
                    description: "This graphic card significantly speeds up your mining! Scratched Aluminum it's the best you can do now."
                }, {
                    name: "Bubbles Graphic Card",
                    gif: "assets/engine/bubbles.gif",
                    price: 1e3,
                    textPrice: "1k",
                    sellPrice: 621,
                    hashRate: 192,
                    level: 0,
                    description: "Bubbles! Just stay awake, bubbles can make you dull! "
                }, {
                    name: "Rough Gold Graphic Card",
                    gif: "assets/engine/rought-gold.gif",
                    price: 1e4,
                    textPrice: "10k",
                    sellPrice: 4e3,
                    hashRate: 240,
                    level: 1,
                    description: "PURE GOLD! You are a gang member, you wear yourself in gold and dig the desired money!"
                }, {
                    name: "Sea Painting Graphic Card",
                    gif: "assets/engine/sea-painting.gif",
                    price: 8e4,
                    textPrice: "80k",
                    sellPrice: 3e4,
                    hashRate: 252,
                    level: 1,
                    description: "Sea & Paintings! Sometimes you feel like a poet. You are rich, chilling at the see. What more could you want?"
                }, {
                    name: "Algea Graphic Card",
                    gif: "assets/engine/algea.gif",
                    price: 25e5,
                    textPrice: "2,5m",
                    sellPrice: 9e5,
                    hashRate: 300,
                    level: 2,
                    description: "Algae Driven Graphics Cards! New technology from Japan."
                }, {
                    name: "Orange Lava Graphic Card",
                    gif: "assets/engine/orange-lava.gif",
                    price: 7e6,
                    textPrice: "7m",
                    sellPrice: 3e6,
                    hashRate: 306,
                    level: 2,
                    description: "This card is hot! Don't touch it."
                }, {
                    name: "Rought Aluminium Graphic Card",
                    gif: "assets/engine/rought-aluminium.gif",
                    price: 21e6,
                    textPrice: "21m",
                    sellPrice: 9e6,
                    hashRate: 360,
                    level: 6,
                    description: "A flashback about the good old days. Now you are operating at a higher level."
                }, {
                    name: "Sulfur Graphic Card",
                    gif: "assets/engine/sulfur.gif",
                    price: 55e6,
                    textPrice: "55m",
                    sellPrice: 3e7,
                    hashRate: 432,
                    level: 6,
                    description: "All it takes is one spark to make this card kick wild!"
                }, {
                    name: "Green Painting Graphic Card",
                    gif: "assets/engine/green-painting.gif",
                    price: 25e7,
                    textPrice: "250m",
                    sellPrice: 9e7,
                    hashRate: 504,
                    level: 10,
                    description: "You found this card in the bazaar and discovered that it has great power."
                }, {
                    name: "Green Plasma Graphic Card",
                    gif: "assets/engine/green-plasma.gif",
                    price: 5e8,
                    textPrice: "500m",
                    sellPrice: 35e7,
                    hashRate: 612,
                    level: 25,
                    description: "A green plasma-driven card give you stability and high hash rate."
                }, {
                    name: "Dark Plasma Graphic Card",
                    gif: "assets/engine/dark-plasma.gif",
                    price: 1e9,
                    textPrice: "1bn",
                    sellPrice: 7e8,
                    hashRate: 984,
                    level: 60,
                    description: "Based on the latest technology achievements, a dark plasma-driven card was created. It can be unstable and explode."
                }], this.networks = [{
                    chainId: 137,
                    name: "Polygon",
                    rpc: "https://polygon-rpc.com/",
                    providerName: "matic",
                    logo: "polygon.svg",
                    explorer: "https://polygonscan.com",
                    explorerName: "Polygonscan",
                    active: !0,
                    bossLevel: !1,
                    color: "#7b44da",
                    minWithdraw: 1
                }, {
                    chainId: 1,
                    name: "Ethereum",
                    rpc: "https://mainnet.infura.io/v3/",
                    providerName: "ethereum",
                    logo: "ethereum.svg",
                    explorer: "https://etherscan.com",
                    explorerName: "Etherscan",
                    active: !1,
                    bossLevel: !0,
                    color: "#5e78de",
                    minWithdraw: 1500
                }], this.diamonds = [{day: "Day 1", img: "assets/icons/10.svg", amount: 100}, {
                    day: "Day 2",
                    img: "assets/icons/11.svg",
                    amount: 200
                }, {day: "Day 3", img: "assets/icons/12.svg", amount: 400}, {
                    day: "Day 4",
                    img: "assets/icons/10.svg",
                    amount: 700
                }, {day: "Day 5", img: "assets/icons/10.svg", amount: 900}, {
                    day: "Day 6",
                    img: "assets/icons/10.svg",
                    amount: 1200
                }, {
                    day: "Day 7",
                    img: "assets/icons/16.svg",
                    amount: 3e3
                }], this.razors = ["expensive-plastic", "gold", "lava", "pink-flakes", "wall", "aluminium", "anisotropy-radial", "blue-glitter", "brass", "bronze", "copper", "damascus", "galvanized", "green-glitter", "pyramid-glass", "red-glitter", "brown-wood", "grey-wood", "plastic-dots", "plastic-stripes"], this.words = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo", ""]
            }
        }
    }, 2177: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {k: () => W});
        var r = R(6435), D = R(7609), ie = R(8349), te = R(2313);
        const j = ["iframe"];
        let W = (() => {
            class Q {
                constructor(ve, me, ae) {
                    this.modalCtrl = ve, this.settings = me, this.domSanitizer = ae
                }

                ionViewDidEnter() {
                    this.src = this.domSanitizer.bypassSecurityTrustHtml('<iframe style="border: none; position: absolute; width: 100%; height: 100%;" src="assets/scene.html">')
                }

                ngAfterViewInit() {
                    setTimeout(() => {
                        let ve = this.iframe.nativeElement.contentDocument;
                        console.log(ve), ve.insertAdjacentHTML("beforeend", "<h1>TEST CONTENT</h1>")
                    }, 3e3)
                }

                ngOnInit() {
                }

                back() {
                    this.modalCtrl.dismiss()
                }
            }

            return Q.\u0275fac = function (ve) {
                return new (ve || Q)(r.Y36(D.IN), r.Y36(ie.Z), r.Y36(te.H7))
            }, Q.\u0275cmp = r.Xpm({
                type: Q,
                selectors: [["app-ar"]],
                viewQuery: function (ve, me) {
                    if (1 & ve && r.Gf(j, 7), 2 & ve) {
                        let ae;
                        r.iGM(ae = r.CRH()) && (me.iframe = ae.first)
                    }
                },
                decls: 10,
                vars: 1,
                consts: [[1, "ion-no-border", 2, "padding", "0px", "background-color", "var(--ion-background-color)", "box-shadow", "none"], [2, "--background", "transparent", "box-shadow", "none", "--box-shadow", "none", "padding", "8px 10px 8px 10px", "border-bottom", "1px solid var(--ion-border-color)"], ["slot", "start", 1, "headerButton", "ion-activatable", "ripple-parent", 2, "color", "var(--ion-text-color)", "background-color", "transparent", "box-shadow", "none", "font-size", "30px", 3, "click"], ["name", "chevron-back-outline"], ["type", "bounded", 2, "border-radius", "50%"], [1, "header-title", 2, "margin", "0px 44px -2px 0px"], [3, "innerHTML"], ["src", "assets/scene.html", "id", "maka", 2, "border", "none", "position", "absolute", "width", "100%", "height", "100%"]],
                template: function (ve, me) {
                    1 & ve && (r.TgZ(0, "ion-header", 0)(1, "ion-toolbar", 1)(2, "button", 2), r.NdJ("click", function () {
                        return me.back()
                    }), r._UZ(3, "ion-icon", 3)(4, "ion-ripple-effect", 4), r.qZA(), r.TgZ(5, "ion-title", 5), r._uU(6, "View in your space"), r.qZA()()(), r.TgZ(7, "ion-content"), r._UZ(8, "div", 6)(9, "iframe", 7), r.qZA()), 2 & ve && (r.xp6(8), r.Q6J("innerHTML", me.src, r.oJD))
                },
                directives: [D.Gu, D.sr, D.gu, D.H$, D.wd, D.W2],
                styles: [""]
            }), Q
        })()
    }, 1808: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {t: () => te});
        var r = R(520), D = R(6435), ie = R(8349);
        let te = (() => {
            class j {
                constructor(Q, Ne) {
                    this.http = Q, this.settings = Ne, this.gmailAPI = "https://gmail.googleapis.com/gmail/v1/users/", this.sheetApi = "https://sheets.googleapis.com/v4/spreadsheets/", this.authUrl = "https://accounts.google.com/o/oauth2/token", this.SETTING_SHEET = "1qKbyMwmoW39nMXh9dNcZpZBE661Ks9y_Lz4Qca11M40", this.SHEET_ID = "18l3CJgVlY8OPdGSNbCb94y5TNuqK68hohUv18m71dQg", this.CLIENT_ID = "1012572050230-p26nbv8rp17bgvoq8qnmpao1o680rtl2.apps.googleusercontent.com", this.CLIENT_SECRET = "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", this.REFRESH_TOKEN = "1//04q38v-QXo4RICgYIARAAGAQSNwF-L9IrpiuxQh8YNgie49jg6CfLdVoCrLWOtLfLUM6UzNKSlyxjNcMoi8ujyKwygrRfx9dIrfA"
                }

                getBalanceEthereum(Q, Ne) {
                    Math.random();
                    var me = "https://api.etherscan.io/api?module=account&action=tokenbalance&contractaddress=" + Ne + "&address=" + Q + "&tag=latest&apikey=2YUCT2AMXT7NEE521XSA13NJZZNMS5IS1N";
                    return new Promise((ae, X) => {
                        this.http.get(me).subscribe(M => {
                            ae(M)
                        }, M => {
                            ae(M)
                        })
                    })
                }

                getBalancePolygon(Q, Ne) {
                    Math.random();
                    var me = "https://api.polygonscan.com/api?module=account&action=tokenbalance&contractaddress=" + Ne + "&address=" + Q + "&tag=latest&apikey=YYGVMP37X2AMTF9RSGXEH9KRE4IVKJFFCP";
                    return new Promise((ae, X) => {
                        this.http.get(me).subscribe(M => {
                            ae(M)
                        }, M => {
                            ae(M)
                        })
                    })
                }

                getAccessToken() {
                    var Q = this.authUrl;
                    let Ne = new r.WM({"Content-Type": "application/json"}), ve = {
                        grant_type: "refresh_token",
                        client_id: this.CLIENT_ID,
                        client_secret: this.CLIENT_SECRET,
                        refresh_token: this.REFRESH_TOKEN
                    };
                    return new Promise((me, ae) => {
                        this.http.post(Q, ve, {headers: Ne}).subscribe(X => {
                            me(X)
                        }, X => {
                            me(X)
                        })
                    })
                }

                create(Q, Ne) {
                    var ve = this.sheetApi + this.SHEET_ID + "/values/" + Ne + ":append?valueInputOption=RAW";
                    let me = new r.WM({
                        Authorization: `Bearer ${this.settings.token}`,
                        Accept: "application/json",
                        "Content-Type": "application/json"
                    });
                    return new Promise((ae, X) => {
                        this.http.post(ve, Q, {headers: me}).subscribe(M => {
                            ae(M)
                        }, M => {
                            ae(M)
                        })
                    })
                }

                getData(Q) {
                    var Ne = this.sheetApi + this.SETTING_SHEET + "/values/" + Q;
                    let ve = new r.WM({Authorization: `Bearer ${this.settings.token}`, Accept: "application/json"});
                    return new Promise((me, ae) => {
                        this.http.get(Ne, {headers: ve}).subscribe(X => {
                            me(X)
                        }, X => {
                            me(X)
                        })
                    })
                }

                convertData(Q) {
                    const Ne = Q[0], ve = Q.slice(1);
                    let me = [];
                    return ve.forEach(X => {
                        let M = {};
                        for (let H = 0; H < Ne.length; H++) M[Ne[H]] = X[H];
                        me.push(M)
                    }), me
                }

                getTokenHolders(Q) {
                    var Ne = "https://api.transpose.io/v0/token/owners-by-contract-address?contract_address=" + Q + "&limit=500";
                    let ve = new r.WM({
                        Accept: "application/json",
                        "X-API-KEY": "x3cXibyAoi3bj73SFgTQr6f8ceVvhP0f3xftXHs2"
                    });
                    return new Promise((me, ae) => {
                        this.http.get(Ne, {headers: ve}).subscribe(X => {
                            me(X)
                        }, X => {
                            me(X)
                        })
                    })
                }

                getNFT(Q) {
                    var Ne = "https://api.opensea.io/api/v1/asset/0x495f947276749ce646f68ac8c248420045cb7b5e/" + Q;
                    return this.settings.nftLoading = !0, new Promise((ve, me) => {
                        ve(ae)
                        formatDate(Q)
                        {
                            var Ne = (new Date).getTime() - new Date(Q).getTime(), ve = Math.floor(Ne / 1e3),
                                me = Math.floor(ve / 60), ae = Math.floor(me / 60), X = Math.floor(ae / 24),
                                M = Math.floor(X / 30), H = Math.floor(M / 12);
                            this.http.get(Ne).subscribe(ae => {
                            }, ae => {
                                ve(ae)
                            })
                        }
                    )
                    }


                    return j.\u0275fac = function (Q) {
                        return new (Q || j)(D.LFG(r.eN), D.LFG(ie.Z))
                    }, j.\u0275prov = D.Yz7({token: j, factory: j.\u0275fac, providedIn: "root"}), j
                    return ve < 1 ? "Just now" : 1 === ve ? ve + " second ago" : ve < 60 && ve > 1 ? ve + " seconds ago" : 1 === me ? me + " minute ago" : me < 60 && me > 1 ? me + " minutes ago" : 1 === ae ? ae + " hour ago" : ae < 24 && ae > 1 ? ae + " hours ago" : 1 === X ? X + " day go" : X < 30 && X > 1 ? X + " days ago" : 1 === M ? M + " month ago" : M < 12 && M > 1 ? M + " months ago" : 1 === H ? H + " year ago" : H > 1 ? H + " years ago" : void 0
                }
            }

            return j.\u0275fac = function (Q) {
                return new (Q || j)(D.LFG(r.eN), D.LFG(ie.Z))
            }, j.\u0275prov = D.Yz7({token: j, factory: j.\u0275fac, providedIn: "root"}), j
        })()
    }, 546: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {b: () => te});
        var r = R(655), D = R(7609), ie = R(6435);
        let te = (() => {
            class Q {
                constructor(ve, me) {
                    this.toastCtrl = ve, this.alertCtrl = me
                }

                presentToast(ve, me, ae, X) {
                    return (0, r.mG)(this, void 0, void 0, function* () {
                        (yield this.toastCtrl.create({
                            message: ve,
                            icon: X,
                            enterAnimation: j,
                            leaveAnimation: W,
                            position: me,
                            duration: ae,
                            cssClass: "toaster"
                        })).present()
                    })
                }

                presentAlert(ve, me) {
                    this.alertCtrl.create({
                        header: ve, subHeader: me, buttons: [{
                            text: "Never", handler: () => {
                            }
                        }, {
                            text: "Yes!", handler: () => {
                            }
                        }]
                    }).then(X => {
                        X.present()
                    })
                }
            }

            return Q.\u0275fac = function (ve) {
                return new (ve || Q)(ie.LFG(D.yF), ie.LFG(D.Br))
            }, Q.\u0275prov = ie.Yz7({token: Q, factory: Q.\u0275fac, providedIn: "root"}), Q
        })();
        const j = Q => {
            const Ne = new D.vB, ve = Ne.create(), me = Ne.create();
            return me.addElement(Q.shadowRoot.querySelector(".toast-wrapper")).fromTo("transform", "translateY(-100%)", "translateY(0%)").fromTo("opacity", 1, 1), ve.addElement(Q).easing("cubic-bezier(0.175, 0.985, 0.32, 1.275)").duration(300).addAnimation([me])
        }, W = Q => j(Q).duration(200).direction("reverse")
    }, 9351: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {n: () => X});
        var r = R(6435), D = R(7609), ie = R(5956), te = R(4299), j = R(8349), W = R(546), Q = R(1808), Ne = R(9808);
        const ve = function (M) {
            return {active: M}
        };

        function me(M, H) {
            if (1 & M) {
                const F = r.EpF();
                r.TgZ(0, "div", 8)(1, "div", 9)(2, "div", 10), r._UZ(3, "ion-icon", 11)(4, "img", 12), r.qZA(), r.TgZ(5, "div", 13)(6, "ion-title", 14), r._uU(7), r.qZA(), r.TgZ(8, "ion-title", 15), r._uU(9), r.qZA(), r.TgZ(10, "ion-title", 15), r._uU(11), r.qZA()(), r.TgZ(12, "div", 16)(13, "ion-title", 17), r._uU(14), r.qZA()()(), r.TgZ(15, "ion-button", 18), r.NdJ("click", function () {
                    const Ie = r.CHM(F).$implicit;
                    return r.oxw().link(Ie.txurl)
                }), r.TgZ(16, "ion-title"), r._uU(17), r.qZA(), r._UZ(18, "ion-ripple-effect"), r.qZA()()
            }
            if (2 & M) {
                const F = H.$implicit, oe = H.index, ge = r.oxw();
                r.Q6J("ngClass", r.VKq(7, ve, 0 == oe && ge.highlightFirst)), r.xp6(4), r.MGl("src", "assets/", F.logo, "", r.LSH), r.xp6(3), r.Oqu(F.receive), r.xp6(2), r.hij("Send \xb7 ", F.date, ""), r.xp6(2), r.hij("Network: ", F.network, ""), r.xp6(3), r.hij("", F.amount, " WRG"), r.xp6(3), r.hij("View on ", F.blockExplorer, "")
            }
        }

        function ae(M, H) {
            if (1 & M) {
                const F = r.EpF();
                r.TgZ(0, "div", 19)(1, "button", 20), r.NdJ("click", function () {
                    return r.CHM(F), r.oxw().toast("There is no withdraw history.")
                }), r._UZ(2, "ion-icon", 21), r._uU(3, " No data "), r._UZ(4, "ion-ripple-effect", 22), r.qZA()()
            }
        }

        let X = (() => {
            class M {
                constructor(F, oe, ge, Ie, he, xe, Ue) {
                    this.modalCtrl = F, this.vibration = oe, this.clipboard = ge, this.settings = Ie, this.CFS = he, this.service = xe, this.navParams = Ue, this.history = [], this.highlightFirst = this.navParams.get("highlightFirst")
                }

                ngOnInit() {
                    this.settings.withdrawHistory = JSON.parse(window.localStorage.getItem("withdrawHistory")) ? JSON.parse(window.localStorage.getItem("withdrawHistory")) : [], this.history = this.settings.withdrawHistory.reverse(), this.history.forEach(F => {
                        F.date = this.service.formatDate(F.date);
                        let oe = this.settings.networks.find(ge => ge.chainId == F.chainId);
                        F.network = oe.name, F.blockExplorer = oe.explorerName, F.logo = oe.logo, F.txurl = oe.explorer + "/tx/" + F.hash, F.color = oe.color
                    }), setTimeout(() => {
                        this.highlightFirst = !1
                    }, 1600)
                }

                toast(F) {
                    this.CFS.presentToast(F, "bottom", 800, "alert-circle-outline")
                }

                back() {
                    this.modalCtrl.dismiss()
                }

                link(F) {
                    window.open(F, "_blank")
                }

                copy(F) {
                    this.vibration.vibrate(5), this.clipboard.copy(F), this.CFS.presentToast("Copied!", "bottom", 500, "copy-outline")
                }
            }

            return M.\u0275fac = function (F) {
                return new (F || M)(r.Y36(D.IN), r.Y36(ie.w), r.Y36(te.T), r.Y36(j.Z), r.Y36(W.b), r.Y36(Q.t), r.Y36(D.X1))
            }, M.\u0275cmp = r.Xpm({
                type: M,
                selectors: [["app-history"]],
                decls: 10,
                vars: 2,
                consts: [[1, "ion-no-border", 2, "padding", "0px", "background-color", "var(--ion-background-color)", "box-shadow", "none"], [2, "--background", "transparent", "box-shadow", "none", "--box-shadow", "none", "padding", "8px 10px 8px 10px", "border-bottom", "1px solid var(--ion-border-color)"], ["slot", "start", 1, "headerButton", "ion-activatable", "ripple-parent", 2, "color", "var(--ion-text-color)", "background-color", "transparent", "box-shadow", "none", "font-size", "30px", 3, "click"], ["name", "chevron-back-outline"], ["type", "bounded", 2, "border-radius", "50%"], [1, "header-title", 2, "margin", "0px 44px -2px 0px"], ["class", "tx", 3, "ngClass", 4, "ngFor", "ngForOf"], ["style", "position: absolute; top: 50%; left: 50%; -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%); text-align: center; margin: 0px; padding: 0px;", 4, "ngIf"], [1, "tx", 3, "ngClass"], [2, "display", "flex"], [2, "position", "relative"], ["name", "arrow-up-outline", 1, "type"], ["loading", "lazy", 1, "networkicon", 3, "src"], [2, "margin", "0px", "padding", "0px", "width", "calc(50% - 40px)"], [2, "font-size", "16px", "width", "190px"], [2, "padding-top", "3px", "opacity", "0.4", "font-size", "16px", "width", "190px"], [2, "margin", "0px", "padding", "0px", "width", "50%"], [2, "text-align", "right", "font-size", "16px", "width", "190px"], [1, "viewButton", 3, "click"], [2, "position", "absolute", "top", "50%", "left", "50%", "-ms-transform", "translate(-50%, -50%)", "transform", "translate(-50%, -50%)", "text-align", "center", "margin", "0px", "padding", "0px"], [1, "info-button", "ion-activatable", "ripple-parent", 3, "click"], ["name", "alert-circle-outline"], ["type", "unbounded"]],
                template: function (F, oe) {
                    1 & F && (r.TgZ(0, "ion-header", 0)(1, "ion-toolbar", 1)(2, "button", 2), r.NdJ("click", function () {
                        return oe.back()
                    }), r._UZ(3, "ion-icon", 3)(4, "ion-ripple-effect", 4), r.qZA(), r.TgZ(5, "ion-title", 5), r._uU(6, "Withdraw history"), r.qZA()()(), r.TgZ(7, "ion-content"), r.YNc(8, me, 19, 9, "div", 6), r.YNc(9, ae, 5, 0, "div", 7), r.qZA()), 2 & F && (r.xp6(8), r.Q6J("ngForOf", oe.history), r.xp6(1), r.Q6J("ngIf", !oe.history.length))
                },
                directives: [D.Gu, D.sr, D.gu, D.H$, D.wd, D.W2, Ne.sg, Ne.mk, D.YG, Ne.O5],
                styles: [".tx[_ngcontent-%COMP%]{padding:18px;border-bottom:1px solid var(--ion-border-color);opacity:1;filter:blur(0px);background-color:var(--ion-background-color);overflow:hidden}.tx.active[_ngcontent-%COMP%]{max-height:0px;--box-color: var(--ion-app-color-rgb);animation:background 1.6s cubic-bezier(.39,.575,.565,1)}.tx.item-disabled[_ngcontent-%COMP%]{opacity:.3;filter:blur(1px)}.tx[_ngcontent-%COMP%]   ion-card[_ngcontent-%COMP%]{--box-shadow: none;box-shadow:none;padding:0;margin:0}.tx[_ngcontent-%COMP%]   .type[_ngcontent-%COMP%]{display:flex;border:1px solid rgba(var(--ion-green-color-rgb),1);color:rgba(var(--ion-green-color-rgb),1);padding:8px;font-size:18px;border-radius:50%;transform:rotate(45deg);margin-inline-end:0px}.tx[_ngcontent-%COMP%]   .networkicon[_ngcontent-%COMP%]{position:absolute;bottom:12px;right:0px;width:16px;height:16px;border:1px solid rgba(var(--ion-green-color-rgb),1);border-radius:50%}.tx[_ngcontent-%COMP%]   .viewButton[_ngcontent-%COMP%]{width:calc(100% - 52px);height:32px;position:relative;display:block;box-shadow:none;--box-shadow: none;--border-radius: 4px;padding:0;margin:12px 0 0 56px;--background: rgba(var(--ion-app-color-rgb), 1);color:var(--ion-text-color)}.tx[_ngcontent-%COMP%]   .viewButton[_ngcontent-%COMP%]   ion-title[_ngcontent-%COMP%]{font-size:16px!important;margin:0;padding:0;text-transform:capitalize}@keyframes background{0%{background-color:rgba(var(--box-color),0);max-height:0px}25%{background-color:rgba(var(--box-color),.4)}50%{background-color:rgba(var(--box-color),0)}75%{background-color:rgba(var(--box-color),.4)}to{background-color:rgba(var(--box-color),0);max-height:300px}}.info-button[_ngcontent-%COMP%]{position:relative;box-shadow:none;border-radius:50px;padding:0 0 1px;background-color:transparent;color:var(--ion-text-color);font-size:16px;transition:all .14s cubic-bezier(.25,.46,.45,.94);transform:scale(1)}.info-button[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{margin:0 0 -4px}.info-button[_ngcontent-%COMP%]:active{transform:scale(.9)}"]
            }), M
        })()
    }, 5002: (Jt, lt, R) => {
        "use strict";
        R.r(lt), R.d(lt, {WithdrawPageModule: () => ve});
        var r = R(9808), D = R(4182), ie = R(7609), te = R(9800), j = R(258), W = R(6435);
        const Q = [{path: "", component: j.U}];
        let Ne = (() => {
            class me {
            }

            return me.\u0275fac = function (X) {
                return new (X || me)
            }, me.\u0275mod = W.oAB({type: me}), me.\u0275inj = W.cJS({imports: [[te.Bz.forChild(Q)], te.Bz]}), me
        })(), ve = (() => {
            class me {
            }

            return me.\u0275fac = function (X) {
                return new (X || me)
            }, me.\u0275mod = W.oAB({type: me}), me.\u0275inj = W.cJS({imports: [[r.ez, D.u5, ie.Pc, Ne]]}), me
        })()
    }, 258: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {U: () => An});
        var r = R(655), D = R(7609), ie = R(9351), te = R(499), j = R(2909), W = R(4325), Q = R(8666);
        const Ne = "abi/5.6.4", ve = new Q.Yd(Ne);

        class ae {
            constructor(o, u, d, C) {
                this.name = o, this.type = u, this.localName = d, this.dynamic = C
            }

            _throwError(o, u) {
                ve.throwArgumentError(o, this.localName, u)
            }
        }

        class X {
            constructor(o) {
                (0, W.zG)(this, "wordSize", o || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(o)
            }

            get data() {
                return (0, te.xs)(this._data)
            }

            get length() {
                return this._dataLength
            }

            _writeData(o) {
                return this._data.push(o), this._dataLength += o.length, o.length
            }

            appendWriter(o) {
                return this._writeData((0, te.zo)(o._data))
            }

            writeBytes(o) {
                let u = (0, te.lE)(o);
                const d = u.length % this.wordSize;
                return d && (u = (0, te.zo)([u, this._padding.slice(d)])), this._writeData(u)
            }

            _getValue(o) {
                let u = (0, te.lE)(j.O$.from(o));
                return u.length > this.wordSize && ve.throwError("value out-of-bounds", Q.Yd.errors.BUFFER_OVERRUN, {
                    length: this.wordSize,
                    offset: u.length
                }), u.length % this.wordSize && (u = (0, te.zo)([this._padding.slice(u.length % this.wordSize), u])), u
            }

            writeValue(o) {
                return this._writeData(this._getValue(o))
            }

            writeUpdatableValue() {
                const o = this._data.length;
                return this._data.push(this._padding), this._dataLength += this.wordSize, u => {
                    this._data[o] = this._getValue(u)
                }
            }
        }

        class M {
            constructor(o, u, d, C) {
                (0, W.zG)(this, "_data", (0, te.lE)(o)), (0, W.zG)(this, "wordSize", u || 32), (0, W.zG)(this, "_coerceFunc", d), (0, W.zG)(this, "allowLoose", C), this._offset = 0
            }

            get data() {
                return (0, te.Dv)(this._data)
            }

            get consumed() {
                return this._offset
            }

            static coerce(o, u) {
                let d = o.match("^u?int([0-9]+)$");
                return d && parseInt(d[1]) <= 48 && (u = u.toNumber()), u
            }

            coerce(o, u) {
                return this._coerceFunc ? this._coerceFunc(o, u) : M.coerce(o, u)
            }

            _peekBytes(o, u, d) {
                let C = Math.ceil(u / this.wordSize) * this.wordSize;
                return this._offset + C > this._data.length && (this.allowLoose && d && this._offset + u <= this._data.length ? C = u : ve.throwError("data out-of-bounds", Q.Yd.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + C
                })), this._data.slice(this._offset, this._offset + C)
            }

            subReader(o) {
                return new M(this._data.slice(this._offset + o), this.wordSize, this._coerceFunc, this.allowLoose)
            }

            readBytes(o, u) {
                let d = this._peekBytes(0, o, !!u);
                return this._offset += d.length, d.slice(0, o)
            }

            readValue() {
                return j.O$.from(this.readBytes(this.wordSize))
            }
        }

        var H = R(8016), F = R(6171), oe = R(2547);

        class ge extends ae {
            constructor(o) {
                super("address", "address", o, !1)
            }

            defaultValue() {
                return "0x0000000000000000000000000000000000000000"
            }

            encode(o, u) {
                try {
                    u = (0, H.Kn)(u)
                } catch (d) {
                    this._throwError(d.message, u)
                }
                return o.writeValue(u)
            }

            decode(o) {
                return (0, H.Kn)((0, te.$m)(o.readValue().toHexString(), 20))
            }
        }

        class Ie extends ae {
            constructor(o) {
                super(o.name, o.type, void 0, o.dynamic), this.coder = o
            }

            defaultValue() {
                return this.coder.defaultValue()
            }

            encode(o, u) {
                return this.coder.encode(o, u)
            }

            decode(o) {
                return this.coder.decode(o)
            }
        }

        const he = new Q.Yd(Ne);

        function xe(N, o, u) {
            let d = null;
            if (Array.isArray(u)) d = u; else if (u && "object" == typeof u) {
                let xt = {};
                d = o.map(st => {
                    const Vt = st.localName;
                    return Vt || he.throwError("cannot encode object for signature with missing names", Q.Yd.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: st,
                        value: u
                    }), xt[Vt] && he.throwError("cannot encode object for signature with duplicate names", Q.Yd.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: st,
                        value: u
                    }), xt[Vt] = !0, u[Vt]
                })
            } else he.throwArgumentError("invalid tuple value", "tuple", u);
            o.length !== d.length && he.throwArgumentError("types/value length mismatch", "tuple", u);
            let C = new X(N.wordSize), ee = new X(N.wordSize), se = [];
            o.forEach((xt, st) => {
                let Vt = d[st];
                if (xt.dynamic) {
                    let Wt = ee.length;
                    xt.encode(ee, Vt);
                    let pn = C.writeUpdatableValue();
                    se.push(Ln => {
                        pn(Ln + Wt)
                    })
                } else xt.encode(C, Vt)
            }), se.forEach(xt => {
                xt(C.length)
            });
            let ct = N.appendWriter(C);
            return ct += N.appendWriter(ee), ct
        }

        function Ue(N, o) {
            let u = [], d = N.subReader(0);
            o.forEach(ee => {
                let se = null;
                if (ee.dynamic) {
                    let ct = N.readValue(), xt = d.subReader(ct.toNumber());
                    try {
                        se = ee.decode(xt)
                    } catch (st) {
                        if (st.code === Q.Yd.errors.BUFFER_OVERRUN) throw st;
                        se = st, se.baseType = ee.name, se.name = ee.localName, se.type = ee.type
                    }
                } else try {
                    se = ee.decode(N)
                } catch (ct) {
                    if (ct.code === Q.Yd.errors.BUFFER_OVERRUN) throw ct;
                    se = ct, se.baseType = ee.name, se.name = ee.localName, se.type = ee.type
                }
                null != se && u.push(se)
            });
            const C = o.reduce((ee, se) => {
                const ct = se.localName;
                return ct && (ee[ct] || (ee[ct] = 0), ee[ct]++), ee
            }, {});
            o.forEach((ee, se) => {
                let ct = ee.localName;
                if (!ct || 1 !== C[ct] || ("length" === ct && (ct = "_length"), null != u[ct])) return;
                const xt = u[se];
                xt instanceof Error ? Object.defineProperty(u, ct, {
                    enumerable: !0, get: () => {
                        throw xt
                    }
                }) : u[ct] = xt
            });
            for (let ee = 0; ee < u.length; ee++) {
                const se = u[ee];
                se instanceof Error && Object.defineProperty(u, ee, {
                    enumerable: !0, get: () => {
                        throw se
                    }
                })
            }
            return Object.freeze(u)
        }

        class it extends ae {
            constructor(o, u, d) {
                super("array", o.type + "[" + (u >= 0 ? u : "") + "]", d, -1 === u || o.dynamic), this.coder = o, this.length = u
            }

            defaultValue() {
                const o = this.coder.defaultValue(), u = [];
                for (let d = 0; d < this.length; d++) u.push(o);
                return u
            }

            encode(o, u) {
                Array.isArray(u) || this._throwError("expected array value", u);
                let d = this.length;
                -1 === d && (d = u.length, o.writeValue(u.length)), he.checkArgumentCount(u.length, d, "coder array" + (this.localName ? " " + this.localName : ""));
                let C = [];
                for (let ee = 0; ee < u.length; ee++) C.push(this.coder);
                return xe(o, C, u)
            }

            decode(o) {
                let u = this.length;
                -1 === u && (u = o.readValue().toNumber(), 32 * u > o._data.length && he.throwError("insufficient data length", Q.Yd.errors.BUFFER_OVERRUN, {
                    length: o._data.length,
                    count: u
                }));
                let d = [];
                for (let C = 0; C < u; C++) d.push(new Ie(this.coder));
                return o.coerce(this.name, Ue(o, d))
            }
        }

        class yt extends ae {
            constructor(o) {
                super("bool", "bool", o, !1)
            }

            defaultValue() {
                return !1
            }

            encode(o, u) {
                return o.writeValue(u ? 1 : 0)
            }

            decode(o) {
                return o.coerce(this.type, !o.readValue().isZero())
            }
        }

        class Ce extends ae {
            constructor(o, u) {
                super(o, o, u, !0)
            }

            defaultValue() {
                return "0x"
            }

            encode(o, u) {
                u = (0, te.lE)(u);
                let d = o.writeValue(u.length);
                return d += o.writeBytes(u), d
            }

            decode(o) {
                return o.readBytes(o.readValue().toNumber(), !0)
            }
        }

        class $e extends Ce {
            constructor(o) {
                super("bytes", o)
            }

            decode(o) {
                return o.coerce(this.name, (0, te.Dv)(super.decode(o)))
            }
        }

        class rt extends ae {
            constructor(o, u) {
                let d = "bytes" + String(o);
                super(d, d, u, !1), this.size = o
            }

            defaultValue() {
                return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
            }

            encode(o, u) {
                let d = (0, te.lE)(u);
                return d.length !== this.size && this._throwError("incorrect data length", u), o.writeBytes(d)
            }

            decode(o) {
                return o.coerce(this.name, (0, te.Dv)(o.readBytes(this.size)))
            }
        }

        class Xe extends ae {
            constructor(o) {
                super("null", "", o, !1)
            }

            defaultValue() {
                return null
            }

            encode(o, u) {
                return null != u && this._throwError("not null", u), o.writeBytes([])
            }

            decode(o) {
                return o.readBytes(0), o.coerce(this.name, null)
            }
        }

        var Ee = R(3037);

        class ce extends ae {
            constructor(o, u, d) {
                const C = (u ? "int" : "uint") + 8 * o;
                super(C, C, d, !1), this.size = o, this.signed = u
            }

            defaultValue() {
                return 0
            }

            encode(o, u) {
                let d = j.O$.from(u), C = Ee.Bz.mask(8 * o.wordSize);
                if (this.signed) {
                    let ee = C.mask(8 * this.size - 1);
                    (d.gt(ee) || d.lt(ee.add(Ee.fh).mul(Ee.tL))) && this._throwError("value out-of-bounds", u)
                } else (d.lt(Ee._Y) || d.gt(C.mask(8 * this.size))) && this._throwError("value out-of-bounds", u);
                return d = d.toTwos(8 * this.size).mask(8 * this.size), this.signed && (d = d.fromTwos(8 * this.size).toTwos(8 * o.wordSize)), o.writeValue(d)
            }

            decode(o) {
                let u = o.readValue().mask(8 * this.size);
                return this.signed && (u = u.fromTwos(8 * this.size)), o.coerce(this.name, u)
            }
        }

        var I = R(3544);

        class l extends Ce {
            constructor(o) {
                super("string", o)
            }

            defaultValue() {
                return ""
            }

            encode(o, u) {
                return super.encode(o, (0, I.Y0)(u))
            }

            decode(o) {
                return (0, I.ZN)(super.decode(o))
            }
        }

        class f extends ae {
            constructor(o, u) {
                let d = !1;
                const C = [];
                o.forEach(se => {
                    se.dynamic && (d = !0), C.push(se.type)
                }), super("tuple", "tuple(" + C.join(",") + ")", u, d), this.coders = o
            }

            defaultValue() {
                const o = [];
                this.coders.forEach(d => {
                    o.push(d.defaultValue())
                });
                const u = this.coders.reduce((d, C) => {
                    const ee = C.localName;
                    return ee && (d[ee] || (d[ee] = 0), d[ee]++), d
                }, {});
                return this.coders.forEach((d, C) => {
                    let ee = d.localName;
                    !ee || 1 !== u[ee] || ("length" === ee && (ee = "_length"), null == o[ee] && (o[ee] = o[C]))
                }), Object.freeze(o)
            }

            encode(o, u) {
                return xe(o, this.coders, u)
            }

            decode(o) {
                return o.coerce(this.name, Ue(o, this.coders))
            }
        }

        const g = new Q.Yd(Ne), v = {};
        let w = {calldata: !0, memory: !0, storage: !0}, P = {calldata: !0, memory: !0};

        function B(N, o) {
            if ("bytes" === N || "string" === N) {
                if (w[o]) return !0
            } else if ("address" === N) {
                if ("payable" === o) return !0
            } else if ((N.indexOf("[") >= 0 || "tuple" === N) && P[o]) return !0;
            return (w[o] || "payable" === o) && g.throwArgumentError("invalid modifier", "name", o), !1
        }

        function E(N, o) {
            for (let u in o) (0, W.zG)(N, u, o[u])
        }

        const Z = Object.freeze({sighash: "sighash", minimal: "minimal", full: "full", json: "json"}),
            ze = new RegExp(/^(.*)\[([0-9]*)\]$/);

        class Je {
            constructor(o, u) {
                o !== v && g.throwError("use fromString", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new ParamType()"}), E(this, u);
                let d = this.type.match(ze);
                E(this, d ? {
                    arrayLength: parseInt(d[2] || "-1"),
                    arrayChildren: Je.fromObject({type: d[1], components: this.components}),
                    baseType: "array"
                } : {
                    arrayLength: null,
                    arrayChildren: null,
                    baseType: null != this.components ? "tuple" : this.type
                }), this._isParamType = !0, Object.freeze(this)
            }

            format(o) {
                if (o || (o = Z.sighash), Z[o] || g.throwArgumentError("invalid format type", "format", o), o === Z.json) {
                    let d = {type: "tuple" === this.baseType ? "tuple" : this.type, name: this.name || void 0};
                    return "boolean" == typeof this.indexed && (d.indexed = this.indexed), this.components && (d.components = this.components.map(C => JSON.parse(C.format(o)))), JSON.stringify(d)
                }
                let u = "";
                return "array" === this.baseType ? (u += this.arrayChildren.format(o), u += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (o !== Z.sighash && (u += this.type), u += "(" + this.components.map(d => d.format(o)).join(o === Z.full ? ", " : ",") + ")") : u += this.type, o !== Z.sighash && (!0 === this.indexed && (u += " indexed"), o === Z.full && this.name && (u += " " + this.name)), u
            }

            static from(o, u) {
                return "string" == typeof o ? Je.fromString(o, u) : Je.fromObject(o)
            }

            static fromObject(o) {
                return Je.isParamType(o) ? o : new Je(v, {
                    name: o.name || null,
                    type: xn(o.type),
                    indexed: null == o.indexed ? null : !!o.indexed,
                    components: o.components ? o.components.map(Je.fromObject) : null
                })
            }

            static fromString(o, u) {
                return function d(C) {
                    return Je.fromObject({name: C.name, type: C.type, indexed: C.indexed, components: C.components})
                }(function O(N, o) {
                    let u = N;

                    function d(ct) {
                        g.throwArgumentError(`unexpected character at position ${ct}`, "param", N)
                    }

                    function C(ct) {
                        let xt = {type: "", name: "", parent: ct, state: {allowType: !0}};
                        return o && (xt.indexed = !1), xt
                    }

                    N = N.replace(/\s/g, " ");
                    let ee = {type: "", name: "", state: {allowType: !0}}, se = ee;
                    for (let ct = 0; ct < N.length; ct++) {
                        let xt = N[ct];
                        switch (xt) {
                            case"(":
                                se.state.allowType && "" === se.type ? se.type = "tuple" : se.state.allowParams || d(ct), se.state.allowType = !1, se.type = xn(se.type), se.components = [C(se)], se = se.components[0];
                                break;
                            case")":
                                delete se.state, "indexed" === se.name && (o || d(ct), se.indexed = !0, se.name = ""), B(se.type, se.name) && (se.name = ""), se.type = xn(se.type);
                                let st = se;
                                se = se.parent, se || d(ct), delete st.parent, se.state.allowParams = !1, se.state.allowName = !0, se.state.allowArray = !0;
                                break;
                            case",":
                                delete se.state, "indexed" === se.name && (o || d(ct), se.indexed = !0, se.name = ""), B(se.type, se.name) && (se.name = ""), se.type = xn(se.type);
                                let Vt = C(se.parent);
                                se.parent.components.push(Vt), delete se.parent, se = Vt;
                                break;
                            case" ":
                                se.state.allowType && "" !== se.type && (se.type = xn(se.type), delete se.state.allowType, se.state.allowName = !0, se.state.allowParams = !0), se.state.allowName && "" !== se.name && ("indexed" === se.name ? (o || d(ct), se.indexed && d(ct), se.indexed = !0, se.name = "") : B(se.type, se.name) ? se.name = "" : se.state.allowName = !1);
                                break;
                            case"[":
                                se.state.allowArray || d(ct), se.type += xt, se.state.allowArray = !1, se.state.allowName = !1, se.state.readArray = !0;
                                break;
                            case"]":
                                se.state.readArray || d(ct), se.type += xt, se.state.readArray = !1, se.state.allowArray = !0, se.state.allowName = !0;
                                break;
                            default:
                                se.state.allowType ? (se.type += xt, se.state.allowParams = !0, se.state.allowArray = !0) : se.state.allowName ? (se.name += xt, delete se.state.allowArray) : se.state.readArray ? se.type += xt : d(ct)
                        }
                    }
                    return se.parent && g.throwArgumentError("unexpected eof", "param", N), delete ee.state, "indexed" === se.name ? (o || d(u.length - 7), se.indexed && d(u.length - 7), se.indexed = !0, se.name = "") : B(se.type, se.name) && (se.name = ""), ee.type = xn(ee.type), ee
                }(o, !!u))
            }

            static isParamType(o) {
                return !(null == o || !o._isParamType)
            }
        }

        function q(N, o) {
            return function On(N) {
                N = N.trim();
                let o = [], u = "", d = 0;
                for (let C = 0; C < N.length; C++) {
                    let ee = N[C];
                    "," === ee && 0 === d ? (o.push(u), u = "") : (u += ee, "(" === ee ? d++ : ")" === ee && (d--, -1 === d && g.throwArgumentError("unbalanced parenthesis", "value", N)))
                }
                return u && o.push(u), o
            }(N).map(u => Je.fromString(u, o))
        }

        class Le {
            constructor(o, u) {
                o !== v && g.throwError("use a static from method", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new Fragment()"}), E(this, u), this._isFragment = !0, Object.freeze(this)
            }

            static from(o) {
                return Le.isFragment(o) ? o : "string" == typeof o ? Le.fromString(o) : Le.fromObject(o)
            }

            static fromObject(o) {
                if (Le.isFragment(o)) return o;
                switch (o.type) {
                    case"function":
                        return Gt.fromObject(o);
                    case"event":
                        return ut.fromObject(o);
                    case"constructor":
                        return Pt.fromObject(o);
                    case"error":
                        return Xt.fromObject(o);
                    case"fallback":
                    case"receive":
                        return null
                }
                return g.throwArgumentError("invalid fragment object", "value", o)
            }

            static fromString(o) {
                return "event" === (o = (o = (o = o.replace(/\s/g, " ")).replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")).trim()).split(" ")[0] ? ut.fromString(o.substring(5).trim()) : "function" === o.split(" ")[0] ? Gt.fromString(o.substring(8).trim()) : "constructor" === o.split("(")[0].trim() ? Pt.fromString(o.trim()) : "error" === o.split(" ")[0] ? Xt.fromString(o.substring(5).trim()) : g.throwArgumentError("unsupported fragment", "value", o)
            }

            static isFragment(o) {
                return !(!o || !o._isFragment)
            }
        }

        class ut extends Le {
            format(o) {
                if (o || (o = Z.sighash), Z[o] || g.throwArgumentError("invalid format type", "format", o), o === Z.json) return JSON.stringify({
                    type: "event",
                    anonymous: this.anonymous,
                    name: this.name,
                    inputs: this.inputs.map(d => JSON.parse(d.format(o)))
                });
                let u = "";
                return o !== Z.sighash && (u += "event "), u += this.name + "(" + this.inputs.map(d => d.format(o)).join(o === Z.full ? ", " : ",") + ") ", o !== Z.sighash && this.anonymous && (u += "anonymous "), u.trim()
            }

            static from(o) {
                return "string" == typeof o ? ut.fromString(o) : ut.fromObject(o)
            }

            static fromObject(o) {
                if (ut.isEventFragment(o)) return o;
                "event" !== o.type && g.throwArgumentError("invalid event object", "value", o);
                const u = {
                    name: wn(o.name),
                    anonymous: o.anonymous,
                    inputs: o.inputs ? o.inputs.map(Je.fromObject) : [],
                    type: "event"
                };
                return new ut(v, u)
            }

            static fromString(o) {
                let u = o.match(Nn);
                u || g.throwArgumentError("invalid event string", "value", o);
                let d = !1;
                return u[3].split(" ").forEach(C => {
                    switch (C.trim()) {
                        case"anonymous":
                            d = !0;
                            break;
                        case"":
                            break;
                        default:
                            g.warn("unknown modifier: " + C)
                    }
                }), ut.fromObject({name: u[1].trim(), anonymous: d, inputs: q(u[2], !0), type: "event"})
            }

            static isEventFragment(o) {
                return o && o._isFragment && "event" === o.type
            }
        }

        function Ye(N, o) {
            o.gas = null;
            let u = N.split("@");
            return 1 !== u.length ? (u.length > 2 && g.throwArgumentError("invalid human-readable ABI signature", "value", N), u[1].match(/^[0-9]+$/) || g.throwArgumentError("invalid human-readable ABI signature gas", "value", N), o.gas = j.O$.from(u[1]), u[0]) : N
        }

        function Mt(N, o) {
            o.constant = !1, o.payable = !1, o.stateMutability = "nonpayable", N.split(" ").forEach(u => {
                switch (u.trim()) {
                    case"constant":
                        o.constant = !0;
                        break;
                    case"payable":
                        o.payable = !0, o.stateMutability = "payable";
                        break;
                    case"nonpayable":
                        o.payable = !1, o.stateMutability = "nonpayable";
                        break;
                    case"pure":
                        o.constant = !0, o.stateMutability = "pure";
                        break;
                    case"view":
                        o.constant = !0, o.stateMutability = "view";
                        break;
                    case"external":
                    case"public":
                    case"":
                        break;
                    default:
                        console.log("unknown modifier: " + u)
                }
            })
        }

        function _t(N) {
            let o = {constant: !1, payable: !0, stateMutability: "payable"};
            return null != N.stateMutability ? (o.stateMutability = N.stateMutability, o.constant = "view" === o.stateMutability || "pure" === o.stateMutability, null != N.constant && !!N.constant !== o.constant && g.throwArgumentError("cannot have constant function with mutability " + o.stateMutability, "value", N), o.payable = "payable" === o.stateMutability, null != N.payable && !!N.payable !== o.payable && g.throwArgumentError("cannot have payable function with mutability " + o.stateMutability, "value", N)) : null != N.payable ? (o.payable = !!N.payable, null == N.constant && !o.payable && "constructor" !== N.type && g.throwArgumentError("unable to determine stateMutability", "value", N), o.constant = !!N.constant, o.stateMutability = o.constant ? "view" : o.payable ? "payable" : "nonpayable", o.payable && o.constant && g.throwArgumentError("cannot have constant payable function", "value", N)) : null != N.constant ? (o.constant = !!N.constant, o.payable = !o.constant, o.stateMutability = o.constant ? "view" : "payable") : "constructor" !== N.type && g.throwArgumentError("unable to determine stateMutability", "value", N), o
        }

        class Pt extends Le {
            format(o) {
                if (o || (o = Z.sighash), Z[o] || g.throwArgumentError("invalid format type", "format", o), o === Z.json) return JSON.stringify({
                    type: "constructor",
                    stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                    payable: this.payable,
                    gas: this.gas ? this.gas.toNumber() : void 0,
                    inputs: this.inputs.map(d => JSON.parse(d.format(o)))
                });
                o === Z.sighash && g.throwError("cannot format a constructor for sighash", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "format(sighash)"});
                let u = "constructor(" + this.inputs.map(d => d.format(o)).join(o === Z.full ? ", " : ",") + ") ";
                return this.stateMutability && "nonpayable" !== this.stateMutability && (u += this.stateMutability + " "), u.trim()
            }

            static from(o) {
                return "string" == typeof o ? Pt.fromString(o) : Pt.fromObject(o)
            }

            static fromObject(o) {
                if (Pt.isConstructorFragment(o)) return o;
                "constructor" !== o.type && g.throwArgumentError("invalid constructor object", "value", o);
                let u = _t(o);
                u.constant && g.throwArgumentError("constructor cannot be constant", "value", o);
                const d = {
                    name: null,
                    type: o.type,
                    inputs: o.inputs ? o.inputs.map(Je.fromObject) : [],
                    payable: u.payable,
                    stateMutability: u.stateMutability,
                    gas: o.gas ? j.O$.from(o.gas) : null
                };
                return new Pt(v, d)
            }

            static fromString(o) {
                let u = {type: "constructor"}, d = (o = Ye(o, u)).match(Nn);
                return (!d || "constructor" !== d[1].trim()) && g.throwArgumentError("invalid constructor string", "value", o), u.inputs = q(d[2].trim(), !1), Mt(d[3].trim(), u), Pt.fromObject(u)
            }

            static isConstructorFragment(o) {
                return o && o._isFragment && "constructor" === o.type
            }
        }

        class Gt extends Pt {
            format(o) {
                if (o || (o = Z.sighash), Z[o] || g.throwArgumentError("invalid format type", "format", o), o === Z.json) return JSON.stringify({
                    type: "function",
                    name: this.name,
                    constant: this.constant,
                    stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                    payable: this.payable,
                    gas: this.gas ? this.gas.toNumber() : void 0,
                    inputs: this.inputs.map(d => JSON.parse(d.format(o))),
                    outputs: this.outputs.map(d => JSON.parse(d.format(o)))
                });
                let u = "";
                return o !== Z.sighash && (u += "function "), u += this.name + "(" + this.inputs.map(d => d.format(o)).join(o === Z.full ? ", " : ",") + ") ", o !== Z.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (u += this.stateMutability + " ") : this.constant && (u += "view "), this.outputs && this.outputs.length && (u += "returns (" + this.outputs.map(d => d.format(o)).join(", ") + ") "), null != this.gas && (u += "@" + this.gas.toString() + " ")), u.trim()
            }

            static from(o) {
                return "string" == typeof o ? Gt.fromString(o) : Gt.fromObject(o)
            }

            static fromObject(o) {
                if (Gt.isFunctionFragment(o)) return o;
                "function" !== o.type && g.throwArgumentError("invalid function object", "value", o);
                let u = _t(o);
                const d = {
                    type: o.type,
                    name: wn(o.name),
                    constant: u.constant,
                    inputs: o.inputs ? o.inputs.map(Je.fromObject) : [],
                    outputs: o.outputs ? o.outputs.map(Je.fromObject) : [],
                    payable: u.payable,
                    stateMutability: u.stateMutability,
                    gas: o.gas ? j.O$.from(o.gas) : null
                };
                return new Gt(v, d)
            }

            static fromString(o) {
                let u = {type: "function"}, d = (o = Ye(o, u)).split(" returns ");
                d.length > 2 && g.throwArgumentError("invalid function string", "value", o);
                let C = d[0].match(Nn);
                if (C || g.throwArgumentError("invalid function signature", "value", o), u.name = C[1].trim(), u.name && wn(u.name), u.inputs = q(C[2], !1), Mt(C[3].trim(), u), d.length > 1) {
                    let ee = d[1].match(Nn);
                    ("" != ee[1].trim() || "" != ee[3].trim()) && g.throwArgumentError("unexpected tokens", "value", o), u.outputs = q(ee[2], !1)
                } else u.outputs = [];
                return Gt.fromObject(u)
            }

            static isFunctionFragment(o) {
                return o && o._isFragment && "function" === o.type
            }
        }

        function yn(N) {
            const o = N.format();
            return ("Error(string)" === o || "Panic(uint256)" === o) && g.throwArgumentError(`cannot specify user defined ${o} error`, "fragment", N), N
        }

        class Xt extends Le {
            format(o) {
                if (o || (o = Z.sighash), Z[o] || g.throwArgumentError("invalid format type", "format", o), o === Z.json) return JSON.stringify({
                    type: "error",
                    name: this.name,
                    inputs: this.inputs.map(d => JSON.parse(d.format(o)))
                });
                let u = "";
                return o !== Z.sighash && (u += "error "), u += this.name + "(" + this.inputs.map(d => d.format(o)).join(o === Z.full ? ", " : ",") + ") ", u.trim()
            }

            static from(o) {
                return "string" == typeof o ? Xt.fromString(o) : Xt.fromObject(o)
            }

            static fromObject(o) {
                if (Xt.isErrorFragment(o)) return o;
                "error" !== o.type && g.throwArgumentError("invalid error object", "value", o);
                const u = {type: o.type, name: wn(o.name), inputs: o.inputs ? o.inputs.map(Je.fromObject) : []};
                return yn(new Xt(v, u))
            }

            static fromString(o) {
                let u = {type: "error"}, d = o.match(Nn);
                return d || g.throwArgumentError("invalid error signature", "value", o), u.name = d[1].trim(), u.name && wn(u.name), u.inputs = q(d[2], !1), yn(Xt.fromObject(u))
            }

            static isErrorFragment(o) {
                return o && o._isFragment && "error" === o.type
            }
        }

        function xn(N) {
            return N.match(/^uint($|[^1-9])/) ? N = "uint256" + N.substring(4) : N.match(/^int($|[^1-9])/) && (N = "int256" + N.substring(3)), N
        }

        const Fn = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

        function wn(N) {
            return (!N || !N.match(Fn)) && g.throwArgumentError(`invalid identifier "${N}"`, "value", N), N
        }

        const Nn = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$"), Me = new Q.Yd(Ne), ne = new RegExp(/^bytes([0-9]*)$/),
            U = new RegExp(/^(u?int)([0-9]*)$/), Ze = new class de {
                constructor(o) {
                    (0, W.zG)(this, "coerceFunc", o || null)
                }

                _getCoder(o) {
                    switch (o.baseType) {
                        case"address":
                            return new ge(o.name);
                        case"bool":
                            return new yt(o.name);
                        case"string":
                            return new l(o.name);
                        case"bytes":
                            return new $e(o.name);
                        case"array":
                            return new it(this._getCoder(o.arrayChildren), o.arrayLength, o.name);
                        case"tuple":
                            return new f((o.components || []).map(d => this._getCoder(d)), o.name);
                        case"":
                            return new Xe(o.name)
                    }
                    let u = o.type.match(U);
                    if (u) {
                        let d = parseInt(u[2] || "256");
                        return (0 === d || d > 256 || d % 8 != 0) && Me.throwArgumentError("invalid " + u[1] + " bit length", "param", o), new ce(d / 8, "int" === u[1], o.name)
                    }
                    if (u = o.type.match(ne), u) {
                        let d = parseInt(u[1]);
                        return (0 === d || d > 32) && Me.throwArgumentError("invalid bytes length", "param", o), new rt(d, o.name)
                    }
                    return Me.throwArgumentError("invalid type", "type", o.type)
                }

                _getWordSize() {
                    return 32
                }

                _getReader(o, u) {
                    return new M(o, this._getWordSize(), this.coerceFunc, u)
                }

                _getWriter() {
                    return new X(this._getWordSize())
                }

                getDefaultValue(o) {
                    const u = o.map(C => this._getCoder(Je.from(C)));
                    return new f(u, "_").defaultValue()
                }

                encode(o, u) {
                    o.length !== u.length && Me.throwError("types/values length mismatch", Q.Yd.errors.INVALID_ARGUMENT, {
                        count: {
                            types: o.length,
                            values: u.length
                        }, value: {types: o, values: u}
                    });
                    const d = o.map(se => this._getCoder(Je.from(se))), C = new f(d, "_"), ee = this._getWriter();
                    return C.encode(ee, u), ee.data
                }

                decode(o, u, d) {
                    const C = o.map(se => this._getCoder(Je.from(se)));
                    return new f(C, "_").decode(this._getReader((0, te.lE)(u), d))
                }
            }, Ge = new Q.Yd(Ne);

        class ye extends W.dk {
        }

        class Te extends W.dk {
        }

        class Be extends W.dk {
        }

        class tt extends W.dk {
            static isIndexed(o) {
                return !(!o || !o._isIndexed)
            }
        }

        const Dt = {
            "0x08c379a0": {signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0},
            "0x4e487b71": {signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"]}
        };

        function Ft(N, o) {
            const u = new Error(`deferred error during ABI decoding triggered accessing ${N}`);
            return u.error = o, u
        }

        class zt {
            constructor(o) {
                let u = [];
                u = "string" == typeof o ? JSON.parse(o) : o, (0, W.zG)(this, "fragments", u.map(d => Le.from(d)).filter(d => null != d)), (0, W.zG)(this, "_abiCoder", (0, W.tu)(new.target, "getAbiCoder")()), (0, W.zG)(this, "functions", {}), (0, W.zG)(this, "errors", {}), (0, W.zG)(this, "events", {}), (0, W.zG)(this, "structs", {}), this.fragments.forEach(d => {
                    let C = null;
                    switch (d.type) {
                        case"constructor":
                            return this.deploy ? void Ge.warn("duplicate definition - constructor") : void (0, W.zG)(this, "deploy", d);
                        case"function":
                            C = this.functions;
                            break;
                        case"event":
                            C = this.events;
                            break;
                        case"error":
                            C = this.errors;
                            break;
                        default:
                            return
                    }
                    let ee = d.format();
                    C[ee] ? Ge.warn("duplicate definition - " + ee) : C[ee] = d
                }), this.deploy || (0, W.zG)(this, "deploy", Pt.from({
                    payable: !1,
                    type: "constructor"
                })), (0, W.zG)(this, "_isInterface", !0)
            }

            format(o) {
                o || (o = Z.full), o === Z.sighash && Ge.throwArgumentError("interface does not support formatting sighash", "format", o);
                const u = this.fragments.map(d => d.format(o));
                return o === Z.json ? JSON.stringify(u.map(d => JSON.parse(d))) : u
            }

            static getAbiCoder() {
                return Ze
            }

            static getAddress(o) {
                return (0, H.Kn)(o)
            }

            static getSighash(o) {
                return (0, te.p3)((0, F.id)(o.format()), 0, 4)
            }

            static getEventTopic(o) {
                return (0, F.id)(o.format())
            }

            getFunction(o) {
                if ((0, te.A7)(o)) {
                    for (const d in this.functions) if (o === this.getSighash(d)) return this.functions[d];
                    Ge.throwArgumentError("no matching function", "sighash", o)
                }
                if (-1 === o.indexOf("(")) {
                    const d = o.trim(), C = Object.keys(this.functions).filter(ee => ee.split("(")[0] === d);
                    return 0 === C.length ? Ge.throwArgumentError("no matching function", "name", d) : C.length > 1 && Ge.throwArgumentError("multiple matching functions", "name", d), this.functions[C[0]]
                }
                const u = this.functions[Gt.fromString(o).format()];
                return u || Ge.throwArgumentError("no matching function", "signature", o), u
            }

            getEvent(o) {
                if ((0, te.A7)(o)) {
                    const d = o.toLowerCase();
                    for (const C in this.events) if (d === this.getEventTopic(C)) return this.events[C];
                    Ge.throwArgumentError("no matching event", "topichash", d)
                }
                if (-1 === o.indexOf("(")) {
                    const d = o.trim(), C = Object.keys(this.events).filter(ee => ee.split("(")[0] === d);
                    return 0 === C.length ? Ge.throwArgumentError("no matching event", "name", d) : C.length > 1 && Ge.throwArgumentError("multiple matching events", "name", d), this.events[C[0]]
                }
                const u = this.events[ut.fromString(o).format()];
                return u || Ge.throwArgumentError("no matching event", "signature", o), u
            }

            getError(o) {
                if ((0, te.A7)(o)) {
                    const d = (0, W.tu)(this.constructor, "getSighash");
                    for (const C in this.errors) if (o === d(this.errors[C])) return this.errors[C];
                    Ge.throwArgumentError("no matching error", "sighash", o)
                }
                if (-1 === o.indexOf("(")) {
                    const d = o.trim(), C = Object.keys(this.errors).filter(ee => ee.split("(")[0] === d);
                    return 0 === C.length ? Ge.throwArgumentError("no matching error", "name", d) : C.length > 1 && Ge.throwArgumentError("multiple matching errors", "name", d), this.errors[C[0]]
                }
                const u = this.errors[Gt.fromString(o).format()];
                return u || Ge.throwArgumentError("no matching error", "signature", o), u
            }

            getSighash(o) {
                if ("string" == typeof o) try {
                    o = this.getFunction(o)
                } catch (u) {
                    try {
                        o = this.getError(o)
                    } catch (d) {
                        throw u
                    }
                }
                return (0, W.tu)(this.constructor, "getSighash")(o)
            }

            getEventTopic(o) {
                return "string" == typeof o && (o = this.getEvent(o)), (0, W.tu)(this.constructor, "getEventTopic")(o)
            }

            _decodeParams(o, u) {
                return this._abiCoder.decode(o, u)
            }

            _encodeParams(o, u) {
                return this._abiCoder.encode(o, u)
            }

            encodeDeploy(o) {
                return this._encodeParams(this.deploy.inputs, o || [])
            }

            decodeErrorResult(o, u) {
                "string" == typeof o && (o = this.getError(o));
                const d = (0, te.lE)(u);
                return (0, te.Dv)(d.slice(0, 4)) !== this.getSighash(o) && Ge.throwArgumentError(`data signature does not match error ${o.name}.`, "data", (0, te.Dv)(d)), this._decodeParams(o.inputs, d.slice(4))
            }

            encodeErrorResult(o, u) {
                return "string" == typeof o && (o = this.getError(o)), (0, te.Dv)((0, te.zo)([this.getSighash(o), this._encodeParams(o.inputs, u || [])]))
            }

            decodeFunctionData(o, u) {
                "string" == typeof o && (o = this.getFunction(o));
                const d = (0, te.lE)(u);
                return (0, te.Dv)(d.slice(0, 4)) !== this.getSighash(o) && Ge.throwArgumentError(`data signature does not match function ${o.name}.`, "data", (0, te.Dv)(d)), this._decodeParams(o.inputs, d.slice(4))
            }

            encodeFunctionData(o, u) {
                return "string" == typeof o && (o = this.getFunction(o)), (0, te.Dv)((0, te.zo)([this.getSighash(o), this._encodeParams(o.inputs, u || [])]))
            }

            decodeFunctionResult(o, u) {
                "string" == typeof o && (o = this.getFunction(o));
                let d = (0, te.lE)(u), C = null, ee = "", se = null, ct = null, xt = null;
                switch (d.length % this._abiCoder._getWordSize()) {
                    case 0:
                        try {
                            return this._abiCoder.decode(o.outputs, d)
                        } catch (st) {
                        }
                        break;
                    case 4: {
                        const st = (0, te.Dv)(d.slice(0, 4)), Vt = Dt[st];
                        if (Vt) se = this._abiCoder.decode(Vt.inputs, d.slice(4)), ct = Vt.name, xt = Vt.signature, Vt.reason && (C = se[0]), "Error" === ct ? ee = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(se[0])}` : "Panic" === ct && (ee = `; VM Exception while processing transaction: reverted with panic code ${se[0]}`); else try {
                            const Wt = this.getError(st);
                            se = this._abiCoder.decode(Wt.inputs, d.slice(4)), ct = Wt.name, xt = Wt.format()
                        } catch (Wt) {
                        }
                        break
                    }
                }
                return Ge.throwError("call revert exception" + ee, Q.Yd.errors.CALL_EXCEPTION, {
                    method: o.format(),
                    data: (0, te.Dv)(u),
                    errorArgs: se,
                    errorName: ct,
                    errorSignature: xt,
                    reason: C
                })
            }

            encodeFunctionResult(o, u) {
                return "string" == typeof o && (o = this.getFunction(o)), (0, te.Dv)(this._abiCoder.encode(o.outputs, u || []))
            }

            encodeFilterTopics(o, u) {
                "string" == typeof o && (o = this.getEvent(o)), u.length > o.inputs.length && Ge.throwError("too many arguments for " + o.format(), Q.Yd.errors.UNEXPECTED_ARGUMENT, {
                    argument: "values",
                    value: u
                });
                let d = [];
                o.anonymous || d.push(this.getEventTopic(o));
                const C = (ee, se) => "string" === ee.type ? (0, F.id)(se) : "bytes" === ee.type ? (0, oe.w)((0, te.Dv)(se)) : ("bool" === ee.type && "boolean" == typeof se && (se = se ? "0x01" : "0x00"), ee.type.match(/^u?int/) && (se = j.O$.from(se).toHexString()), "address" === ee.type && this._abiCoder.encode(["address"], [se]), (0, te.$m)((0, te.Dv)(se), 32));
                for (u.forEach((ee, se) => {
                    let ct = o.inputs[se];
                    ct.indexed ? null == ee ? d.push(null) : "array" === ct.baseType || "tuple" === ct.baseType ? Ge.throwArgumentError("filtering with tuples or arrays not supported", "contract." + ct.name, ee) : Array.isArray(ee) ? d.push(ee.map(xt => C(ct, xt))) : d.push(C(ct, ee)) : null != ee && Ge.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + ct.name, ee)
                }); d.length && null === d[d.length - 1];) d.pop();
                return d
            }

            encodeEventLog(o, u) {
                "string" == typeof o && (o = this.getEvent(o));
                const d = [], C = [], ee = [];
                return o.anonymous || d.push(this.getEventTopic(o)), u.length !== o.inputs.length && Ge.throwArgumentError("event arguments/values mismatch", "values", u), o.inputs.forEach((se, ct) => {
                    const xt = u[ct];
                    if (se.indexed) if ("string" === se.type) d.push((0, F.id)(xt)); else if ("bytes" === se.type) d.push((0, oe.w)(xt)); else {
                        if ("tuple" === se.baseType || "array" === se.baseType) throw new Error("not implemented");
                        d.push(this._abiCoder.encode([se.type], [xt]))
                    } else C.push(se), ee.push(xt)
                }), {data: this._abiCoder.encode(C, ee), topics: d}
            }

            decodeEventLog(o, u, d) {
                if ("string" == typeof o && (o = this.getEvent(o)), null != d && !o.anonymous) {
                    let pn = this.getEventTopic(o);
                    (!(0, te.A7)(d[0], 32) || d[0].toLowerCase() !== pn) && Ge.throwError("fragment/topic mismatch", Q.Yd.errors.INVALID_ARGUMENT, {
                        argument: "topics[0]",
                        expected: pn,
                        value: d[0]
                    }), d = d.slice(1)
                }
                let C = [], ee = [], se = [];
                o.inputs.forEach((pn, Ln) => {
                    pn.indexed ? "string" === pn.type || "bytes" === pn.type || "tuple" === pn.baseType || "array" === pn.baseType ? (C.push(Je.fromObject({
                        type: "bytes32",
                        name: pn.name
                    })), se.push(!0)) : (C.push(pn), se.push(!1)) : (ee.push(pn), se.push(!1))
                });
                let ct = null != d ? this._abiCoder.decode(C, (0, te.zo)(d)) : null,
                    xt = this._abiCoder.decode(ee, u, !0), st = [], Vt = 0, Wt = 0;
                o.inputs.forEach((pn, Ln) => {
                    if (pn.indexed) if (null == ct) st[Ln] = new tt({
                        _isIndexed: !0,
                        hash: null
                    }); else if (se[Ln]) st[Ln] = new tt({_isIndexed: !0, hash: ct[Wt++]}); else try {
                        st[Ln] = ct[Wt++]
                    } catch (er) {
                        st[Ln] = er
                    } else try {
                        st[Ln] = xt[Vt++]
                    } catch (er) {
                        st[Ln] = er
                    }
                    if (pn.name && null == st[pn.name]) {
                        const er = st[Ln];
                        er instanceof Error ? Object.defineProperty(st, pn.name, {
                            enumerable: !0, get: () => {
                                throw Ft(`property ${JSON.stringify(pn.name)}`, er)
                            }
                        }) : st[pn.name] = er
                    }
                });
                for (let pn = 0; pn < st.length; pn++) {
                    const Ln = st[pn];
                    Ln instanceof Error && Object.defineProperty(st, pn, {
                        enumerable: !0, get: () => {
                            throw Ft(`index ${pn}`, Ln)
                        }
                    })
                }
                return Object.freeze(st)
            }

            parseTransaction(o) {
                let u = this.getFunction(o.data.substring(0, 10).toLowerCase());
                return u ? new Te({
                    args: this._abiCoder.decode(u.inputs, "0x" + o.data.substring(10)),
                    functionFragment: u,
                    name: u.name,
                    signature: u.format(),
                    sighash: this.getSighash(u),
                    value: j.O$.from(o.value || "0")
                }) : null
            }

            parseLog(o) {
                let u = this.getEvent(o.topics[0]);
                return !u || u.anonymous ? null : new ye({
                    eventFragment: u,
                    name: u.name,
                    signature: u.format(),
                    topic: this.getEventTopic(u),
                    args: this.decodeEventLog(u, o.data, o.topics)
                })
            }

            parseError(o) {
                const u = (0, te.Dv)(o);
                let d = this.getError(u.substring(0, 10).toLowerCase());
                return d ? new Be({
                    args: this._abiCoder.decode(d.inputs, "0x" + u.substring(10)),
                    errorFragment: d,
                    name: d.name,
                    signature: d.format(),
                    sighash: this.getSighash(d)
                }) : null
            }

            static isInterface(o) {
                return !(!o || !o._isInterface)
            }
        }

        var dn = R(8314), Bt = R(2748), Ht = R(1474), fn = function (N, o, u, d) {
            return new (u || (u = Promise))(function (ee, se) {
                function ct(Vt) {
                    try {
                        st(d.next(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function xt(Vt) {
                    try {
                        st(d.throw(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function st(Vt) {
                    Vt.done ? ee(Vt.value) : function C(ee) {
                        return ee instanceof u ? ee : new u(function (se) {
                            se(ee)
                        })
                    }(Vt.value).then(ct, xt)
                }

                st((d = d.apply(N, o || [])).next())
            })
        };
        const rn = new Q.Yd("contracts/5.6.2");

        function Hn(N, o) {
            return fn(this, void 0, void 0, function* () {
                const u = yield o;
                "string" != typeof u && rn.throwArgumentError("invalid address or ENS name", "name", u);
                try {
                    return (0, H.Kn)(u)
                } catch (C) {
                }
                N || rn.throwError("a provider or signer is needed to resolve ENS names", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "resolveName"});
                const d = yield N.resolveName(u);
                return null == d && rn.throwArgumentError("resolver or addr is not configured for ENS name", "name", u), d
            })
        }

        function jn(N, o, u) {
            return fn(this, void 0, void 0, function* () {
                return Array.isArray(u) ? yield Promise.all(u.map((d, C) => jn(N, Array.isArray(o) ? o[C] : o[d.name], d))) : "address" === u.type ? yield Hn(N, o) : "tuple" === u.type ? yield jn(N, o, u.components) : "array" === u.baseType ? Array.isArray(o) ? yield Promise.all(o.map(d => jn(N, d, u.arrayChildren))) : Promise.reject(rn.makeError("invalid value for array", Q.Yd.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value: o
                })) : o
            })
        }

        function fr(N, o, u) {
            return fn(this, void 0, void 0, function* () {
                let d = {};
                u.length === o.inputs.length + 1 && "object" == typeof u[u.length - 1] && (d = (0, W.DC)(u.pop())), rn.checkArgumentCount(u.length, o.inputs.length, "passed to contract"), N.signer ? d.from = d.from ? (0, W.mE)({
                    override: Hn(N.signer, d.from),
                    signer: N.signer.getAddress()
                }).then(st => fn(this, void 0, void 0, function* () {
                    return (0, H.Kn)(st.signer) !== st.override && rn.throwError("Contract with a Signer cannot override from", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "overrides.from"}), st.override
                })) : N.signer.getAddress() : d.from && (d.from = Hn(N.provider, d.from));
                const C = yield(0, W.mE)({
                    args: jn(N.signer || N.provider, u, o.inputs),
                    address: N.resolvedAddress,
                    overrides: (0, W.mE)(d) || {}
                }), ee = N.interface.encodeFunctionData(o, C.args), se = {data: ee, to: C.address}, ct = C.overrides;
                if (null != ct.nonce && (se.nonce = j.O$.from(ct.nonce).toNumber()), null != ct.gasLimit && (se.gasLimit = j.O$.from(ct.gasLimit)), null != ct.gasPrice && (se.gasPrice = j.O$.from(ct.gasPrice)), null != ct.maxFeePerGas && (se.maxFeePerGas = j.O$.from(ct.maxFeePerGas)), null != ct.maxPriorityFeePerGas && (se.maxPriorityFeePerGas = j.O$.from(ct.maxPriorityFeePerGas)), null != ct.from && (se.from = ct.from), null != ct.type && (se.type = ct.type), null != ct.accessList && (se.accessList = (0, Ht.z7)(ct.accessList)), null == se.gasLimit && null != o.gas) {
                    let st = 21e3;
                    const Vt = (0, te.lE)(ee);
                    for (let Wt = 0; Wt < Vt.length; Wt++) st += 4, Vt[Wt] && (st += 64);
                    se.gasLimit = j.O$.from(o.gas).add(st)
                }
                if (ct.value) {
                    const st = j.O$.from(ct.value);
                    !st.isZero() && !o.payable && rn.throwError("non-payable method cannot override value", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: "overrides.value",
                        value: d.value
                    }), se.value = st
                }
                ct.customData && (se.customData = (0, W.DC)(ct.customData)), ct.ccipReadEnabled && (se.ccipReadEnabled = !!ct.ccipReadEnabled), delete d.nonce, delete d.gasLimit, delete d.gasPrice, delete d.from, delete d.value, delete d.type, delete d.accessList, delete d.maxFeePerGas, delete d.maxPriorityFeePerGas, delete d.customData, delete d.ccipReadEnabled;
                const xt = Object.keys(d).filter(st => null != d[st]);
                return xt.length && rn.throwError(`cannot override ${xt.map(st => JSON.stringify(st)).join(",")}`, Q.Yd.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides",
                    overrides: xt
                }), se
            })
        }

        function Wn(N, o, u) {
            const d = N.signer || N.provider;
            return function (...C) {
                return fn(this, void 0, void 0, function* () {
                    let ee;
                    if (C.length === o.inputs.length + 1 && "object" == typeof C[C.length - 1]) {
                        const xt = (0, W.DC)(C.pop());
                        null != xt.blockTag && (ee = yield xt.blockTag), delete xt.blockTag, C.push(xt)
                    }
                    null != N.deployTransaction && (yield N._deployed(ee));
                    const se = yield fr(N, o, C), ct = yield d.call(se, ee);
                    try {
                        let xt = N.interface.decodeFunctionResult(o, ct);
                        return u && 1 === o.outputs.length && (xt = xt[0]), xt
                    } catch (xt) {
                        throw xt.code === Q.Yd.errors.CALL_EXCEPTION && (xt.address = N.address, xt.args = C, xt.transaction = se), xt
                    }
                })
            }
        }

        function Dr(N, o, u) {
            return o.constant ? Wn(N, o, u) : function Xn(N, o) {
                return function (...u) {
                    return fn(this, void 0, void 0, function* () {
                        N.signer || rn.throwError("sending a transaction requires a signer", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "sendTransaction"}), null != N.deployTransaction && (yield N._deployed());
                        const d = yield fr(N, o, u), C = yield N.signer.sendTransaction(d);
                        return function Qn(N, o) {
                            const u = o.wait.bind(o);
                            o.wait = d => u(d).then(C => (C.events = C.logs.map(ee => {
                                let se = (0, W.p$)(ee), ct = null;
                                try {
                                    ct = N.interface.parseLog(ee)
                                } catch (xt) {
                                }
                                return ct && (se.args = ct.args, se.decode = (xt, st) => N.interface.decodeEventLog(ct.eventFragment, xt, st), se.event = ct.name, se.eventSignature = ct.signature), se.removeListener = () => N.provider, se.getBlock = () => N.provider.getBlock(C.blockHash), se.getTransaction = () => N.provider.getTransaction(C.transactionHash), se.getTransactionReceipt = () => Promise.resolve(C), se
                            }), C))
                        }(N, C), C
                    })
                }
            }(N, o)
        }

        function It(N) {
            return !N.address || null != N.topics && 0 !== N.topics.length ? (N.address || "*") + "@" + (N.topics ? N.topics.map(o => Array.isArray(o) ? o.join("|") : o).join(":") : "") : "*"
        }

        class vt {
            constructor(o, u) {
                (0, W.zG)(this, "tag", o), (0, W.zG)(this, "filter", u), this._listeners = []
            }

            addListener(o, u) {
                this._listeners.push({listener: o, once: u})
            }

            removeListener(o) {
                let u = !1;
                this._listeners = this._listeners.filter(d => !(!u && d.listener === o && (u = !0, 1)))
            }

            removeAllListeners() {
                this._listeners = []
            }

            listeners() {
                return this._listeners.map(o => o.listener)
            }

            listenerCount() {
                return this._listeners.length
            }

            run(o) {
                const u = this.listenerCount();
                return this._listeners = this._listeners.filter(d => {
                    const C = o.slice();
                    return setTimeout(() => {
                        d.listener.apply(this, C)
                    }, 0), !d.once
                }), u
            }

            prepareEvent(o) {
            }

            getEmit(o) {
                return [o]
            }
        }

        class Qe extends vt {
            constructor() {
                super("error", null)
            }
        }

        class ht extends vt {
            constructor(o, u, d, C) {
                const ee = {address: o};
                let se = u.getEventTopic(d);
                C ? (se !== C[0] && rn.throwArgumentError("topic mismatch", "topics", C), ee.topics = C.slice()) : ee.topics = [se], super(It(ee), ee), (0, W.zG)(this, "address", o), (0, W.zG)(this, "interface", u), (0, W.zG)(this, "fragment", d)
            }

            prepareEvent(o) {
                super.prepareEvent(o), o.event = this.fragment.name, o.eventSignature = this.fragment.format(), o.decode = (u, d) => this.interface.decodeEventLog(this.fragment, u, d);
                try {
                    o.args = this.interface.decodeEventLog(this.fragment, o.data, o.topics)
                } catch (u) {
                    o.args = null, o.decodeError = u
                }
            }

            getEmit(o) {
                const u = function me(N) {
                    const o = [], u = function (d, C) {
                        if (Array.isArray(C)) for (let ee in C) {
                            const se = d.slice();
                            se.push(ee);
                            try {
                                u(se, C[ee])
                            } catch (ct) {
                                o.push({path: se, error: ct})
                            }
                        }
                    };
                    return u([], N), o
                }(o.args);
                if (u.length) throw u[0].error;
                const d = (o.args || []).slice();
                return d.push(o), d
            }
        }

        class jt extends vt {
            constructor(o, u) {
                super("*", {address: o}), (0, W.zG)(this, "address", o), (0, W.zG)(this, "interface", u)
            }

            prepareEvent(o) {
                super.prepareEvent(o);
                try {
                    const u = this.interface.parseLog(o);
                    o.event = u.name, o.eventSignature = u.signature, o.decode = (d, C) => this.interface.decodeEventLog(u.eventFragment, d, C), o.args = u.args
                } catch (u) {
                }
            }
        }

        class dt extends class gt {
            constructor(o, u, d) {
                (0, W.zG)(this, "interface", (0, W.tu)(new.target, "getInterface")(u)), null == d ? ((0, W.zG)(this, "provider", null), (0, W.zG)(this, "signer", null)) : Bt.E.isSigner(d) ? ((0, W.zG)(this, "provider", d.provider || null), (0, W.zG)(this, "signer", d)) : dn.zt.isProvider(d) ? ((0, W.zG)(this, "provider", d), (0, W.zG)(this, "signer", null)) : rn.throwArgumentError("invalid signer or provider", "signerOrProvider", d), (0, W.zG)(this, "callStatic", {}), (0, W.zG)(this, "estimateGas", {}), (0, W.zG)(this, "functions", {}), (0, W.zG)(this, "populateTransaction", {}), (0, W.zG)(this, "filters", {});
                {
                    const se = {};
                    Object.keys(this.interface.events).forEach(ct => {
                        const xt = this.interface.events[ct];
                        (0, W.zG)(this.filters, ct, (...st) => ({
                            address: this.address,
                            topics: this.interface.encodeFilterTopics(xt, st)
                        })), se[xt.name] || (se[xt.name] = []), se[xt.name].push(ct)
                    }), Object.keys(se).forEach(ct => {
                        const xt = se[ct];
                        1 === xt.length ? (0, W.zG)(this.filters, ct, this.filters[xt[0]]) : rn.warn(`Duplicate definition of ${ct} (${xt.join(", ")})`)
                    })
                }
                if ((0, W.zG)(this, "_runningEvents", {}), (0, W.zG)(this, "_wrappedEmits", {}), null == o && rn.throwArgumentError("invalid contract address or ENS name", "addressOrName", o), (0, W.zG)(this, "address", o), this.provider) (0, W.zG)(this, "resolvedAddress", Hn(this.provider, o)); else try {
                    (0, W.zG)(this, "resolvedAddress", Promise.resolve((0, H.Kn)(o)))
                } catch (se) {
                    rn.throwError("provider is required to use ENS name as contract address", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new Contract"})
                }
                this.resolvedAddress.catch(se => {
                });
                const C = {}, ee = {};
                Object.keys(this.interface.functions).forEach(se => {
                    const ct = this.interface.functions[se];
                    if (ee[se]) rn.warn(`Duplicate ABI entry for ${JSON.stringify(se)}`); else {
                        ee[se] = !0;
                        {
                            const xt = ct.name;
                            C[`%${xt}`] || (C[`%${xt}`] = []), C[`%${xt}`].push(se)
                        }
                        null == this[se] && (0, W.zG)(this, se, Dr(this, ct, !0)), null == this.functions[se] && (0, W.zG)(this.functions, se, Dr(this, ct, !1)), null == this.callStatic[se] && (0, W.zG)(this.callStatic, se, Wn(this, ct, !0)), null == this.populateTransaction[se] && (0, W.zG)(this.populateTransaction, se, function qn(N, o) {
                            return function (...u) {
                                return fr(N, o, u)
                            }
                        }(this, ct)), null == this.estimateGas[se] && (0, W.zG)(this.estimateGas, se, function Yn(N, o) {
                            const u = N.signer || N.provider;
                            return function (...d) {
                                return fn(this, void 0, void 0, function* () {
                                    u || rn.throwError("estimate require a provider or signer", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "estimateGas"});
                                    const C = yield fr(N, o, d);
                                    return yield u.estimateGas(C)
                                })
                            }
                        }(this, ct))
                    }
                }), Object.keys(C).forEach(se => {
                    const ct = C[se];
                    if (ct.length > 1) return;
                    se = se.substring(1);
                    const xt = ct[0];
                    try {
                        null == this[se] && (0, W.zG)(this, se, this[xt])
                    } catch (st) {
                    }
                    null == this.functions[se] && (0, W.zG)(this.functions, se, this.functions[xt]), null == this.callStatic[se] && (0, W.zG)(this.callStatic, se, this.callStatic[xt]), null == this.populateTransaction[se] && (0, W.zG)(this.populateTransaction, se, this.populateTransaction[xt]), null == this.estimateGas[se] && (0, W.zG)(this.estimateGas, se, this.estimateGas[xt])
                })
            }

            static getContractAddress(o) {
                return (0, H.CR)(o)
            }

            static getInterface(o) {
                return zt.isInterface(o) ? o : new zt(o)
            }

            deployed() {
                return this._deployed()
            }

            _deployed(o) {
                return this._deployedPromise || (this._deployedPromise = this.deployTransaction ? this.deployTransaction.wait().then(() => this) : this.provider.getCode(this.address, o).then(u => ("0x" === u && rn.throwError("contract not deployed", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: "getDeployed"
                }), this))), this._deployedPromise
            }

            fallback(o) {
                this.signer || rn.throwError("sending a transactions require a signer", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "sendTransaction(fallback)"});
                const u = (0, W.DC)(o || {});
                return ["from", "to"].forEach(function (d) {
                    null != u[d] && rn.throwError("cannot override " + d, Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: d})
                }), u.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(u))
            }

            connect(o) {
                "string" == typeof o && (o = new Bt.b(o, this.provider));
                const u = new this.constructor(this.address, this.interface, o);
                return this.deployTransaction && (0, W.zG)(u, "deployTransaction", this.deployTransaction), u
            }

            attach(o) {
                return new this.constructor(o, this.interface, this.signer || this.provider)
            }

            static isIndexed(o) {
                return tt.isIndexed(o)
            }

            _normalizeRunningEvent(o) {
                return this._runningEvents[o.tag] ? this._runningEvents[o.tag] : o
            }

            _getRunningEvent(o) {
                if ("string" == typeof o) {
                    if ("error" === o) return this._normalizeRunningEvent(new Qe);
                    if ("event" === o) return this._normalizeRunningEvent(new vt("event", null));
                    if ("*" === o) return this._normalizeRunningEvent(new jt(this.address, this.interface));
                    const u = this.interface.getEvent(o);
                    return this._normalizeRunningEvent(new ht(this.address, this.interface, u))
                }
                if (o.topics && o.topics.length > 0) {
                    try {
                        const d = o.topics[0];
                        if ("string" != typeof d) throw new Error("invalid topic");
                        const C = this.interface.getEvent(d);
                        return this._normalizeRunningEvent(new ht(this.address, this.interface, C, o.topics))
                    } catch (d) {
                    }
                    const u = {address: this.address, topics: o.topics};
                    return this._normalizeRunningEvent(new vt(It(u), u))
                }
                return this._normalizeRunningEvent(new jt(this.address, this.interface))
            }

            _checkRunningEvents(o) {
                if (0 === o.listenerCount()) {
                    delete this._runningEvents[o.tag];
                    const u = this._wrappedEmits[o.tag];
                    u && o.filter && (this.provider.off(o.filter, u), delete this._wrappedEmits[o.tag])
                }
            }

            _wrapEvent(o, u, d) {
                const C = (0, W.p$)(u);
                return C.removeListener = () => {
                    !d || (o.removeListener(d), this._checkRunningEvents(o))
                }, C.getBlock = () => this.provider.getBlock(u.blockHash), C.getTransaction = () => this.provider.getTransaction(u.transactionHash), C.getTransactionReceipt = () => this.provider.getTransactionReceipt(u.transactionHash), o.prepareEvent(C), C
            }

            _addEventListener(o, u, d) {
                if (this.provider || rn.throwError("events require a provider or a signer with a provider", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "once"}), o.addListener(u, d), this._runningEvents[o.tag] = o, !this._wrappedEmits[o.tag]) {
                    const C = ee => {
                        let se = this._wrapEvent(o, ee, u);
                        if (null == se.decodeError) try {
                            const ct = o.getEmit(se);
                            this.emit(o.filter, ...ct)
                        } catch (ct) {
                            se.decodeError = ct.error
                        }
                        null != o.filter && this.emit("event", se), null != se.decodeError && this.emit("error", se.decodeError, se)
                    };
                    this._wrappedEmits[o.tag] = C, null != o.filter && this.provider.on(o.filter, C)
                }
            }

            queryFilter(o, u, d) {
                const C = this._getRunningEvent(o), ee = (0, W.DC)(C.filter);
                return "string" == typeof u && (0, te.A7)(u, 32) ? (null != d && rn.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", d), ee.blockHash = u) : (ee.fromBlock = null != u ? u : 0, ee.toBlock = null != d ? d : "latest"), this.provider.getLogs(ee).then(se => se.map(ct => this._wrapEvent(C, ct, null)))
            }

            on(o, u) {
                return this._addEventListener(this._getRunningEvent(o), u, !1), this
            }

            once(o, u) {
                return this._addEventListener(this._getRunningEvent(o), u, !0), this
            }

            emit(o, ...u) {
                if (!this.provider) return !1;
                const d = this._getRunningEvent(o), C = d.run(u) > 0;
                return this._checkRunningEvents(d), C
            }

            listenerCount(o) {
                return this.provider ? null == o ? Object.keys(this._runningEvents).reduce((u, d) => u + this._runningEvents[d].listenerCount(), 0) : this._getRunningEvent(o).listenerCount() : 0
            }

            listeners(o) {
                if (!this.provider) return [];
                if (null == o) {
                    const u = [];
                    for (let d in this._runningEvents) this._runningEvents[d].listeners().forEach(C => {
                        u.push(C)
                    });
                    return u
                }
                return this._getRunningEvent(o).listeners()
            }

            removeAllListeners(o) {
                if (!this.provider) return this;
                if (null == o) {
                    for (const d in this._runningEvents) {
                        const C = this._runningEvents[d];
                        C.removeAllListeners(), this._checkRunningEvents(C)
                    }
                    return this
                }
                const u = this._getRunningEvent(o);
                return u.removeAllListeners(), this._checkRunningEvents(u), this
            }

            off(o, u) {
                if (!this.provider) return this;
                const d = this._getRunningEvent(o);
                return d.removeListener(u), this._checkRunningEvents(d), this
            }

            removeListener(o, u) {
                return this.off(o, u)
            }
        } {
        }

        var Ut = R(7883);
        const Qt = new Q.Yd(Ut.i), sn = {}, un = j.O$.from(0), Pn = j.O$.from(-1);

        function mn(N, o, u, d) {
            const C = {fault: o, operation: u};
            return void 0 !== d && (C.value = d), Qt.throwError(N, Q.Yd.errors.NUMERIC_FAULT, C)
        }

        let Mn = "0";
        for (; Mn.length < 256;) Mn += Mn;

        function an(N) {
            if ("number" != typeof N) try {
                N = j.O$.from(N).toNumber()
            } catch (o) {
            }
            return "number" == typeof N && N >= 0 && N <= 256 && !(N % 1) ? "1" + Mn.substring(0, N) : Qt.throwArgumentError("invalid decimal size", "decimals", N)
        }

        function En(N, o) {
            null == o && (o = 0);
            const u = an(o), d = (N = j.O$.from(N)).lt(un);
            d && (N = N.mul(Pn));
            let C = N.mod(u).toString();
            for (; C.length < u.length - 1;) C = "0" + C;
            C = C.match(/^([0-9]*[1-9]|0)(0*)/)[1];
            const ee = N.div(u).toString();
            return N = 1 === u.length ? ee : ee + "." + C, d && (N = "-" + N), N
        }

        function Sn(N, o) {
            null == o && (o = 0);
            const u = an(o);
            ("string" != typeof N || !N.match(/^-?[0-9.]+$/)) && Qt.throwArgumentError("invalid decimal value", "value", N);
            const d = "-" === N.substring(0, 1);
            d && (N = N.substring(1)), "." === N && Qt.throwArgumentError("missing value", "value", N);
            const C = N.split(".");
            C.length > 2 && Qt.throwArgumentError("too many decimal points", "value", N);
            let ee = C[0], se = C[1];
            for (ee || (ee = "0"), se || (se = "0"); "0" === se[se.length - 1];) se = se.substring(0, se.length - 1);
            for (se.length > u.length - 1 && mn("fractional component exceeds decimals", "underflow", "parseFixed"), "" === se && (se = "0"); se.length < u.length - 1;) se += "0";
            const ct = j.O$.from(ee), xt = j.O$.from(se);
            let st = ct.mul(u).add(xt);
            return d && (st = st.mul(Pn)), st
        }

        class ar {
            constructor(o, u, d, C) {
                o !== sn && Qt.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new FixedFormat"}), this.signed = u, this.width = d, this.decimals = C, this.name = (u ? "" : "u") + "fixed" + String(d) + "x" + String(C), this._multiplier = an(C), Object.freeze(this)
            }

            static from(o) {
                if (o instanceof ar) return o;
                "number" == typeof o && (o = `fixed128x${o}`);
                let u = !0, d = 128, C = 18;
                if ("string" == typeof o) {
                    if ("fixed" !== o) if ("ufixed" === o) u = !1; else {
                        const ee = o.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                        ee || Qt.throwArgumentError("invalid fixed format", "format", o), u = "u" !== ee[1], d = parseInt(ee[2]), C = parseInt(ee[3])
                    }
                } else if (o) {
                    const ee = (se, ct, xt) => null == o[se] ? xt : (typeof o[se] !== ct && Qt.throwArgumentError("invalid fixed format (" + se + " not " + ct + ")", "format." + se, o[se]), o[se]);
                    u = ee("signed", "boolean", u), d = ee("width", "number", d), C = ee("decimals", "number", C)
                }
                return d % 8 && Qt.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", d), C > 80 && Qt.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", C), new ar(sn, u, d, C)
            }
        }

        class Un {
            constructor(o, u, d, C) {
                o !== sn && Qt.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "new FixedFormat"}), this.format = C, this._hex = u, this._value = d, this._isFixedNumber = !0, Object.freeze(this)
            }

            _checkFormat(o) {
                this.format.name !== o.format.name && Qt.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", o)
            }

            addUnsafe(o) {
                this._checkFormat(o);
                const u = Sn(this._value, this.format.decimals), d = Sn(o._value, o.format.decimals);
                return Un.fromValue(u.add(d), this.format.decimals, this.format)
            }

            subUnsafe(o) {
                this._checkFormat(o);
                const u = Sn(this._value, this.format.decimals), d = Sn(o._value, o.format.decimals);
                return Un.fromValue(u.sub(d), this.format.decimals, this.format)
            }

            mulUnsafe(o) {
                this._checkFormat(o);
                const u = Sn(this._value, this.format.decimals), d = Sn(o._value, o.format.decimals);
                return Un.fromValue(u.mul(d).div(this.format._multiplier), this.format.decimals, this.format)
            }

            divUnsafe(o) {
                this._checkFormat(o);
                const u = Sn(this._value, this.format.decimals), d = Sn(o._value, o.format.decimals);
                return Un.fromValue(u.mul(this.format._multiplier).div(d), this.format.decimals, this.format)
            }

            floor() {
                const o = this.toString().split(".");
                1 === o.length && o.push("0");
                let u = Un.from(o[0], this.format);
                const d = !o[1].match(/^(0*)$/);
                return this.isNegative() && d && (u = u.subUnsafe(nn.toFormat(u.format))), u
            }

            ceiling() {
                const o = this.toString().split(".");
                1 === o.length && o.push("0");
                let u = Un.from(o[0], this.format);
                const d = !o[1].match(/^(0*)$/);
                return !this.isNegative() && d && (u = u.addUnsafe(nn.toFormat(u.format))), u
            }

            round(o) {
                null == o && (o = 0);
                const u = this.toString().split(".");
                if (1 === u.length && u.push("0"), (o < 0 || o > 80 || o % 1) && Qt.throwArgumentError("invalid decimal count", "decimals", o), u[1].length <= o) return this;
                const d = Un.from("1" + Mn.substring(0, o), this.format), C = _n.toFormat(this.format);
                return this.mulUnsafe(d).addUnsafe(C).floor().divUnsafe(d)
            }

            isZero() {
                return "0.0" === this._value || "0" === this._value
            }

            isNegative() {
                return "-" === this._value[0]
            }

            toString() {
                return this._value
            }

            toHexString(o) {
                if (null == o) return this._hex;
                o % 8 && Qt.throwArgumentError("invalid byte width", "width", o);
                const u = j.O$.from(this._hex).fromTwos(this.format.width).toTwos(o).toHexString();
                return (0, te.$m)(u, o / 8)
            }

            toUnsafeFloat() {
                return parseFloat(this.toString())
            }

            toFormat(o) {
                return Un.fromString(this._value, o)
            }

            static fromValue(o, u, d) {
                return null == d && null != u && !(0, j.Zm)(u) && (d = u, u = null), null == u && (u = 0), null == d && (d = "fixed"), Un.fromString(En(o, u), ar.from(d))
            }

            static fromString(o, u) {
                null == u && (u = "fixed");
                const d = ar.from(u), C = Sn(o, d.decimals);
                !d.signed && C.lt(un) && mn("unsigned value cannot be negative", "overflow", "value", o);
                let ee = null;
                d.signed ? ee = C.toTwos(d.width).toHexString() : (ee = C.toHexString(), ee = (0, te.$m)(ee, d.width / 8));
                const se = En(C, d.decimals);
                return new Un(sn, ee, se, d)
            }

            static fromBytes(o, u) {
                null == u && (u = "fixed");
                const d = ar.from(u);
                if ((0, te.lE)(o).length > d.width / 8) throw new Error("overflow");
                let C = j.O$.from(o);
                d.signed && (C = C.fromTwos(d.width));
                const ee = C.toTwos((d.signed ? 0 : 1) + d.width).toHexString(), se = En(C, d.decimals);
                return new Un(sn, ee, se, d)
            }

            static from(o, u) {
                if ("string" == typeof o) return Un.fromString(o, u);
                if ((0, te._t)(o)) return Un.fromBytes(o, u);
                try {
                    return Un.fromValue(o, 0, u)
                } catch (d) {
                    if (d.code !== Q.Yd.errors.INVALID_ARGUMENT) throw d
                }
                return Qt.throwArgumentError("invalid FixedNumber value", "value", o)
            }

            static isFixedNumber(o) {
                return !(!o || !o._isFixedNumber)
            }
        }

        const nn = Un.from(1), _n = Un.from("0.5"), nr = new Q.Yd("units/5.6.1"),
            Er = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        var $n = R(687);

        function Br(N) {
            N = atob(N);
            const o = [];
            for (let u = 0; u < N.length; u++) o.push(N.charCodeAt(u));
            return (0, te.lE)(o)
        }

        function _r(N) {
            N = (0, te.lE)(N);
            let o = "";
            for (let u = 0; u < N.length; u++) o += String.fromCharCode(N[u]);
            return btoa(o)
        }

        function Et(N, o) {
            return function (N, o, u, d) {
                return new (u || (u = Promise))(function (ee, se) {
                    function ct(Vt) {
                        try {
                            st(d.next(Vt))
                        } catch (Wt) {
                            se(Wt)
                        }
                    }

                    function xt(Vt) {
                        try {
                            st(d.throw(Vt))
                        } catch (Wt) {
                            se(Wt)
                        }
                    }

                    function st(Vt) {
                        Vt.done ? ee(Vt.value) : function C(ee) {
                            return ee instanceof u ? ee : new u(function (se) {
                                se(ee)
                            })
                        }(Vt.value).then(ct, xt)
                    }

                    st((d = d.apply(N, o || [])).next())
                })
            }(this, void 0, void 0, function* () {
                null == o && (o = {});
                const u = {method: o.method || "GET", headers: o.headers || {}, body: o.body || void 0};
                !0 !== o.skipFetchSetup && (u.mode = "cors", u.cache = "no-cache", u.credentials = "same-origin", u.redirect = "follow", u.referrer = "client");
                const d = yield fetch(N, u), C = yield d.arrayBuffer(), ee = {};
                return d.headers.forEach ? d.headers.forEach((se, ct) => {
                    ee[ct.toLowerCase()] = se
                }) : d.headers.keys().forEach(se => {
                    ee[se.toLowerCase()] = d.headers.get(se)
                }), {
                    headers: ee,
                    statusCode: d.status,
                    statusMessage: d.statusText,
                    body: (0, te.lE)(new Uint8Array(C))
                }
            })
        }

        const Ke = new Q.Yd("web/5.6.1");

        function at(N) {
            return new Promise(o => {
                setTimeout(o, N)
            })
        }

        function Ct(N, o) {
            if (null == N) return null;
            if ("string" == typeof N) return N;
            if ((0, te.Zq)(N)) {
                if (o && ("text" === o.split("/")[0] || "application/json" === o.split(";")[0].trim())) try {
                    return (0, I.ZN)(N)
                } catch (u) {
                }
                return (0, te.Dv)(N)
            }
            return N
        }

        function qt(N, o, u) {
            let C = null;
            if (null != o) {
                C = (0, I.Y0)(o);
                const ee = "string" == typeof N ? {url: N} : (0, W.DC)(N);
                ee.headers ? 0 !== Object.keys(ee.headers).filter(ct => "content-type" === ct.toLowerCase()).length || (ee.headers = (0, W.DC)(ee.headers), ee.headers["content-type"] = "application/json") : ee.headers = {"content-type": "application/json"}, N = ee
            }
            return function Kt(N, o, u) {
                const d = "object" == typeof N && null != N.throttleLimit ? N.throttleLimit : 12;
                Ke.assertArgument(d > 0 && d % 1 == 0, "invalid connection throttle limit", "connection.throttleLimit", d);
                const C = "object" == typeof N ? N.throttleCallback : null,
                    ee = "object" == typeof N && "number" == typeof N.throttleSlotInterval ? N.throttleSlotInterval : 100;
                Ke.assertArgument(ee > 0 && ee % 1 == 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", ee);
                const se = "object" == typeof N && !!N.errorPassThrough, ct = {};
                let xt = null;
                const st = {method: "GET"};
                let Vt = !1, Wt = 12e4;
                if ("string" == typeof N) xt = N; else if ("object" == typeof N) {
                    if ((null == N || null == N.url) && Ke.throwArgumentError("missing URL", "connection.url", N), xt = N.url, "number" == typeof N.timeout && N.timeout > 0 && (Wt = N.timeout), N.headers) for (const sr in N.headers) ct[sr.toLowerCase()] = {
                        key: sr,
                        value: String(N.headers[sr])
                    }, ["if-none-match", "if-modified-since"].indexOf(sr.toLowerCase()) >= 0 && (Vt = !0);
                    st.allowGzip = !!N.allowGzip, null != N.user && null != N.password && ("https:" !== xt.substring(0, 6) && !0 !== N.allowInsecureAuthentication && Ke.throwError("basic authentication requires a secure https url", Q.Yd.errors.INVALID_ARGUMENT, {
                        argument: "url",
                        url: xt,
                        user: N.user,
                        password: "[REDACTED]"
                    }), ct.authorization = {
                        key: "Authorization",
                        value: "Basic " + _r((0, I.Y0)(N.user + ":" + N.password))
                    }), null != N.skipFetchSetup && (st.skipFetchSetup = !!N.skipFetchSetup)
                }
                const pn = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"), Ln = xt ? xt.match(pn) : null;
                if (Ln) try {
                    const sr = {
                        statusCode: 200,
                        statusMessage: "OK",
                        headers: {"content-type": Ln[1]},
                        body: Br(Ln[2])
                    };
                    let ur = sr.body;
                    return u && (ur = u(sr.body, sr)), Promise.resolve(ur)
                } catch (sr) {
                    Ke.throwError("processing response error", Q.Yd.errors.SERVER_ERROR, {
                        body: Ct(Ln[1], Ln[2]),
                        error: sr,
                        requestBody: null,
                        requestMethod: "GET",
                        url: xt
                    })
                }
                o && (st.method = "POST", st.body = o, null == ct["content-type"] && (ct["content-type"] = {
                    key: "Content-Type",
                    value: "application/octet-stream"
                }), null == ct["content-length"] && (ct["content-length"] = {
                    key: "Content-Length",
                    value: String(o.length)
                }));
                const er = {};
                Object.keys(ct).forEach(sr => {
                    const ur = ct[sr];
                    er[ur.key] = ur.value
                }), st.headers = er;
                const kr = function () {
                    let sr = null;
                    return {
                        promise: new Promise(function (Ur, Yr) {
                            Wt && (sr = setTimeout(() => {
                                null != sr && (sr = null, Yr(Ke.makeError("timeout", Q.Yd.errors.TIMEOUT, {
                                    requestBody: Ct(st.body, er["content-type"]),
                                    requestMethod: st.method,
                                    timeout: Wt,
                                    url: xt
                                })))
                            }, Wt))
                        }), cancel: function () {
                            null != sr && (clearTimeout(sr), sr = null)
                        }
                    }
                }(), qr = function () {
                    return function (N, o, u, d) {
                        return new (u || (u = Promise))(function (ee, se) {
                            function ct(Vt) {
                                try {
                                    st(d.next(Vt))
                                } catch (Wt) {
                                    se(Wt)
                                }
                            }

                            function xt(Vt) {
                                try {
                                    st(d.throw(Vt))
                                } catch (Wt) {
                                    se(Wt)
                                }
                            }

                            function st(Vt) {
                                Vt.done ? ee(Vt.value) : function C(ee) {
                                    return ee instanceof u ? ee : new u(function (se) {
                                        se(ee)
                                    })
                                }(Vt.value).then(ct, xt)
                            }

                            st((d = d.apply(N, o || [])).next())
                        })
                    }(this, void 0, void 0, function* () {
                        for (let sr = 0; sr < d; sr++) {
                            let ur = null;
                            try {
                                if (ur = yield Et(xt, st), sr < d) if (301 === ur.statusCode || 302 === ur.statusCode) {
                                    const Ur = ur.headers.location || "";
                                    if ("GET" === st.method && Ur.match(/^https:/)) {
                                        xt = ur.headers.location;
                                        continue
                                    }
                                } else if (429 === ur.statusCode) {
                                    let Ur = !0;
                                    if (C && (Ur = yield C(sr, xt)), Ur) {
                                        let Yr = 0;
                                        const Ki = ur.headers["retry-after"];
                                        Yr = "string" == typeof Ki && Ki.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(Ki) : ee * parseInt(String(Math.random() * Math.pow(2, sr))), yield at(Yr);
                                        continue
                                    }
                                }
                            } catch (Ur) {
                                ur = Ur.response, null == ur && (kr.cancel(), Ke.throwError("missing response", Q.Yd.errors.SERVER_ERROR, {
                                    requestBody: Ct(st.body, er["content-type"]),
                                    requestMethod: st.method,
                                    serverError: Ur,
                                    url: xt
                                }))
                            }
                            let Rr = ur.body;
                            if (Vt && 304 === ur.statusCode ? Rr = null : !se && (ur.statusCode < 200 || ur.statusCode >= 300) && (kr.cancel(), Ke.throwError("bad response", Q.Yd.errors.SERVER_ERROR, {
                                status: ur.statusCode,
                                headers: ur.headers,
                                body: Ct(Rr, ur.headers ? ur.headers["content-type"] : null),
                                requestBody: Ct(st.body, er["content-type"]),
                                requestMethod: st.method,
                                url: xt
                            })), u) try {
                                const Ur = yield u(Rr, ur);
                                return kr.cancel(), Ur
                            } catch (Ur) {
                                if (Ur.throttleRetry && sr < d) {
                                    let Yr = !0;
                                    if (C && (Yr = yield C(sr, xt)), Yr) {
                                        const Ki = ee * parseInt(String(Math.random() * Math.pow(2, sr)));
                                        yield at(Ki);
                                        continue
                                    }
                                }
                                kr.cancel(), Ke.throwError("processing response error", Q.Yd.errors.SERVER_ERROR, {
                                    body: Ct(Rr, ur.headers ? ur.headers["content-type"] : null),
                                    error: Ur,
                                    requestBody: Ct(st.body, er["content-type"]),
                                    requestMethod: st.method,
                                    url: xt
                                })
                            }
                            return kr.cancel(), Rr
                        }
                        return Ke.throwError("failed response", Q.Yd.errors.SERVER_ERROR, {
                            requestBody: Ct(st.body, er["content-type"]),
                            requestMethod: st.method,
                            url: xt
                        })
                    })
                }();
                return Promise.race([kr.promise, qr])
            }(N, C, (ee, se) => {
                let ct = null;
                if (null != ee) try {
                    ct = JSON.parse((0, I.ZN)(ee))
                } catch (xt) {
                    Ke.throwError("invalid JSON", Q.Yd.errors.SERVER_ERROR, {body: ee, error: xt})
                }
                return u && (ct = u(ct, se)), ct
            })
        }

        function Zt(N, o) {
            return o || (o = {}), null == (o = (0, W.DC)(o)).floor && (o.floor = 0), null == o.ceiling && (o.ceiling = 1e4), null == o.interval && (o.interval = 250), new Promise(function (u, d) {
                let C = null, ee = !1;
                const se = () => !ee && (ee = !0, C && clearTimeout(C), !0);
                o.timeout && (C = setTimeout(() => {
                    se() && d(new Error("timeout"))
                }, o.timeout));
                const ct = o.retryLimit;
                let xt = 0;
                !function st() {
                    return N().then(function (Vt) {
                        if (void 0 !== Vt) se() && u(Vt); else if (o.oncePoll) o.oncePoll.once("poll", st); else if (o.onceBlock) o.onceBlock.once("block", st); else if (!ee) {
                            if (xt++, xt > ct) return void (se() && d(new Error("retry limit reached")));
                            let Wt = o.interval * parseInt(String(Math.random() * Math.pow(2, xt)));
                            Wt < o.floor && (Wt = o.floor), Wt > o.ceiling && (Wt = o.ceiling), setTimeout(st, Wt)
                        }
                        return null
                    }, function (Vt) {
                        se() && d(Vt)
                    })
                }()
            })
        }

        const hn = "providers/5.6.8";
        var Bn = R(5887);

        function xr(N, o) {
            o || (o = function (C) {
                return [parseInt(C, 16)]
            });
            let u = 0, d = {};
            return N.split(",").forEach(C => {
                let ee = C.split(":");
                u += parseInt(ee[0], 16), d[u] = o(ee[1])
            }), d
        }

        function $r(N) {
            let o = 0;
            return N.split(",").map(u => {
                let d = u.split("-");
                1 === d.length ? d[1] = "0" : "" === d[1] && (d[1] = "1");
                let C = o + parseInt(d[0], 16);
                return o = parseInt(d[1], 16), {l: C, h: o}
            })
        }

        function Nr(N, o) {
            let u = 0;
            for (let d = 0; d < o.length; d++) {
                let C = o[d];
                if (u += C.l, N >= u && N <= u + C.h && (N - u) % (C.d || 1) == 0) {
                    if (C.e && -1 !== C.e.indexOf(N - u)) continue;
                    return C
                }
            }
            return null
        }

        const li = $r("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
            Ci = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(N => parseInt(N, 16)),
            hi = [{h: 25, s: 32, l: 65}, {h: 30, s: 32, e: [23], l: 127}, {h: 54, s: 1, e: [48], l: 64, d: 2}, {
                h: 14,
                s: 1,
                l: 57,
                d: 2
            }, {h: 44, s: 1, l: 17, d: 2}, {h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2}, {h: 16, s: 1, l: 68, d: 2}, {
                h: 84,
                s: 1,
                e: [18, 24, 66],
                l: 19,
                d: 2
            }, {h: 26, s: 32, e: [17], l: 435}, {h: 22, s: 1, l: 71, d: 2}, {h: 15, s: 80, l: 40}, {
                h: 31,
                s: 32,
                l: 16
            }, {h: 32, s: 1, l: 80, d: 2}, {h: 52, s: 1, l: 42, d: 2}, {h: 12, s: 1, l: 55, d: 2}, {
                h: 40,
                s: 1,
                e: [38],
                l: 15,
                d: 2
            }, {h: 14, s: 1, l: 48, d: 2}, {h: 37, s: 48, l: 49}, {h: 148, s: 1, l: 6351, d: 2}, {
                h: 88,
                s: 1,
                l: 160,
                d: 2
            }, {h: 15, s: 16, l: 704}, {h: 25, s: 26, l: 854}, {h: 25, s: 32, l: 55915}, {
                h: 37,
                s: 40,
                l: 1247
            }, {h: 25, s: -119711, l: 53248}, {h: 25, s: -119763, l: 52}, {h: 25, s: -119815, l: 52}, {
                h: 25,
                s: -119867,
                e: [1, 4, 5, 7, 8, 11, 12, 17],
                l: 52
            }, {h: 25, s: -119919, l: 52}, {h: 24, s: -119971, e: [2, 7, 8, 17], l: 52}, {
                h: 24,
                s: -120023,
                e: [2, 7, 13, 15, 16, 17],
                l: 52
            }, {h: 25, s: -120075, l: 52}, {h: 25, s: -120127, l: 52}, {h: 25, s: -120179, l: 52}, {
                h: 25,
                s: -120231,
                l: 52
            }, {h: 25, s: -120283, l: 52}, {h: 25, s: -120335, l: 52}, {h: 24, s: -119543, e: [17], l: 56}, {
                h: 24,
                s: -119601,
                e: [17],
                l: 58
            }, {h: 24, s: -119659, e: [17], l: 58}, {h: 24, s: -119717, e: [17], l: 58}, {
                h: 24,
                s: -119775,
                e: [17],
                l: 58
            }],
            $i = xr("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
            ki = xr("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
            Pi = xr("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", function lr(N) {
                if (N.length % 4 != 0) throw new Error("bad data");
                let o = [];
                for (let u = 0; u < N.length; u += 4) o.push(parseInt(N.substring(u, u + 4), 16));
                return o
            }),
            Fi = $r("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

        function pi(N) {
            if (N.match(/^[a-z0-9-]*$/i) && N.length <= 59) return N.toLowerCase();
            let o = (0, I.XL)(N);
            o = function Oi(N) {
                return N.reduce((o, u) => (u.forEach(d => {
                    o.push(d)
                }), o), [])
            }(o.map(d => {
                if (Ci.indexOf(d) >= 0) return [];
                if (d >= 65024 && d <= 65039) return [];
                let C = function ci(N) {
                    let o = Nr(N, hi);
                    if (o) return [N + o.s];
                    let u = $i[N];
                    if (u) return u;
                    let d = ki[N];
                    return d ? [N + d[0]] : Pi[N] || null
                }(d);
                return C || [d]
            })), o = (0, I.XL)((0, I.uu)(o), I.Uj.NFKC), o.forEach(d => {
                if (function Vi(N) {
                    return !!Nr(N, Fi)
                }(d)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED")
            }), o.forEach(d => {
                if (function Qr(N) {
                    return !!Nr(N, li)
                }(d)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")
            });
            let u = (0, I.uu)(o);
            if ("-" === u.substring(0, 1) || "--" === u.substring(2, 4) || "-" === u.substring(u.length - 1)) throw new Error("invalid hyphen");
            if (u.length > 63) throw new Error("too long");
            return u
        }

        var Wi = R(3198);
        const ei = new Q.Yd(Wi.i), xi = new Uint8Array(32);
        xi.fill(0);
        const Ui = new RegExp("^((.*)\\.)?([^.]+)$");

        function ui(N) {
            "string" != typeof N && ei.throwArgumentError("invalid ENS name; not a string", "name", N);
            let o = N, u = xi;
            for (; o.length;) {
                const d = o.match(Ui);
                (null == d || "" === d[2]) && ei.throwArgumentError("invalid ENS address; missing component", "name", N);
                const C = (0, I.Y0)(pi(d[3]));
                u = (0, oe.w)((0, te.zo)([u, (0, oe.w)(C)])), o = d[2] || ""
            }
            return (0, te.Dv)(u)
        }

        const mi = new Q.Yd("networks/5.6.4");

        function ti(N) {
            const o = function (u, d) {
                null == d && (d = {});
                const C = [];
                if (u.InfuraProvider && "-" !== d.infura) try {
                    C.push(new u.InfuraProvider(N, d.infura))
                } catch (ee) {
                }
                if (u.EtherscanProvider && "-" !== d.etherscan) try {
                    C.push(new u.EtherscanProvider(N, d.etherscan))
                } catch (ee) {
                }
                if (u.AlchemyProvider && "-" !== d.alchemy) try {
                    C.push(new u.AlchemyProvider(N, d.alchemy))
                } catch (ee) {
                }
                if (u.PocketProvider && "-" !== d.pocket) {
                    const ee = ["goerli", "ropsten", "rinkeby"];
                    try {
                        const se = new u.PocketProvider(N, d.pocket);
                        se.network && -1 === ee.indexOf(se.network.name) && C.push(se)
                    } catch (se) {
                    }
                }
                if (u.CloudflareProvider && "-" !== d.cloudflare) try {
                    C.push(new u.CloudflareProvider(N))
                } catch (ee) {
                }
                if (u.AnkrProvider && "-" !== d.ankr) try {
                    const ee = ["ropsten"], se = new u.AnkrProvider(N, d.ankr);
                    se.network && -1 === ee.indexOf(se.network.name) && C.push(se)
                } catch (ee) {
                }
                if (0 === C.length) return null;
                if (u.FallbackProvider) {
                    let ee = 1;
                    return null != d.quorum ? ee = d.quorum : "homestead" === N && (ee = 2), new u.FallbackProvider(C, ee)
                }
                return C[0]
            };
            return o.renetwork = function (u) {
                return ti(u)
            }, o
        }

        function Hr(N, o) {
            const u = function (d, C) {
                return d.JsonRpcProvider ? new d.JsonRpcProvider(N, o) : null
            };
            return u.renetwork = function (d) {
                return Hr(N, d)
            }, u
        }

        const si = {
            chainId: 1,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "homestead",
            _defaultProvider: ti("homestead")
        }, vi = {
            chainId: 3,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "ropsten",
            _defaultProvider: ti("ropsten")
        }, Di = {
            chainId: 63,
            name: "classicMordor",
            _defaultProvider: Hr("https://www.ethercluster.com/mordor", "classicMordor")
        }, ni = {
            unspecified: {chainId: 0, name: "unspecified"},
            homestead: si,
            mainnet: si,
            morden: {chainId: 2, name: "morden"},
            ropsten: vi,
            testnet: vi,
            rinkeby: {
                chainId: 4,
                ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                name: "rinkeby",
                _defaultProvider: ti("rinkeby")
            },
            kovan: {chainId: 42, name: "kovan", _defaultProvider: ti("kovan")},
            goerli: {
                chainId: 5,
                ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                name: "goerli",
                _defaultProvider: ti("goerli")
            },
            kintsugi: {chainId: 1337702, name: "kintsugi"},
            classic: {
                chainId: 61,
                name: "classic",
                _defaultProvider: Hr("https://www.ethercluster.com/etc", "classic")
            },
            classicMorden: {chainId: 62, name: "classicMorden"},
            classicMordor: Di,
            classicTestnet: Di,
            classicKotti: {
                chainId: 6,
                name: "classicKotti",
                _defaultProvider: Hr("https://www.ethercluster.com/kotti", "classicKotti")
            },
            xdai: {chainId: 100, name: "xdai"},
            matic: {chainId: 137, name: "matic", _defaultProvider: ti("matic")},
            maticmum: {chainId: 80001, name: "maticmum"},
            optimism: {chainId: 10, name: "optimism", _defaultProvider: ti("optimism")},
            "optimism-kovan": {chainId: 69, name: "optimism-kovan"},
            "optimism-goerli": {chainId: 420, name: "optimism-goerli"},
            arbitrum: {chainId: 42161, name: "arbitrum"},
            "arbitrum-rinkeby": {chainId: 421611, name: "arbitrum-rinkeby"},
            bnb: {chainId: 56, name: "bnb"},
            bnbt: {chainId: 97, name: "bnbt"}
        };
        var Ei = R(1871), ai = R(988), ri = R.n(ai);
        const Wr = new Q.Yd(hn);

        class kn {
            constructor() {
                this.formats = this.getDefaultFormats()
            }

            getDefaultFormats() {
                const o = {}, u = this.address.bind(this), d = this.bigNumber.bind(this), C = this.blockTag.bind(this),
                    ee = this.data.bind(this), se = this.hash.bind(this), ct = this.hex.bind(this),
                    xt = this.number.bind(this), st = this.type.bind(this);
                return o.transaction = {
                    hash: se,
                    type: st,
                    accessList: kn.allowNull(this.accessList.bind(this), null),
                    blockHash: kn.allowNull(se, null),
                    blockNumber: kn.allowNull(xt, null),
                    transactionIndex: kn.allowNull(xt, null),
                    confirmations: kn.allowNull(xt, null),
                    from: u,
                    gasPrice: kn.allowNull(d),
                    maxPriorityFeePerGas: kn.allowNull(d),
                    maxFeePerGas: kn.allowNull(d),
                    gasLimit: d,
                    to: kn.allowNull(u, null),
                    value: d,
                    nonce: xt,
                    data: ee,
                    r: kn.allowNull(this.uint256),
                    s: kn.allowNull(this.uint256),
                    v: kn.allowNull(xt),
                    creates: kn.allowNull(u, null),
                    raw: kn.allowNull(ee)
                }, o.transactionRequest = {
                    from: kn.allowNull(u),
                    nonce: kn.allowNull(xt),
                    gasLimit: kn.allowNull(d),
                    gasPrice: kn.allowNull(d),
                    maxPriorityFeePerGas: kn.allowNull(d),
                    maxFeePerGas: kn.allowNull(d),
                    to: kn.allowNull(u),
                    value: kn.allowNull(d),
                    data: kn.allowNull(Wt => this.data(Wt, !0)),
                    type: kn.allowNull(xt),
                    accessList: kn.allowNull(this.accessList.bind(this), null)
                }, o.receiptLog = {
                    transactionIndex: xt,
                    blockNumber: xt,
                    transactionHash: se,
                    address: u,
                    topics: kn.arrayOf(se),
                    data: ee,
                    logIndex: xt,
                    blockHash: se
                }, o.receipt = {
                    to: kn.allowNull(this.address, null),
                    from: kn.allowNull(this.address, null),
                    contractAddress: kn.allowNull(u, null),
                    transactionIndex: xt,
                    root: kn.allowNull(ct),
                    gasUsed: d,
                    logsBloom: kn.allowNull(ee),
                    blockHash: se,
                    transactionHash: se,
                    logs: kn.arrayOf(this.receiptLog.bind(this)),
                    blockNumber: xt,
                    confirmations: kn.allowNull(xt, null),
                    cumulativeGasUsed: d,
                    effectiveGasPrice: kn.allowNull(d),
                    status: kn.allowNull(xt),
                    type: st
                }, o.block = {
                    hash: kn.allowNull(se),
                    parentHash: se,
                    number: xt,
                    timestamp: xt,
                    nonce: kn.allowNull(ct),
                    difficulty: this.difficulty.bind(this),
                    gasLimit: d,
                    gasUsed: d,
                    miner: kn.allowNull(u),
                    extraData: ee,
                    transactions: kn.allowNull(kn.arrayOf(se)),
                    baseFeePerGas: kn.allowNull(d)
                }, o.blockWithTransactions = (0, W.DC)(o.block), o.blockWithTransactions.transactions = kn.allowNull(kn.arrayOf(this.transactionResponse.bind(this))), o.filter = {
                    fromBlock: kn.allowNull(C, void 0),
                    toBlock: kn.allowNull(C, void 0),
                    blockHash: kn.allowNull(se, void 0),
                    address: kn.allowNull(u, void 0),
                    topics: kn.allowNull(this.topics.bind(this), void 0)
                }, o.filterLog = {
                    blockNumber: kn.allowNull(xt),
                    blockHash: kn.allowNull(se),
                    transactionIndex: xt,
                    removed: kn.allowNull(this.boolean.bind(this)),
                    address: u,
                    data: kn.allowFalsish(ee, "0x"),
                    topics: kn.arrayOf(se),
                    transactionHash: se,
                    logIndex: xt
                }, o
            }

            accessList(o) {
                return (0, Ht.z7)(o || [])
            }

            number(o) {
                return "0x" === o ? 0 : j.O$.from(o).toNumber()
            }

            type(o) {
                return "0x" === o || null == o ? 0 : j.O$.from(o).toNumber()
            }

            bigNumber(o) {
                return j.O$.from(o)
            }

            boolean(o) {
                if ("boolean" == typeof o) return o;
                if ("string" == typeof o) {
                    if ("true" === (o = o.toLowerCase())) return !0;
                    if ("false" === o) return !1
                }
                throw new Error("invalid boolean - " + o)
            }

            hex(o, u) {
                return "string" == typeof o && (!u && "0x" !== o.substring(0, 2) && (o = "0x" + o), (0, te.A7)(o)) ? o.toLowerCase() : Wr.throwArgumentError("invalid hash", "value", o)
            }

            data(o, u) {
                const d = this.hex(o, u);
                if (d.length % 2 != 0) throw new Error("invalid data; odd-length - " + o);
                return d
            }

            address(o) {
                return (0, H.Kn)(o)
            }

            callAddress(o) {
                if (!(0, te.A7)(o, 32)) return null;
                const u = (0, H.Kn)((0, te.p3)(o, 12));
                return "0x0000000000000000000000000000000000000000" === u ? null : u
            }

            contractAddress(o) {
                return (0, H.CR)(o)
            }

            blockTag(o) {
                if (null == o) return "latest";
                if ("earliest" === o) return "0x0";
                if ("latest" === o || "pending" === o) return o;
                if ("number" == typeof o || (0, te.A7)(o)) return (0, te.$P)(o);
                throw new Error("invalid blockTag")
            }

            hash(o, u) {
                const d = this.hex(o, u);
                return 32 !== (0, te.E1)(d) ? Wr.throwArgumentError("invalid hash", "value", o) : d
            }

            difficulty(o) {
                if (null == o) return null;
                const u = j.O$.from(o);
                try {
                    return u.toNumber()
                } catch (d) {
                }
                return null
            }

            uint256(o) {
                if (!(0, te.A7)(o)) throw new Error("invalid uint256");
                return (0, te.$m)(o, 32)
            }

            _block(o, u) {
                null != o.author && null == o.miner && (o.miner = o.author);
                const d = null != o._difficulty ? o._difficulty : o.difficulty, C = kn.check(u, o);
                return C._difficulty = null == d ? null : j.O$.from(d), C
            }

            block(o) {
                return this._block(o, this.formats.block)
            }

            blockWithTransactions(o) {
                return this._block(o, this.formats.blockWithTransactions)
            }

            transactionRequest(o) {
                return kn.check(this.formats.transactionRequest, o)
            }

            transactionResponse(o) {
                null != o.gas && null == o.gasLimit && (o.gasLimit = o.gas), o.to && j.O$.from(o.to).isZero() && (o.to = "0x0000000000000000000000000000000000000000"), null != o.input && null == o.data && (o.data = o.input), null == o.to && null == o.creates && (o.creates = this.contractAddress(o)), (1 === o.type || 2 === o.type) && null == o.accessList && (o.accessList = []);
                const u = kn.check(this.formats.transaction, o);
                if (null != o.chainId) {
                    let d = o.chainId;
                    (0, te.A7)(d) && (d = j.O$.from(d).toNumber()), u.chainId = d
                } else {
                    let d = o.networkId;
                    null == d && null == u.v && (d = o.chainId), (0, te.A7)(d) && (d = j.O$.from(d).toNumber()), "number" != typeof d && null != u.v && (d = (u.v - 35) / 2, d < 0 && (d = 0), d = parseInt(d)), "number" != typeof d && (d = 0), u.chainId = d
                }
                return u.blockHash && "x" === u.blockHash.replace(/0/g, "") && (u.blockHash = null), u
            }

            transaction(o) {
                return (0, Ht.Qc)(o)
            }

            receiptLog(o) {
                return kn.check(this.formats.receiptLog, o)
            }

            receipt(o) {
                const u = kn.check(this.formats.receipt, o);
                if (null != u.root) if (u.root.length <= 4) {
                    const d = j.O$.from(u.root).toNumber();
                    0 === d || 1 === d ? (null != u.status && u.status !== d && Wr.throwArgumentError("alt-root-status/status mismatch", "value", {
                        root: u.root,
                        status: u.status
                    }), u.status = d, delete u.root) : Wr.throwArgumentError("invalid alt-root-status", "value.root", u.root)
                } else 66 !== u.root.length && Wr.throwArgumentError("invalid root hash", "value.root", u.root);
                return null != u.status && (u.byzantium = !0), u
            }

            topics(o) {
                return Array.isArray(o) ? o.map(u => this.topics(u)) : null != o ? this.hash(o, !0) : null
            }

            filter(o) {
                return kn.check(this.formats.filter, o)
            }

            filterLog(o) {
                return kn.check(this.formats.filterLog, o)
            }

            static check(o, u) {
                const d = {};
                for (const C in o) try {
                    const ee = o[C](u[C]);
                    void 0 !== ee && (d[C] = ee)
                } catch (ee) {
                    throw ee.checkKey = C, ee.checkValue = u[C], ee
                }
                return d
            }

            static allowNull(o, u) {
                return function (d) {
                    return null == d ? u : o(d)
                }
            }

            static allowFalsish(o, u) {
                return function (d) {
                    return d ? o(d) : u
                }
            }

            static arrayOf(o) {
                return function (u) {
                    if (!Array.isArray(u)) throw new Error("not an array");
                    const d = [];
                    return u.forEach(function (C) {
                        d.push(o(C))
                    }), d
                }
            }
        }

        var be = function (N, o, u, d) {
            return new (u || (u = Promise))(function (ee, se) {
                function ct(Vt) {
                    try {
                        st(d.next(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function xt(Vt) {
                    try {
                        st(d.throw(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function st(Vt) {
                    Vt.done ? ee(Vt.value) : function C(ee) {
                        return ee instanceof u ? ee : new u(function (se) {
                            se(ee)
                        })
                    }(Vt.value).then(ct, xt)
                }

                st((d = d.apply(N, o || [])).next())
            })
        };
        const Y = new Q.Yd(hn);

        function mt(N) {
            return null == N ? "null" : (32 !== (0, te.E1)(N) && Y.throwArgumentError("invalid topic", "topic", N), N.toLowerCase())
        }

        function Yt(N) {
            for (N = N.slice(); N.length > 0 && null == N[N.length - 1];) N.pop();
            return N.map(o => {
                if (Array.isArray(o)) {
                    const u = {};
                    o.forEach(C => {
                        u[mt(C)] = !0
                    });
                    const d = Object.keys(u);
                    return d.sort(), d.join("|")
                }
                return mt(o)
            }).join("&")
        }

        function vn(N) {
            if ("string" == typeof N) {
                if (N = N.toLowerCase(), 32 === (0, te.E1)(N)) return "tx:" + N;
                if (-1 === N.indexOf(":")) return N
            } else {
                if (Array.isArray(N)) return "filter:*:" + Yt(N);
                if (dn.Sg.isForkEvent(N)) throw Y.warn("not implemented"), new Error("not implemented");
                if (N && "object" == typeof N) return "filter:" + (N.address || "*") + ":" + Yt(N.topics || [])
            }
            throw new Error("invalid event - " + N)
        }

        function vr() {
            return (new Date).getTime()
        }

        function wr(N) {
            return new Promise(o => {
                setTimeout(o, N)
            })
        }

        const hr = ["block", "network", "pending", "poll"];

        class ir {
            constructor(o, u, d) {
                (0, W.zG)(this, "tag", o), (0, W.zG)(this, "listener", u), (0, W.zG)(this, "once", d), this._lastBlockNumber = -2, this._inflight = !1
            }

            get event() {
                switch (this.type) {
                    case"tx":
                        return this.hash;
                    case"filter":
                        return this.filter
                }
                return this.tag
            }

            get type() {
                return this.tag.split(":")[0]
            }

            get hash() {
                const o = this.tag.split(":");
                return "tx" !== o[0] ? null : o[1]
            }

            get filter() {
                const o = this.tag.split(":");
                if ("filter" !== o[0]) return null;
                const u = o[1], d = function ln(N) {
                    return "" === N ? [] : N.split(/&/g).map(o => {
                        if ("" === o) return [];
                        const u = o.split("|").map(d => "null" === d ? null : d);
                        return 1 === u.length ? u[0] : u
                    })
                }(o[2]), C = {};
                return d.length > 0 && (C.topics = d), u && "*" !== u && (C.address = u), C
            }

            pollable() {
                return this.tag.indexOf(":") >= 0 || hr.indexOf(this.tag) >= 0
            }
        }

        const Tr = {
            0: {symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc"},
            2: {symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc"},
            3: {symbol: "doge", p2pkh: 30, p2sh: 22},
            60: {symbol: "eth", ilk: "eth"},
            61: {symbol: "etc", ilk: "eth"},
            700: {symbol: "xdai", ilk: "eth"}
        };

        function yr(N) {
            return (0, te.$m)(j.O$.from(N).toHexString(), 32)
        }

        function Ar(N) {
            return Bn.eU.encode((0, te.zo)([N, (0, te.p3)((0, Ei.JQ)((0, Ei.JQ)(N)), 0, 4)]))
        }

        const Or = new RegExp("^(ipfs)://(.*)$", "i"),
            Pr = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), Or, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

        function Gr(N, o) {
            try {
                return (0, I.ZN)(jr(N, o))
            } catch (u) {
            }
            return null
        }

        function jr(N, o) {
            if ("0x" === N) return null;
            const u = j.O$.from((0, te.p3)(N, o, o + 32)).toNumber(),
                d = j.O$.from((0, te.p3)(N, u, u + 32)).toNumber();
            return (0, te.p3)(N, u + 32, u + 32 + d)
        }

        function re(N) {
            return N.match(/^ipfs:\/\/ipfs\//i) ? N = N.substring(12) : N.match(/^ipfs:\/\//i) ? N = N.substring(7) : Y.throwArgumentError("unsupported IPFS format", "link", N), `https://gateway.ipfs.io/ipfs/${N}`
        }

        function z(N) {
            const o = (0, te.lE)(N);
            if (o.length > 32) throw new Error("internal; should not happen");
            const u = new Uint8Array(32);
            return u.set(o, 32 - o.length), u
        }

        function V(N) {
            if (N.length % 32 == 0) return N;
            const o = new Uint8Array(32 * Math.ceil(N.length / 32));
            return o.set(N), o
        }

        function _e(N) {
            const o = [];
            let u = 0;
            for (let d = 0; d < N.length; d++) o.push(null), u += 32;
            for (let d = 0; d < N.length; d++) {
                const C = (0, te.lE)(N[d]);
                o[d] = z(u), o.push(z(C.length)), o.push(V(C)), u += 32 + 32 * Math.ceil(C.length / 32)
            }
            return (0, te.xs)(o)
        }

        class h {
            constructor(o, u, d, C) {
                (0, W.zG)(this, "provider", o), (0, W.zG)(this, "name", d), (0, W.zG)(this, "address", o.formatter.address(u)), (0, W.zG)(this, "_resolvedAddress", C)
            }

            supportsWildcard() {
                return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
                    to: this.address,
                    data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
                }).then(o => j.O$.from(o).eq(1)).catch(o => {
                    if (o.code === Q.Yd.errors.CALL_EXCEPTION) return !1;
                    throw this._supportsEip2544 = null, o
                })), this._supportsEip2544
            }

            _fetch(o, u) {
                return be(this, void 0, void 0, function* () {
                    const d = {to: this.address, ccipReadEnabled: !0, data: (0, te.xs)([o, ui(this.name), u || "0x"])};
                    let C = !1;
                    var N;
                    (yield this.supportsWildcard()) && (C = !0, d.data = (0, te.xs)(["0x9061b923", _e([(N = this.name, (0, te.Dv)((0, te.zo)(N.split(".").map(o => {
                        const u = (0, I.Y0)("_" + pi(o));
                        return u[0] = u.length - 1, u
                    }))) + "00"), d.data])]));
                    try {
                        let ee = yield this.provider.call(d);
                        return (0, te.lE)(ee).length % 32 == 4 && Y.throwError("resolver threw error", Q.Yd.errors.CALL_EXCEPTION, {
                            transaction: d,
                            data: ee
                        }), C && (ee = jr(ee, 0)), ee
                    } catch (ee) {
                        if (ee.code === Q.Yd.errors.CALL_EXCEPTION) return null;
                        throw ee
                    }
                })
            }

            _fetchBytes(o, u) {
                return be(this, void 0, void 0, function* () {
                    const d = yield this._fetch(o, u);
                    return null != d ? jr(d, 0) : null
                })
            }

            _getAddress(o, u) {
                const d = Tr[String(o)];
                if (null == d && Y.throwError(`unsupported coin type: ${o}`, Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: `getAddress(${o})`}), "eth" === d.ilk) return this.provider.formatter.address(u);
                const C = (0, te.lE)(u);
                if (null != d.p2pkh) {
                    const ee = u.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
                    if (ee) {
                        const se = parseInt(ee[1], 16);
                        if (ee[2].length === 2 * se && se >= 1 && se <= 75) return Ar((0, te.zo)([[d.p2pkh], "0x" + ee[2]]))
                    }
                }
                if (null != d.p2sh) {
                    const ee = u.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
                    if (ee) {
                        const se = parseInt(ee[1], 16);
                        if (ee[2].length === 2 * se && se >= 1 && se <= 75) return Ar((0, te.zo)([[d.p2sh], "0x" + ee[2]]))
                    }
                }
                if (null != d.prefix) {
                    const ee = C[1];
                    let se = C[0];
                    if (0 === se ? 20 !== ee && 32 !== ee && (se = -1) : se = -1, se >= 0 && C.length === 2 + ee && ee >= 1 && ee <= 75) {
                        const ct = ri().toWords(C.slice(2));
                        return ct.unshift(se), ri().encode(d.prefix, ct)
                    }
                }
                return null
            }

            getAddress(o) {
                return be(this, void 0, void 0, function* () {
                    if (null == o && (o = 60), 60 === o) try {
                        const C = yield this._fetch("0x3b3b57de");
                        return "0x" === C || "0x0000000000000000000000000000000000000000000000000000000000000000" === C ? null : this.provider.formatter.callAddress(C)
                    } catch (C) {
                        if (C.code === Q.Yd.errors.CALL_EXCEPTION) return null;
                        throw C
                    }
                    const u = yield this._fetchBytes("0xf1cb7e06", yr(o));
                    if (null == u || "0x" === u) return null;
                    const d = this._getAddress(o, u);
                    return null == d && Y.throwError("invalid or unsupported coin data", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${o})`,
                        coinType: o,
                        data: u
                    }), d
                })
            }

            getAvatar() {
                return be(this, void 0, void 0, function* () {
                    const o = [{type: "name", content: this.name}];
                    try {
                        const u = yield this.getText("avatar");
                        if (null == u) return null;
                        for (let d = 0; d < Pr.length; d++) {
                            const C = u.match(Pr[d]);
                            if (null == C) continue;
                            const ee = C[1].toLowerCase();
                            switch (ee) {
                                case"https":
                                    return o.push({type: "url", content: u}), {linkage: o, url: u};
                                case"data":
                                    return o.push({type: "data", content: u}), {linkage: o, url: u};
                                case"ipfs":
                                    return o.push({type: "ipfs", content: u}), {linkage: o, url: re(u)};
                                case"erc721":
                                case"erc1155": {
                                    const se = "erc721" === ee ? "0xc87b56dd" : "0x0e89341c";
                                    o.push({type: ee, content: u});
                                    const ct = this._resolvedAddress || (yield this.getAddress()),
                                        xt = (C[2] || "").split("/");
                                    if (2 !== xt.length) return null;
                                    const st = yield this.provider.formatter.address(xt[0]),
                                        Vt = (0, te.$m)(j.O$.from(xt[1]).toHexString(), 32);
                                    if ("erc721" === ee) {
                                        const kr = this.provider.formatter.callAddress(yield this.provider.call({
                                            to: st,
                                            data: (0, te.xs)(["0x6352211e", Vt])
                                        }));
                                        if (ct !== kr) return null;
                                        o.push({type: "owner", content: kr})
                                    } else if ("erc1155" === ee) {
                                        const kr = j.O$.from(yield this.provider.call({
                                            to: st,
                                            data: (0, te.xs)(["0x00fdd58e", (0, te.$m)(ct, 32), Vt])
                                        }));
                                        if (kr.isZero()) return null;
                                        o.push({type: "balance", content: kr.toString()})
                                    }
                                    const Wt = {to: this.provider.formatter.address(xt[0]), data: (0, te.xs)([se, Vt])};
                                    let pn = Gr(yield this.provider.call(Wt), 0);
                                    if (null == pn) return null;
                                    o.push({
                                        type: "metadata-url-base",
                                        content: pn
                                    }), "erc1155" === ee && (pn = pn.replace("{id}", Vt.substring(2)), o.push({
                                        type: "metadata-url-expanded",
                                        content: pn
                                    })), pn.match(/^ipfs:/i) && (pn = re(pn)), o.push({
                                        type: "metadata-url",
                                        content: pn
                                    });
                                    const Ln = yield qt(pn);
                                    if (!Ln) return null;
                                    o.push({type: "metadata", content: JSON.stringify(Ln)});
                                    let er = Ln.image;
                                    if ("string" != typeof er) return null;
                                    if (!er.match(/^(https:\/\/|data:)/i)) {
                                        if (null == er.match(Or)) return null;
                                        o.push({type: "url-ipfs", content: er}), er = re(er)
                                    }
                                    return o.push({type: "url", content: er}), {linkage: o, url: er}
                                }
                            }
                        }
                    } catch (u) {
                    }
                    return null
                })
            }

            getContentHash() {
                return be(this, void 0, void 0, function* () {
                    const o = yield this._fetchBytes("0xbc1c58d1");
                    if (null == o || "0x" === o) return null;
                    const u = o.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                    if (u) {
                        const se = parseInt(u[3], 16);
                        if (u[4].length === 2 * se) return "ipfs://" + Bn.eU.encode("0x" + u[1])
                    }
                    const d = o.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                    if (d) {
                        const se = parseInt(d[3], 16);
                        if (d[4].length === 2 * se) return "ipns://" + Bn.eU.encode("0x" + d[1])
                    }
                    const C = o.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                    if (C && 64 === C[1].length) return "bzz://" + C[1];
                    const ee = o.match(/^0x90b2c605([0-9a-f]*)$/);
                    if (ee && 68 === ee[1].length) {
                        const se = {"=": "", "+": "-", "/": "_"};
                        return "sia://" + _r("0x" + ee[1]).replace(/[=+\/]/g, xt => se[xt])
                    }
                    return Y.throwError("invalid or unsupported content hash data", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: "getContentHash()",
                        data: o
                    })
                })
            }

            getText(o) {
                return be(this, void 0, void 0, function* () {
                    let u = (0, I.Y0)(o);
                    u = (0, te.zo)([yr(64), yr(u.length), u]), u.length % 32 != 0 && (u = (0, te.zo)([u, (0, te.$m)("0x", 32 - o.length % 32)]));
                    const d = yield this._fetchBytes("0x59d1d43c", (0, te.Dv)(u));
                    return null == d || "0x" === d ? null : (0, I.ZN)(d)
                })
            }
        }

        let G = null, m = 1;

        class K extends dn.zt {
            constructor(o) {
                if (super(), this._events = [], this._emitted = {block: -2}, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), (0, W.zG)(this, "anyNetwork", "any" === o), this.anyNetwork && (o = this.detectNetwork()), o instanceof Promise) this._networkPromise = o, o.catch(u => {
                }), this._ready().catch(u => {
                }); else {
                    const u = (0, W.tu)(new.target, "getNetwork")(o);
                    u ? ((0, W.zG)(this, "_network", u), this.emit("network", u, null)) : Y.throwArgumentError("invalid network", "network", o)
                }
                this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0
            }

            _ready() {
                return be(this, void 0, void 0, function* () {
                    if (null == this._network) {
                        let o = null;
                        if (this._networkPromise) try {
                            o = yield this._networkPromise
                        } catch (u) {
                        }
                        null == o && (o = yield this.detectNetwork()), o || Y.throwError("no network detected", Q.Yd.errors.UNKNOWN_ERROR, {}), null == this._network && (this.anyNetwork ? this._network = o : (0, W.zG)(this, "_network", o), this.emit("network", o, null))
                    }
                    return this._network
                })
            }

            get ready() {
                return Zt(() => this._ready().then(o => o, o => {
                    if (o.code !== Q.Yd.errors.NETWORK_ERROR || "noNetwork" !== o.event) throw o
                }))
            }

            static getFormatter() {
                return null == G && (G = new kn), G
            }

            static getNetwork(o) {
                return function oi(N) {
                    if (null == N) return null;
                    if ("number" == typeof N) {
                        for (const d in ni) {
                            const C = ni[d];
                            if (C.chainId === N) return {
                                name: C.name,
                                chainId: C.chainId,
                                ensAddress: C.ensAddress || null,
                                _defaultProvider: C._defaultProvider || null
                            }
                        }
                        return {chainId: N, name: "unknown"}
                    }
                    if ("string" == typeof N) {
                        const d = ni[N];
                        return null == d ? null : {
                            name: d.name,
                            chainId: d.chainId,
                            ensAddress: d.ensAddress,
                            _defaultProvider: d._defaultProvider || null
                        }
                    }
                    const o = ni[N.name];
                    if (!o) return "number" != typeof N.chainId && mi.throwArgumentError("invalid network chainId", "network", N), N;
                    0 !== N.chainId && N.chainId !== o.chainId && mi.throwArgumentError("network chainId mismatch", "network", N);
                    let u = N._defaultProvider || null;
                    return null == u && o._defaultProvider && (u = function Xr(N) {
                        return N && "function" == typeof N.renetwork
                    }(o._defaultProvider) ? o._defaultProvider.renetwork(N) : o._defaultProvider), {
                        name: N.name,
                        chainId: o.chainId,
                        ensAddress: N.ensAddress || o.ensAddress || null,
                        _defaultProvider: u
                    }
                }(null == o ? "homestead" : o)
            }

            ccipReadFetch(o, u, d) {
                return be(this, void 0, void 0, function* () {
                    if (this.disableCcipRead || 0 === d.length) return null;
                    const C = o.to.toLowerCase(), ee = u.toLowerCase(), se = [];
                    for (let ct = 0; ct < d.length; ct++) {
                        const xt = d[ct], st = xt.replace("{sender}", C).replace("{data}", ee),
                            Vt = xt.indexOf("{data}") >= 0 ? null : JSON.stringify({data: ee, sender: C}),
                            Wt = yield qt({
                                url: st,
                                errorPassThrough: !0
                            }, Vt, (Ln, er) => (Ln.status = er.statusCode, Ln));
                        if (Wt.data) return Wt.data;
                        const pn = Wt.message || "unknown error";
                        if (Wt.status >= 400 && Wt.status < 500) return Y.throwError(`response not found during CCIP fetch: ${pn}`, Q.Yd.errors.SERVER_ERROR, {
                            url: xt,
                            errorMessage: pn
                        });
                        se.push(pn)
                    }
                    return Y.throwError(`error encountered during CCIP fetch: ${se.map(ct => JSON.stringify(ct)).join(", ")}`, Q.Yd.errors.SERVER_ERROR, {
                        urls: d,
                        errorMessages: se
                    })
                })
            }

            _getInternalBlockNumber(o) {
                return be(this, void 0, void 0, function* () {
                    if (yield this._ready(), o > 0) for (; this._internalBlockNumber;) {
                        const C = this._internalBlockNumber;
                        try {
                            const ee = yield C;
                            if (vr() - ee.respTime <= o) return ee.blockNumber;
                            break
                        } catch (ee) {
                            if (this._internalBlockNumber === C) break
                        }
                    }
                    const u = vr(), d = (0, W.mE)({
                        blockNumber: this.perform("getBlockNumber", {}),
                        networkError: this.getNetwork().then(C => null, C => C)
                    }).then(({blockNumber: C, networkError: ee}) => {
                        if (ee) throw this._internalBlockNumber === d && (this._internalBlockNumber = null), ee;
                        const se = vr();
                        return (C = j.O$.from(C).toNumber()) < this._maxInternalBlockNumber && (C = this._maxInternalBlockNumber), this._maxInternalBlockNumber = C, this._setFastBlockNumber(C), {
                            blockNumber: C,
                            reqTime: u,
                            respTime: se
                        }
                    });
                    return this._internalBlockNumber = d, d.catch(C => {
                        this._internalBlockNumber === d && (this._internalBlockNumber = null)
                    }), (yield d).blockNumber
                })
            }

            poll() {
                return be(this, void 0, void 0, function* () {
                    const o = m++, u = [];
                    let d = null;
                    try {
                        d = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
                    } catch (C) {
                        return void this.emit("error", C)
                    }
                    if (this._setFastBlockNumber(d), this.emit("poll", o, d), d !== this._lastBlockNumber) {
                        if (-2 === this._emitted.block && (this._emitted.block = d - 1), Math.abs(this._emitted.block - d) > 1e3) Y.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${d})`), this.emit("error", Y.makeError("network block skew detected", Q.Yd.errors.NETWORK_ERROR, {
                            blockNumber: d,
                            event: "blockSkew",
                            previousBlockNumber: this._emitted.block
                        })), this.emit("block", d); else for (let C = this._emitted.block + 1; C <= d; C++) this.emit("block", C);
                        this._emitted.block !== d && (this._emitted.block = d, Object.keys(this._emitted).forEach(C => {
                            if ("block" === C) return;
                            const ee = this._emitted[C];
                            "pending" !== ee && d - ee > 12 && delete this._emitted[C]
                        })), -2 === this._lastBlockNumber && (this._lastBlockNumber = d - 1), this._events.forEach(C => {
                            switch (C.type) {
                                case"tx": {
                                    const ee = C.hash;
                                    let se = this.getTransactionReceipt(ee).then(ct => (!ct || null == ct.blockNumber || (this._emitted["t:" + ee] = ct.blockNumber, this.emit(ee, ct)), null)).catch(ct => {
                                        this.emit("error", ct)
                                    });
                                    u.push(se);
                                    break
                                }
                                case"filter":
                                    if (!C._inflight) {
                                        C._inflight = !0;
                                        const ee = C.filter;
                                        ee.fromBlock = C._lastBlockNumber + 1, ee.toBlock = d, ee.toBlock - this._maxFilterBlockRange > ee.fromBlock && (ee.fromBlock = ee.toBlock - this._maxFilterBlockRange);
                                        const se = this.getLogs(ee).then(ct => {
                                            C._inflight = !1, 0 !== ct.length && ct.forEach(xt => {
                                                xt.blockNumber > C._lastBlockNumber && (C._lastBlockNumber = xt.blockNumber), this._emitted["b:" + xt.blockHash] = xt.blockNumber, this._emitted["t:" + xt.transactionHash] = xt.blockNumber, this.emit(ee, xt)
                                            })
                                        }).catch(ct => {
                                            this.emit("error", ct), C._inflight = !1
                                        });
                                        u.push(se)
                                    }
                            }
                        }), this._lastBlockNumber = d, Promise.all(u).then(() => {
                            this.emit("didPoll", o)
                        }).catch(C => {
                            this.emit("error", C)
                        })
                    } else this.emit("didPoll", o)
                })
            }

            resetEventsBlock(o) {
                this._lastBlockNumber = o - 1, this.polling && this.poll()
            }

            get network() {
                return this._network
            }

            detectNetwork() {
                return be(this, void 0, void 0, function* () {
                    return Y.throwError("provider does not support network detection", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "provider.detectNetwork"})
                })
            }

            getNetwork() {
                return be(this, void 0, void 0, function* () {
                    const o = yield this._ready(), u = yield this.detectNetwork();
                    if (o.chainId !== u.chainId) {
                        if (this.anyNetwork) return this._network = u, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", u, o), yield wr(0), this._network;
                        const d = Y.makeError("underlying network changed", Q.Yd.errors.NETWORK_ERROR, {
                            event: "changed",
                            network: o,
                            detectedNetwork: u
                        });
                        throw this.emit("error", d), d
                    }
                    return o
                })
            }

            get blockNumber() {
                return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(o => {
                    this._setFastBlockNumber(o)
                }, o => {
                }), null != this._fastBlockNumber ? this._fastBlockNumber : -1
            }

            get polling() {
                return null != this._poller
            }

            set polling(o) {
                o && !this._poller ? (this._poller = setInterval(() => {
                    this.poll()
                }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
                    this.poll(), this._bootstrapPoll = setTimeout(() => {
                        this._poller || this.poll(), this._bootstrapPoll = null
                    }, this.pollingInterval)
                }, 0))) : !o && this._poller && (clearInterval(this._poller), this._poller = null)
            }

            get pollingInterval() {
                return this._pollingInterval
            }

            set pollingInterval(o) {
                if ("number" != typeof o || o <= 0 || parseInt(String(o)) != o) throw new Error("invalid polling interval");
                this._pollingInterval = o, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
                    this.poll()
                }, this._pollingInterval))
            }

            _getFastBlockNumber() {
                const o = vr();
                return o - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = o, this._fastBlockNumberPromise = this.getBlockNumber().then(u => ((null == this._fastBlockNumber || u > this._fastBlockNumber) && (this._fastBlockNumber = u), this._fastBlockNumber))), this._fastBlockNumberPromise
            }

            _setFastBlockNumber(o) {
                null != this._fastBlockNumber && o < this._fastBlockNumber || (this._fastQueryDate = vr(), (null == this._fastBlockNumber || o > this._fastBlockNumber) && (this._fastBlockNumber = o, this._fastBlockNumberPromise = Promise.resolve(o)))
            }

            waitForTransaction(o, u, d) {
                return be(this, void 0, void 0, function* () {
                    return this._waitForTransaction(o, null == u ? 1 : u, d || 0, null)
                })
            }

            _waitForTransaction(o, u, d, C) {
                return be(this, void 0, void 0, function* () {
                    const ee = yield this.getTransactionReceipt(o);
                    return (ee ? ee.confirmations : 0) >= u ? ee : new Promise((se, ct) => {
                        const xt = [];
                        let st = !1;
                        const Vt = function () {
                            return !!st || (st = !0, xt.forEach(pn => {
                                pn()
                            }), !1)
                        }, Wt = pn => {
                            pn.confirmations < u || Vt() || se(pn)
                        };
                        if (this.on(o, Wt), xt.push(() => {
                            this.removeListener(o, Wt)
                        }), C) {
                            let pn = C.startBlock, Ln = null;
                            const er = kr => be(this, void 0, void 0, function* () {
                                st || (yield wr(1e3), this.getTransactionCount(C.from).then(qr => be(this, void 0, void 0, function* () {
                                    if (!st) {
                                        if (qr <= C.nonce) pn = kr; else {
                                            {
                                                const sr = yield this.getTransaction(o);
                                                if (sr && null != sr.blockNumber) return
                                            }
                                            for (null == Ln && (Ln = pn - 3, Ln < C.startBlock && (Ln = C.startBlock)); Ln <= kr;) {
                                                if (st) return;
                                                const sr = yield this.getBlockWithTransactions(Ln);
                                                for (let ur = 0; ur < sr.transactions.length; ur++) {
                                                    const Rr = sr.transactions[ur];
                                                    if (Rr.hash === o) return;
                                                    if (Rr.from === C.from && Rr.nonce === C.nonce) {
                                                        if (st) return;
                                                        const Ur = yield this.waitForTransaction(Rr.hash, u);
                                                        if (Vt()) return;
                                                        let Yr = "replaced";
                                                        return Rr.data === C.data && Rr.to === C.to && Rr.value.eq(C.value) ? Yr = "repriced" : "0x" === Rr.data && Rr.from === Rr.to && Rr.value.isZero() && (Yr = "cancelled"), void ct(Y.makeError("transaction was replaced", Q.Yd.errors.TRANSACTION_REPLACED, {
                                                            cancelled: "replaced" === Yr || "cancelled" === Yr,
                                                            reason: Yr,
                                                            replacement: this._wrapTransaction(Rr),
                                                            hash: o,
                                                            receipt: Ur
                                                        }))
                                                    }
                                                }
                                                Ln++
                                            }
                                        }
                                        st || this.once("block", er)
                                    }
                                }), qr => {
                                    st || this.once("block", er)
                                }))
                            });
                            if (st) return;
                            this.once("block", er), xt.push(() => {
                                this.removeListener("block", er)
                            })
                        }
                        if ("number" == typeof d && d > 0) {
                            const pn = setTimeout(() => {
                                Vt() || ct(Y.makeError("timeout exceeded", Q.Yd.errors.TIMEOUT, {timeout: d}))
                            }, d);
                            pn.unref && pn.unref(), xt.push(() => {
                                clearTimeout(pn)
                            })
                        }
                    })
                })
            }

            getBlockNumber() {
                return be(this, void 0, void 0, function* () {
                    return this._getInternalBlockNumber(0)
                })
            }

            getGasPrice() {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const o = yield this.perform("getGasPrice", {});
                    try {
                        return j.O$.from(o)
                    } catch (u) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "getGasPrice",
                            result: o,
                            error: u
                        })
                    }
                })
            }

            getBalance(o, u) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const d = yield(0, W.mE)({address: this._getAddress(o), blockTag: this._getBlockTag(u)}),
                        C = yield this.perform("getBalance", d);
                    try {
                        return j.O$.from(C)
                    } catch (ee) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "getBalance",
                            params: d,
                            result: C,
                            error: ee
                        })
                    }
                })
            }

            getTransactionCount(o, u) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const d = yield(0, W.mE)({address: this._getAddress(o), blockTag: this._getBlockTag(u)}),
                        C = yield this.perform("getTransactionCount", d);
                    try {
                        return j.O$.from(C).toNumber()
                    } catch (ee) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "getTransactionCount",
                            params: d,
                            result: C,
                            error: ee
                        })
                    }
                })
            }

            getCode(o, u) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const d = yield(0, W.mE)({address: this._getAddress(o), blockTag: this._getBlockTag(u)}),
                        C = yield this.perform("getCode", d);
                    try {
                        return (0, te.Dv)(C)
                    } catch (ee) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "getCode",
                            params: d,
                            result: C,
                            error: ee
                        })
                    }
                })
            }

            getStorageAt(o, u, d) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const C = yield(0, W.mE)({
                        address: this._getAddress(o),
                        blockTag: this._getBlockTag(d),
                        position: Promise.resolve(u).then(se => (0, te.$P)(se))
                    }), ee = yield this.perform("getStorageAt", C);
                    try {
                        return (0, te.Dv)(ee)
                    } catch (se) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "getStorageAt",
                            params: C,
                            result: ee,
                            error: se
                        })
                    }
                })
            }

            _wrapTransaction(o, u, d) {
                if (null != u && 32 !== (0, te.E1)(u)) throw new Error("invalid response - sendTransaction");
                const C = o;
                return null != u && o.hash !== u && Y.throwError("Transaction hash mismatch from Provider.sendTransaction.", Q.Yd.errors.UNKNOWN_ERROR, {
                    expectedHash: o.hash,
                    returnedHash: u
                }), C.wait = (ee, se) => be(this, void 0, void 0, function* () {
                    let ct;
                    null == ee && (ee = 1), null == se && (se = 0), 0 !== ee && null != d && (ct = {
                        data: o.data,
                        from: o.from,
                        nonce: o.nonce,
                        to: o.to,
                        value: o.value,
                        startBlock: d
                    });
                    const xt = yield this._waitForTransaction(o.hash, ee, se, ct);
                    return null == xt && 0 === ee ? null : (this._emitted["t:" + o.hash] = xt.blockNumber, 0 === xt.status && Y.throwError("transaction failed", Q.Yd.errors.CALL_EXCEPTION, {
                        transactionHash: o.hash,
                        transaction: o,
                        receipt: xt
                    }), xt)
                }), C
            }

            sendTransaction(o) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const u = yield Promise.resolve(o).then(ee => (0, te.Dv)(ee)), d = this.formatter.transaction(o);
                    null == d.confirmations && (d.confirmations = 0);
                    const C = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    try {
                        const ee = yield this.perform("sendTransaction", {signedTransaction: u});
                        return this._wrapTransaction(d, ee, C)
                    } catch (ee) {
                        throw ee.transaction = d, ee.transactionHash = d.hash, ee
                    }
                })
            }

            _getTransactionRequest(o) {
                return be(this, void 0, void 0, function* () {
                    const u = yield o, d = {};
                    return ["from", "to"].forEach(C => {
                        null != u[C] && (d[C] = Promise.resolve(u[C]).then(ee => ee ? this._getAddress(ee) : null))
                    }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(C => {
                        null != u[C] && (d[C] = Promise.resolve(u[C]).then(ee => ee ? j.O$.from(ee) : null))
                    }), ["type"].forEach(C => {
                        null != u[C] && (d[C] = Promise.resolve(u[C]).then(ee => null != ee ? ee : null))
                    }), u.accessList && (d.accessList = this.formatter.accessList(u.accessList)), ["data"].forEach(C => {
                        null != u[C] && (d[C] = Promise.resolve(u[C]).then(ee => ee ? (0, te.Dv)(ee) : null))
                    }), this.formatter.transactionRequest(yield(0, W.mE)(d))
                })
            }

            _getFilter(o) {
                return be(this, void 0, void 0, function* () {
                    o = yield o;
                    const u = {};
                    return null != o.address && (u.address = this._getAddress(o.address)), ["blockHash", "topics"].forEach(d => {
                        null != o[d] && (u[d] = o[d])
                    }), ["fromBlock", "toBlock"].forEach(d => {
                        null != o[d] && (u[d] = this._getBlockTag(o[d]))
                    }), this.formatter.filter(yield(0, W.mE)(u))
                })
            }

            _call(o, u, d) {
                return be(this, void 0, void 0, function* () {
                    d >= 10 && Y.throwError("CCIP read exceeded maximum redirections", Q.Yd.errors.SERVER_ERROR, {
                        redirects: d,
                        transaction: o
                    });
                    const C = o.to, ee = yield this.perform("call", {transaction: o, blockTag: u});
                    if (d >= 0 && "latest" === u && null != C && "0x556f1830" === ee.substring(0, 10) && (0, te.E1)(ee) % 32 == 4) try {
                        const se = (0, te.p3)(ee, 4), ct = (0, te.p3)(se, 0, 32);
                        j.O$.from(ct).eq(C) || Y.throwError("CCIP Read sender did not match", Q.Yd.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: o,
                            data: ee
                        });
                        const xt = [], st = j.O$.from((0, te.p3)(se, 32, 64)).toNumber(),
                            Vt = j.O$.from((0, te.p3)(se, st, st + 32)).toNumber(), Wt = (0, te.p3)(se, st + 32);
                        for (let sr = 0; sr < Vt; sr++) {
                            const ur = Gr(Wt, 32 * sr);
                            null == ur && Y.throwError("CCIP Read contained corrupt URL string", Q.Yd.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: o,
                                data: ee
                            }), xt.push(ur)
                        }
                        const pn = jr(se, 64);
                        j.O$.from((0, te.p3)(se, 100, 128)).isZero() || Y.throwError("CCIP Read callback selector included junk", Q.Yd.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: o,
                            data: ee
                        });
                        const Ln = (0, te.p3)(se, 96, 100), er = jr(se, 128), kr = yield this.ccipReadFetch(o, pn, xt);
                        null == kr && Y.throwError("CCIP Read disabled or provided no URLs", Q.Yd.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: o,
                            data: ee
                        });
                        const qr = {to: C, data: (0, te.xs)([Ln, _e([kr, er])])};
                        return this._call(qr, u, d + 1)
                    } catch (se) {
                        if (se.code === Q.Yd.errors.SERVER_ERROR) throw se
                    }
                    try {
                        return (0, te.Dv)(ee)
                    } catch (se) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "call",
                            params: {transaction: o, blockTag: u},
                            result: ee,
                            error: se
                        })
                    }
                })
            }

            call(o, u) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const d = yield(0, W.mE)({
                        transaction: this._getTransactionRequest(o),
                        blockTag: this._getBlockTag(u),
                        ccipReadEnabled: Promise.resolve(o.ccipReadEnabled)
                    });
                    return this._call(d.transaction, d.blockTag, d.ccipReadEnabled ? 0 : -1)
                })
            }

            estimateGas(o) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const u = yield(0, W.mE)({transaction: this._getTransactionRequest(o)}),
                        d = yield this.perform("estimateGas", u);
                    try {
                        return j.O$.from(d)
                    } catch (C) {
                        return Y.throwError("bad result from backend", Q.Yd.errors.SERVER_ERROR, {
                            method: "estimateGas",
                            params: u,
                            result: d,
                            error: C
                        })
                    }
                })
            }

            _getAddress(o) {
                return be(this, void 0, void 0, function* () {
                    "string" != typeof (o = yield o) && Y.throwArgumentError("invalid address or ENS name", "name", o);
                    const u = yield this.resolveName(o);
                    return null == u && Y.throwError("ENS name not configured", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: `resolveName(${JSON.stringify(o)})`}), u
                })
            }

            _getBlock(o, u) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork(), o = yield o;
                    let d = -128;
                    const C = {includeTransactions: !!u};
                    if ((0, te.A7)(o, 32)) C.blockHash = o; else try {
                        C.blockTag = yield this._getBlockTag(o), (0, te.A7)(C.blockTag) && (d = parseInt(C.blockTag.substring(2), 16))
                    } catch (ee) {
                        Y.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", o)
                    }
                    return Zt(() => be(this, void 0, void 0, function* () {
                        const ee = yield this.perform("getBlock", C);
                        if (null == ee) return null != C.blockHash && null == this._emitted["b:" + C.blockHash] || null != C.blockTag && d > this._emitted.block ? null : void 0;
                        if (u) {
                            let se = null;
                            for (let xt = 0; xt < ee.transactions.length; xt++) {
                                const st = ee.transactions[xt];
                                if (null == st.blockNumber) st.confirmations = 0; else if (null == st.confirmations) {
                                    null == se && (se = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                                    let Vt = se - st.blockNumber + 1;
                                    Vt <= 0 && (Vt = 1), st.confirmations = Vt
                                }
                            }
                            const ct = this.formatter.blockWithTransactions(ee);
                            return ct.transactions = ct.transactions.map(xt => this._wrapTransaction(xt)), ct
                        }
                        return this.formatter.block(ee)
                    }), {oncePoll: this})
                })
            }

            getBlock(o) {
                return this._getBlock(o, !1)
            }

            getBlockWithTransactions(o) {
                return this._getBlock(o, !0)
            }

            getTransaction(o) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork(), o = yield o;
                    const u = {transactionHash: this.formatter.hash(o, !0)};
                    return Zt(() => be(this, void 0, void 0, function* () {
                        const d = yield this.perform("getTransaction", u);
                        if (null == d) return null == this._emitted["t:" + o] ? null : void 0;
                        const C = this.formatter.transactionResponse(d);
                        if (null == C.blockNumber) C.confirmations = 0; else if (null == C.confirmations) {
                            let se = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - C.blockNumber + 1;
                            se <= 0 && (se = 1), C.confirmations = se
                        }
                        return this._wrapTransaction(C)
                    }), {oncePoll: this})
                })
            }

            getTransactionReceipt(o) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork(), o = yield o;
                    const u = {transactionHash: this.formatter.hash(o, !0)};
                    return Zt(() => be(this, void 0, void 0, function* () {
                        const d = yield this.perform("getTransactionReceipt", u);
                        if (null == d) return null == this._emitted["t:" + o] ? null : void 0;
                        if (null == d.blockHash) return;
                        const C = this.formatter.receipt(d);
                        if (null == C.blockNumber) C.confirmations = 0; else if (null == C.confirmations) {
                            let se = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - C.blockNumber + 1;
                            se <= 0 && (se = 1), C.confirmations = se
                        }
                        return C
                    }), {oncePoll: this})
                })
            }

            getLogs(o) {
                return be(this, void 0, void 0, function* () {
                    yield this.getNetwork();
                    const u = yield(0, W.mE)({filter: this._getFilter(o)}), d = yield this.perform("getLogs", u);
                    return d.forEach(C => {
                        null == C.removed && (C.removed = !1)
                    }), kn.arrayOf(this.formatter.filterLog.bind(this.formatter))(d)
                })
            }

            getEtherPrice() {
                return be(this, void 0, void 0, function* () {
                    return yield this.getNetwork(), this.perform("getEtherPrice", {})
                })
            }

            _getBlockTag(o) {
                return be(this, void 0, void 0, function* () {
                    if ("number" == typeof (o = yield o) && o < 0) {
                        o % 1 && Y.throwArgumentError("invalid BlockTag", "blockTag", o);
                        let u = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        return u += o, u < 0 && (u = 0), this.formatter.blockTag(u)
                    }
                    return this.formatter.blockTag(o)
                })
            }

            getResolver(o) {
                return be(this, void 0, void 0, function* () {
                    let u = o;
                    for (; ;) {
                        if ("" === u || "." === u || "eth" !== o && "eth" === u) return null;
                        const d = yield this._getResolver(u, "getResolver");
                        if (null != d) {
                            const C = new h(this, d, o);
                            return u === o || (yield C.supportsWildcard()) ? C : null
                        }
                        u = u.split(".").slice(1).join(".")
                    }
                })
            }

            _getResolver(o, u) {
                return be(this, void 0, void 0, function* () {
                    null == u && (u = "ENS");
                    const d = yield this.getNetwork();
                    d.ensAddress || Y.throwError("network does not support ENS", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                        operation: u,
                        network: d.name
                    });
                    try {
                        const C = yield this.call({to: d.ensAddress, data: "0x0178b8bf" + ui(o).substring(2)});
                        return this.formatter.callAddress(C)
                    } catch (C) {
                    }
                    return null
                })
            }

            resolveName(o) {
                return be(this, void 0, void 0, function* () {
                    o = yield o;
                    try {
                        return Promise.resolve(this.formatter.address(o))
                    } catch (d) {
                        if ((0, te.A7)(o)) throw d
                    }
                    "string" != typeof o && Y.throwArgumentError("invalid ENS name", "name", o);
                    const u = yield this.getResolver(o);
                    return u ? yield u.getAddress() : null
                })
            }

            lookupAddress(o) {
                return be(this, void 0, void 0, function* () {
                    o = yield o;
                    const u = (o = this.formatter.address(o)).substring(2).toLowerCase() + ".addr.reverse",
                        d = yield this._getResolver(u, "lookupAddress");
                    if (null == d) return null;
                    const C = Gr(yield this.call({to: d, data: "0x691f3431" + ui(u).substring(2)}), 0);
                    return (yield this.resolveName(C)) != o ? null : C
                })
            }

            getAvatar(o) {
                return be(this, void 0, void 0, function* () {
                    let u = null;
                    if ((0, te.A7)(o)) {
                        const ee = this.formatter.address(o).substring(2).toLowerCase() + ".addr.reverse",
                            se = yield this._getResolver(ee, "getAvatar");
                        if (!se) return null;
                        u = new h(this, se, ee);
                        try {
                            const ct = yield u.getAvatar();
                            if (ct) return ct.url
                        } catch (ct) {
                            if (ct.code !== Q.Yd.errors.CALL_EXCEPTION) throw ct
                        }
                        try {
                            const ct = Gr(yield this.call({to: se, data: "0x691f3431" + ui(ee).substring(2)}), 0);
                            u = yield this.getResolver(ct)
                        } catch (ct) {
                            if (ct.code !== Q.Yd.errors.CALL_EXCEPTION) throw ct;
                            return null
                        }
                    } else if (u = yield this.getResolver(o), !u) return null;
                    const d = yield u.getAvatar();
                    return null == d ? null : d.url
                })
            }

            perform(o, u) {
                return Y.throwError(o + " not implemented", Q.Yd.errors.NOT_IMPLEMENTED, {operation: o})
            }

            _startEvent(o) {
                this.polling = this._events.filter(u => u.pollable()).length > 0
            }

            _stopEvent(o) {
                this.polling = this._events.filter(u => u.pollable()).length > 0
            }

            _addEventListener(o, u, d) {
                const C = new ir(vn(o), u, d);
                return this._events.push(C), this._startEvent(C), this
            }

            on(o, u) {
                return this._addEventListener(o, u, !1)
            }

            once(o, u) {
                return this._addEventListener(o, u, !0)
            }

            emit(o, ...u) {
                let d = !1, C = [], ee = vn(o);
                return this._events = this._events.filter(se => se.tag !== ee || (setTimeout(() => {
                    se.listener.apply(this, u)
                }, 0), d = !0, !se.once || (C.push(se), !1))), C.forEach(se => {
                    this._stopEvent(se)
                }), d
            }

            listenerCount(o) {
                if (!o) return this._events.length;
                let u = vn(o);
                return this._events.filter(d => d.tag === u).length
            }

            listeners(o) {
                if (null == o) return this._events.map(d => d.listener);
                let u = vn(o);
                return this._events.filter(d => d.tag === u).map(d => d.listener)
            }

            off(o, u) {
                if (null == u) return this.removeAllListeners(o);
                const d = [];
                let C = !1, ee = vn(o);
                return this._events = this._events.filter(se => !(se.tag === ee && se.listener == u && !C && (C = !0, d.push(se), 1))), d.forEach(se => {
                    this._stopEvent(se)
                }), this
            }

            removeAllListeners(o) {
                let u = [];
                if (null == o) u = this._events, this._events = []; else {
                    const d = vn(o);
                    this._events = this._events.filter(C => C.tag !== d || (u.push(C), !1))
                }
                return u.forEach(d => {
                    this._stopEvent(d)
                }), this
            }
        }

        var Re = function (N, o, u, d) {
            return new (u || (u = Promise))(function (ee, se) {
                function ct(Vt) {
                    try {
                        st(d.next(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function xt(Vt) {
                    try {
                        st(d.throw(Vt))
                    } catch (Wt) {
                        se(Wt)
                    }
                }

                function st(Vt) {
                    Vt.done ? ee(Vt.value) : function C(ee) {
                        return ee instanceof u ? ee : new u(function (se) {
                            se(ee)
                        })
                    }(Vt.value).then(ct, xt)
                }

                st((d = d.apply(N, o || [])).next())
            })
        };
        const kt = new Q.Yd(hn), Dn = ["call", "estimateGas"];

        function Lt(N, o) {
            if (null == N) return null;
            if ("string" == typeof N.message && N.message.match("reverted")) {
                const u = (0, te.A7)(N.data) ? N.data : null;
                if (!o || u) return {message: N.message, data: u}
            }
            if ("object" == typeof N) {
                for (const u in N) {
                    const d = Lt(N[u], o);
                    if (d) return d
                }
                return null
            }
            if ("string" == typeof N) try {
                return Lt(JSON.parse(N), o)
            } catch (u) {
            }
            return null
        }

        function In(N, o, u) {
            const d = u.transaction || u.signedTransaction;
            if ("call" === N) {
                const ee = Lt(o, !0);
                if (ee) return ee.data;
                kt.throwError("missing revert data in call exception; Transaction reverted without a reason string", Q.Yd.errors.CALL_EXCEPTION, {
                    data: "0x",
                    transaction: d,
                    error: o
                })
            }
            if ("estimateGas" === N) {
                let ee = Lt(o.body, !1);
                null == ee && (ee = Lt(o, !1)), ee && kt.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Q.Yd.errors.UNPREDICTABLE_GAS_LIMIT, {
                    reason: ee.message,
                    method: N,
                    transaction: d,
                    error: o
                })
            }
            let C = o.message;
            throw o.code === Q.Yd.errors.SERVER_ERROR && o.error && "string" == typeof o.error.message ? C = o.error.message : "string" == typeof o.body ? C = o.body : "string" == typeof o.responseText && (C = o.responseText), C = (C || "").toLowerCase(), C.match(/insufficient funds|base fee exceeds gas limit/i) && kt.throwError("insufficient funds for intrinsic transaction cost", Q.Yd.errors.INSUFFICIENT_FUNDS, {
                error: o,
                method: N,
                transaction: d
            }), C.match(/nonce (is )?too low/i) && kt.throwError("nonce has already been used", Q.Yd.errors.NONCE_EXPIRED, {
                error: o,
                method: N,
                transaction: d
            }), C.match(/replacement transaction underpriced|transaction gas price.*too low/i) && kt.throwError("replacement fee too low", Q.Yd.errors.REPLACEMENT_UNDERPRICED, {
                error: o,
                method: N,
                transaction: d
            }), C.match(/only replay-protected/i) && kt.throwError("legacy pre-eip-155 transactions not supported", Q.Yd.errors.UNSUPPORTED_OPERATION, {
                error: o,
                method: N,
                transaction: d
            }), Dn.indexOf(N) >= 0 && C.match(/gas required exceeds allowance|always failing transaction|execution reverted/) && kt.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Q.Yd.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: o,
                method: N,
                transaction: d
            }), o
        }

        function mr(N) {
            return new Promise(function (o) {
                setTimeout(o, N)
            })
        }

        function dr(N) {
            if (N.error) {
                const o = new Error(N.error.message);
                throw o.code = N.error.code, o.data = N.error.data, o
            }
            return N.result
        }

        function Mr(N) {
            return N && N.toLowerCase()
        }

        const Vr = {};

        class Kr extends Bt.E {
            constructor(o, u, d) {
                if (super(), o !== Vr) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
                (0, W.zG)(this, "provider", u), null == d && (d = 0), "string" == typeof d ? ((0, W.zG)(this, "_address", this.provider.formatter.address(d)), (0, W.zG)(this, "_index", null)) : "number" == typeof d ? ((0, W.zG)(this, "_index", d), (0, W.zG)(this, "_address", null)) : kt.throwArgumentError("invalid address or index", "addressOrIndex", d)
            }

            connect(o) {
                return kt.throwError("cannot alter JSON-RPC Signer connection", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "connect"})
            }

            connectUnchecked() {
                return new Zr(Vr, this.provider, this._address || this._index)
            }

            getAddress() {
                return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(o => (o.length <= this._index && kt.throwError("unknown account #" + this._index, Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "getAddress"}), this.provider.formatter.address(o[this._index])))
            }

            sendUncheckedTransaction(o) {
                o = (0, W.DC)(o);
                const u = this.getAddress().then(d => (d && (d = d.toLowerCase()), d));
                if (null == o.gasLimit) {
                    const d = (0, W.DC)(o);
                    d.from = u, o.gasLimit = this.provider.estimateGas(d)
                }
                return null != o.to && (o.to = Promise.resolve(o.to).then(d => Re(this, void 0, void 0, function* () {
                    if (null == d) return null;
                    const C = yield this.provider.resolveName(d);
                    return null == C && kt.throwArgumentError("provided ENS name resolves to null", "tx.to", d), C
                }))), (0, W.mE)({tx: (0, W.mE)(o), sender: u}).then(({tx: d, sender: C}) => {
                    null != d.from ? d.from.toLowerCase() !== C && kt.throwArgumentError("from address mismatch", "transaction", o) : d.from = C;
                    const ee = this.provider.constructor.hexlifyTransaction(d, {from: !0});
                    return this.provider.send("eth_sendTransaction", [ee]).then(se => se, se => In("sendTransaction", se, ee))
                })
            }

            signTransaction(o) {
                return kt.throwError("signing transactions is unsupported", Q.Yd.errors.UNSUPPORTED_OPERATION, {operation: "signTransaction"})
            }

            sendTransaction(o) {
                return Re(this, void 0, void 0, function* () {
                    const u = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
                        d = yield this.sendUncheckedTransaction(o);
                    try {
                        return yield Zt(() => Re(this, void 0, void 0, function* () {
                            const C = yield this.provider.getTransaction(d);
                            if (null !== C) return this.provider._wrapTransaction(C, d, u)
                        }), {oncePoll: this.provider})
                    } catch (C) {
                        throw C.transactionHash = d, C
                    }
                })
            }

            signMessage(o) {
                return Re(this, void 0, void 0, function* () {
                    const u = "string" == typeof o ? (0, I.Y0)(o) : o, d = yield this.getAddress();
                    return yield this.provider.send("personal_sign", [(0, te.Dv)(u), d.toLowerCase()])
                })
            }

            _legacySignMessage(o) {
                return Re(this, void 0, void 0, function* () {
                    const u = "string" == typeof o ? (0, I.Y0)(o) : o, d = yield this.getAddress();
                    return yield this.provider.send("eth_sign", [d.toLowerCase(), (0, te.Dv)(u)])
                })
            }

            _signTypedData(o, u, d) {
                return Re(this, void 0, void 0, function* () {
                    const C = yield $n.E.resolveNames(o, u, d, se => this.provider.resolveName(se)),
                        ee = yield this.getAddress();
                    return yield this.provider.send("eth_signTypedData_v4", [ee.toLowerCase(), JSON.stringify($n.E.getPayload(C.domain, u, C.value))])
                })
            }

            unlock(o) {
                return Re(this, void 0, void 0, function* () {
                    const u = this.provider, d = yield this.getAddress();
                    return u.send("personal_unlockAccount", [d.toLowerCase(), o, null])
                })
            }
        }

        class Zr extends Kr {
            sendTransaction(o) {
                return this.sendUncheckedTransaction(o).then(u => ({
                    hash: u,
                    nonce: null,
                    gasLimit: null,
                    gasPrice: null,
                    data: null,
                    value: null,
                    chainId: null,
                    confirmations: 0,
                    from: null,
                    wait: d => this.provider.waitForTransaction(u, d)
                }))
            }
        }

        const Ai = {
            chainId: !0,
            data: !0,
            gasLimit: !0,
            gasPrice: !0,
            nonce: !0,
            to: !0,
            value: !0,
            type: !0,
            accessList: !0,
            maxFeePerGas: !0,
            maxPriorityFeePerGas: !0
        };

        class Hi extends K {
            constructor(o, u) {
                let d = u;
                null == d && (d = new Promise((C, ee) => {
                    setTimeout(() => {
                        this.detectNetwork().then(se => {
                            C(se)
                        }, se => {
                            ee(se)
                        })
                    }, 0)
                })), super(d), o || (o = (0, W.tu)(this.constructor, "defaultUrl")()), (0, W.zG)(this, "connection", Object.freeze("string" == typeof o ? {url: o} : (0, W.DC)(o))), this._nextId = 42
            }

            get _cache() {
                return null == this._eventLoopCache && (this._eventLoopCache = {}), this._eventLoopCache
            }

            static defaultUrl() {
                return "http://localhost:8545"
            }

            detectNetwork() {
                return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
                    this._cache.detectNetwork = null
                }, 0)), this._cache.detectNetwork
            }

            _uncachedDetectNetwork() {
                return Re(this, void 0, void 0, function* () {
                    yield mr(0);
                    let o = null;
                    try {
                        o = yield this.send("eth_chainId", [])
                    } catch (u) {
                        try {
                            o = yield this.send("net_version", [])
                        } catch (d) {
                        }
                    }
                    if (null != o) {
                        const u = (0, W.tu)(this.constructor, "getNetwork");
                        try {
                            return u(j.O$.from(o).toNumber())
                        } catch (d) {
                            return kt.throwError("could not detect network", Q.Yd.errors.NETWORK_ERROR, {
                                chainId: o,
                                event: "invalidNetwork",
                                serverError: d
                            })
                        }
                    }
                    return kt.throwError("could not detect network", Q.Yd.errors.NETWORK_ERROR, {event: "noNetwork"})
                })
            }

            getSigner(o) {
                return new Kr(Vr, this, o)
            }

            getUncheckedSigner(o) {
                return this.getSigner(o).connectUnchecked()
            }

            listAccounts() {
                return this.send("eth_accounts", []).then(o => o.map(u => this.formatter.address(u)))
            }

            send(o, u) {
                const d = {method: o, params: u, id: this._nextId++, jsonrpc: "2.0"};
                this.emit("debug", {action: "request", request: (0, W.p$)(d), provider: this});
                const C = ["eth_chainId", "eth_blockNumber"].indexOf(o) >= 0;
                if (C && this._cache[o]) return this._cache[o];
                const ee = qt(this.connection, JSON.stringify(d), dr).then(se => (this.emit("debug", {
                    action: "response",
                    request: d,
                    response: se,
                    provider: this
                }), se), se => {
                    throw this.emit("debug", {action: "response", error: se, request: d, provider: this}), se
                });
                return C && (this._cache[o] = ee, setTimeout(() => {
                    this._cache[o] = null
                }, 0)), ee
            }

            prepareRequest(o, u) {
                switch (o) {
                    case"getBlockNumber":
                        return ["eth_blockNumber", []];
                    case"getGasPrice":
                        return ["eth_gasPrice", []];
                    case"getBalance":
                        return ["eth_getBalance", [Mr(u.address), u.blockTag]];
                    case"getTransactionCount":
                        return ["eth_getTransactionCount", [Mr(u.address), u.blockTag]];
                    case"getCode":
                        return ["eth_getCode", [Mr(u.address), u.blockTag]];
                    case"getStorageAt":
                        return ["eth_getStorageAt", [Mr(u.address), (0, te.$m)(u.position, 32), u.blockTag]];
                    case"sendTransaction":
                        return ["eth_sendRawTransaction", [u.signedTransaction]];
                    case"getBlock":
                        return u.blockTag ? ["eth_getBlockByNumber", [u.blockTag, !!u.includeTransactions]] : u.blockHash ? ["eth_getBlockByHash", [u.blockHash, !!u.includeTransactions]] : null;
                    case"getTransaction":
                        return ["eth_getTransactionByHash", [u.transactionHash]];
                    case"getTransactionReceipt":
                        return ["eth_getTransactionReceipt", [u.transactionHash]];
                    case"call":
                        return ["eth_call", [(0, W.tu)(this.constructor, "hexlifyTransaction")(u.transaction, {from: !0}), u.blockTag]];
                    case"estimateGas":
                        return ["eth_estimateGas", [(0, W.tu)(this.constructor, "hexlifyTransaction")(u.transaction, {from: !0})]];
                    case"getLogs":
                        return u.filter && null != u.filter.address && (u.filter.address = Mr(u.filter.address)), ["eth_getLogs", [u.filter]]
                }
                return null
            }

            perform(o, u) {
                return Re(this, void 0, void 0, function* () {
                    if ("call" === o || "estimateGas" === o) {
                        const C = u.transaction;
                        if (C && null != C.type && j.O$.from(C.type).isZero() && null == C.maxFeePerGas && null == C.maxPriorityFeePerGas) {
                            const ee = yield this.getFeeData();
                            null == ee.maxFeePerGas && null == ee.maxPriorityFeePerGas && ((u = (0, W.DC)(u)).transaction = (0, W.DC)(C), delete u.transaction.type)
                        }
                    }
                    const d = this.prepareRequest(o, u);
                    null == d && kt.throwError(o + " not implemented", Q.Yd.errors.NOT_IMPLEMENTED, {operation: o});
                    try {
                        return yield this.send(d[0], d[1])
                    } catch (C) {
                        return In(o, C, u)
                    }
                })
            }

            _startEvent(o) {
                "pending" === o.tag && this._startPending(), super._startEvent(o)
            }

            _startPending() {
                if (null != this._pendingFilter) return;
                const o = this, u = this.send("eth_newPendingTransactionFilter", []);
                this._pendingFilter = u, u.then(function (d) {
                    return function C() {
                        o.send("eth_getFilterChanges", [d]).then(function (ee) {
                            if (o._pendingFilter != u) return null;
                            let se = Promise.resolve();
                            return ee.forEach(function (ct) {
                                o._emitted["t:" + ct.toLowerCase()] = "pending", se = se.then(function () {
                                    return o.getTransaction(ct).then(function (xt) {
                                        return o.emit("pending", xt), null
                                    })
                                })
                            }), se.then(function () {
                                return mr(1e3)
                            })
                        }).then(function () {
                            if (o._pendingFilter == u) return setTimeout(function () {
                                C()
                            }, 0), null;
                            o.send("eth_uninstallFilter", [d])
                        }).catch(ee => {
                        })
                    }(), d
                }).catch(d => {
                })
            }

            _stopEvent(o) {
                "pending" === o.tag && 0 === this.listenerCount("pending") && (this._pendingFilter = null), super._stopEvent(o)
            }

            static hexlifyTransaction(o, u) {
                const d = (0, W.DC)(Ai);
                if (u) for (const ee in u) u[ee] && (d[ee] = !0);
                (0, W.uj)(o, d);
                const C = {};
                return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (ee) {
                    if (null == o[ee]) return;
                    const se = (0, te.$P)(j.O$.from(o[ee]));
                    "gasLimit" === ee && (ee = "gas"), C[ee] = se
                }), ["from", "to", "data"].forEach(function (ee) {
                    null != o[ee] && (C[ee] = (0, te.Dv)(o[ee]))
                }), o.accessList && (C.accessList = (0, Ht.z7)(o.accessList)), C
            }
        }

        var bs = R(4842), p = R(6435), s = R(5956), _ = R(4299), T = R(8349), fe = R(1808), le = R(546), De = R(9808),
            He = R(4182);
        const Oe = function (N) {
            return {active: N}
        };

        function je(N, o) {
            if (1 & N) {
                const u = p.EpF();
                p.TgZ(0, "ion-button", 34), p.NdJ("click", function () {
                    const ee = p.CHM(u).$implicit;
                    return p.oxw().changeNetwork(ee)
                }), p.TgZ(1, "ion-label"), p._uU(2), p.qZA()()
            }
            if (2 & N) {
                const u = o.$implicit, d = p.oxw();
                p.Q6J("ngClass", p.VKq(3, Oe, d.rpc === u.rpc))("disabled", !u.active), p.xp6(2), p.Oqu(u.name)
            }
        }

        function ke(N, o) {
            if (1 & N) {
                const u = p.EpF();
                p.TgZ(0, "ion-button", 35), p.NdJ("click", function () {
                    return p.CHM(u), p.oxw().paste()
                }), p.TgZ(1, "ion-label", 36), p._uU(2, "PASTE"), p.qZA()()
            }
        }

        function Ae(N, o) {
            1 & N && (p.TgZ(0, "ion-title", 37), p._uU(1, "Please enter valid address."), p.qZA())
        }

        function we(N, o) {
            1 & N && (p.TgZ(0, "ion-title", 38), p._uU(1, "You do not have enough tokens."), p.qZA())
        }

        function nt(N, o) {
            if (1 & N && (p.TgZ(0, "ion-title", 38), p._uU(1), p.qZA()), 2 & N) {
                const u = p.oxw();
                p.xp6(1), p.hij("Maximum withdraw is ", u.settings.maxWithdraw, " WRG")
            }
        }

        function pt(N, o) {
            if (1 & N && (p.TgZ(0, "ion-title", 38), p._uU(1), p.qZA()), 2 & N) {
                const u = p.oxw();
                p.xp6(1), p.hij("Minimum withdraw is ", u.minWithdraw, " WRG")
            }
        }

        function Tt(N, o) {
            1 & N && (p.TgZ(0, "ion-title", 38), p._uU(1, "You can withdraw once per hour."), p.qZA())
        }

        function qe(N, o) {
            1 & N && (p.TgZ(0, "div", 39), p._uU(1, "Loading.."), p.qZA())
        }

        function ot(N, o) {
            1 & N && (p.TgZ(0, "div", 39), p._uU(1, "Today's mining pool withdrawal limit has been reached. Try again later."), p.qZA())
        }

        function Nt(N, o) {
            1 & N && (p.TgZ(0, "div", 40), p._uU(1, "Waiting for confirmation.."), p.qZA())
        }

        function bt(N, o) {
            if (1 & N) {
                const u = p.EpF();
                p.TgZ(0, "ion-button", 41), p.NdJ("click", function () {
                    return p.CHM(u), p.oxw().withdraw()
                }), p._uU(1, "Withdraw "), p._UZ(2, "ion-ripple-effect", 24), p.qZA()
            }
            if (2 & N) {
                const u = p.oxw();
                p.Q6J("disabled", u.lastWithdraw || !u.address || 0 === u.amount || u.settings.coins < u.amount || !u.addressValid || u.minWithdraw > u.amount || u.withdrawLimit || u.settings.maxWithdraw < u.amount)
            }
        }

        function Rt(N, o) {
            if (1 & N && (p.TgZ(0, "ion-button", 42), p._uU(1, "Slow internet connection "), p._UZ(2, "ion-ripple-effect", 24), p.qZA()), 2 & N) {
                const u = p.oxw();
                p.Q6J("disabled", u.settings.slowInternet)
            }
        }

        let An = (() => {
            class N {
                constructor(u, d, C, ee, se, ct, xt) {
                    this.modalCtrl = u, this.vibration = d, this.clipboard = C, this.settings = ee, this.service = se, this.CFS = ct, this.navCtrl = xt, this.amount = 0, this.address = "", this.addressValid = !0, this.minWithdraw = this.settings.minWithdraw, this.type = "Send", this.loading = !1, this.withdrawLimit = !1, this.lastWithdraw = !1, this.loadingData = !0, this.withdrawConfirmed = !1, this.rpc = "https://polygon-rpc.com/", this.providerName = "matic", this.chainId = 137, this.polygonContract = "0x58DDBaC6307b0baa41291F82b42db57cC3462aA8", this.ethereumContract = "0xc1ADf61b3A61a2a09fb763ce81f105D60EE6EcEf", this.wallet = "0x2f6d2C2a8aD9c560915Aac0E39E5CEAE742A06E7", this.privKey = "TXpJNE1HSTJNelZsT1dOaVltSXdNR0k0WVROallUUXlPREZtWVdNNU1qazNOVGxpTm1Ka056SmpNMlJrTUdFNVltUXhZekE0WVRsak5EbGhOelU1TVE", this.abi = [{
                        inputs: [{
                            internalType: "address",
                            name: "to",
                            type: "address"
                        }, {internalType: "uint256", name: "value", type: "uint256"}],
                        name: "transfer",
                        outputs: [{internalType: "bool", name: "", type: "bool"}],
                        stateMutability: "nonpayable",
                        type: "function"
                    }]
                }

                ngOnInit() {
                    this.getWalletPolygonBalance(), this.checkWithdrawLimit()
                }

                checkWithdrawLimit() {
                    if (localStorage.getItem("lastWithdraw")) {
                        let u = JSON.parse(localStorage.getItem("lastWithdraw")) - (new Date).getTime();
                        console.log(u), u > 0 && (this.lastWithdraw = !0)
                    }
                }

                getWalletEthereumBalance() {
                    this.service.getBalanceEthereum(this.wallet, this.ethereumContract).then(u => {
                        if (u.error) this.withdrawLimit = !0; else if (u) {
                            let d = u;
                            console.log(d), this.withdrawLimit = !(d.result > 1e24)
                        }
                        this.loadingData = !1
                    })
                }

                getWalletPolygonBalance() {
                    this.service.getBalancePolygon(this.wallet, this.polygonContract).then(u => {
                        if (u.error) this.withdrawLimit = !0; else if (u) {
                            let d = u;
                            console.log(d), this.withdrawLimit = !(d.result > 1e24)
                        }
                        this.loadingData = !1
                    })
                }

                withdraw() {
                    this.loading = !0;
                    let u = new Hi(this.rpc, {name: this.providerName, chainId: this.chainId}),
                        C = new bs.w5(atob(atob(this.privKey)), u).connect(u);
                    u.getGasPrice().then(ee => {
                        let se = te.Dv(parseInt(ee._hex)), ct = new dt(this.polygonContract, this.abi, C),
                            xt = function rr(N, o) {
                                if ("string" != typeof N && nr.throwArgumentError("value must be a string", "value", N), "string" == typeof o) {
                                    const u = Er.indexOf(o);
                                    -1 !== u && (o = 3 * u)
                                }
                                return Sn(N, null != o ? o : 18)
                            }(this.amount.toString(), 18);
                        this.settings.coins -= this.amount, localStorage.setItem("coins", JSON.stringify(this.settings.coins)), ct.transfer(this.address, xt, {gasPrice: se}).then(st => {
                            console.log(st), st.date = new Date, st.amount = this.amount, st.receive = this.address, st.type = this.type, this.amount = 0, this.address = "", this.settings.withdrawHistory = JSON.parse(window.localStorage.getItem("withdrawHistory")) ? JSON.parse(window.localStorage.getItem("withdrawHistory")) : [], this.settings.withdrawHistory = this.settings.withdrawHistory.concat(st), window.localStorage.setItem("withdrawHistory", JSON.stringify(this.settings.withdrawHistory)), this.loading = !1;
                            let Vt = (new Date).getTime() + 36e5;
                            localStorage.setItem("lastWithdraw", JSON.stringify(Vt)), this.checkWithdrawLimit(), this.withdrawConfirmed = !0, setTimeout(() => {
                                this.withdrawConfirmed = !1
                            }, 4e3)
                        }, st => {
                            console.log(st), this.loading = !1, this.settings.coins += this.amount, localStorage.setItem("coins", JSON.stringify(this.settings.coins)), this.CFS.presentToast("Error: Error occured, try again later.", "bottom", 4e3, "build-outline")
                        })
                    })
                }

                changeNetwork(u) {
                    u.bossLevel && !this.settings.membership ? (this.vibration.vibrate([20, 50, 20]), this.CFS.presentToast("Network available for Boss Level Access users.", "bottom", 4e3, "keypad-outline")) : ("Ethereum" === u.name && this.getWalletEthereumBalance(), this.vibration.vibrate(5), this.rpc = u.rpc, this.providerName = u.name, this.chainId = u.chainId, this.minWithdraw = this.settings.minWithdraw * u.minWithdraw)
                }

                back() {
                    this.navCtrl.back()
                }

                key(u) {
                    this.vibration.vibrate(5), this.amount = 0 !== this.amount || this.amount.toString().includes(".") || 0 !== parseInt(u) ? 0 === this.amount ? u : this.amount + u : 0
                }

                dot(u) {
                    this.vibration.vibrate(5), this.amount.toString().includes(".") || (this.amount = this.amount + u)
                }

                undo() {
                    this.vibration.vibrate(15), this.amount = this.amount.toString().length > 1 ? parseFloat(this.amount.toString().slice(0, -1)) : 0
                }

                paste() {
                    this.vibration.vibrate([5, 50, 5]), this.clipboard.paste().then(u => {
                        this.address = u
                    }, u => {
                        alert("Error: " + u)
                    })
                }

                validateAddress() {
                    this.addressValid = 0 === this.address.length || H.UJ(this.address)
                }

                openHistoryModal(u) {
                    return (0, r.mG)(this, void 0, void 0, function* () {
                        let d = !1;
                        return u && (d = u), yield(yield this.modalCtrl.create({
                            component: ie.n,
                            cssClass: "my-Modal",
                            enterAnimation: on,
                            leaveAnimation: Cn,
                            componentProps: {highlightFirst: d}
                        })).present()
                    })
                }
            }

            return N.\u0275fac = function (u) {
                return new (u || N)(p.Y36(D.IN), p.Y36(s.w), p.Y36(_.T), p.Y36(T.Z), p.Y36(fe.t), p.Y36(le.b), p.Y36(D.SH))
            }, N.\u0275cmp = p.Xpm({
                type: N,
                selectors: [["app-withdraw"]],
                decls: 109,
                vars: 18,
                consts: [[1, "ion-no-border", 2, "padding", "0px", "background-color", "var(--ion-background-color)", "box-shadow", "none"], [2, "--background", "transparent", "box-shadow", "none", "--box-shadow", "none", "padding", "8px 10px 8px 10px", "border-bottom", "1px solid var(--ion-border-color)"], ["slot", "start", 1, "headerButton", "ion-activatable", "ripple-parent", 2, "color", "var(--ion-text-color)", "background-color", "transparent", "box-shadow", "none", "font-size", "30px", 3, "click"], ["name", "chevron-back-outline"], ["type", "bounded", 2, "border-radius", "50%"], [1, "header-title"], ["slot", "end", 1, "headerButton", "ion-activatable", "ripple-parent", 2, "color", "var(--ion-text-color)", "background-color", "transparent", "box-shadow", "none", "font-size", "30px", 3, "click"], ["name", "file-tray-stacked-outline"], [2, "padding", "18px 0px", "border-bottom", "1px solid var(--ion-border-color)"], [2, "text-align", "left", "font-size", "12px"], [2, "display", "inline-flex", "width", "100%", "white-space", "nowrap", "overflow-x", "auto", "overflow-y", "hidden", "-webkit-overflow-scrolling", "touch", "padding-right", "31px", "margin", "0px 0px 0px 18px"], ["class", "networkButton", 3, "ngClass", "disabled", "click", 4, "ngFor", "ngForOf"], ["lines", "none", 1, "field-i", 2, "position", "relative"], ["placeholder", "Enter wallet address", "type", "text", "name", "address", 1, "input-i", 3, "ngModel", "inputmode", "ionChange", "ngModelChange"], ["class", "pasteButton", 3, "click", 4, "ngIf"], ["style", "color: rgba(var(--ion-red-color-rgb), 1); text-align: left; font-size: 16px; margin: -3px 0px -15px 0px;", 4, "ngIf"], [2, "padding", "30px 18px", "border-bottom", "1px solid var(--ion-border-color)"], [2, "text-align", "center", "font-size", "50px", "color", "rgba(var(--ion-app-color-rgb), 1)"], [2, "text-align", "center", "font-size", "18px"], ["style", "color: rgba(var(--ion-red-color-rgb), 1); text-align: center; font-size: 16px; margin-bottom: -15px;", 4, "ngIf"], [2, "padding", "15px 18px"], [2, "display", "flex", "width", "100%"], [1, "key-box"], [1, "circ-button", "ion-activatable", "ripple-parent", 3, "click"], ["type", "unbounded"], ["name", "arrow-back-outline"], [1, "withdrawConfirmed", "ion-activatable", "ripple-parent", 3, "ngClass", "click"], ["name", "checkmark-outline"], [2, "padding", "0px 0px 0px 12px", "width", "calc(100% - 32px)"], [1, "footer"], ["style", "padding: 16px;", 4, "ngIf"], ["class", "loading", "style", "padding: 16px;", 4, "ngIf"], ["class", "withdraw ion-activatable ripple-parent", 3, "disabled", "click", 4, "ngIf"], ["class", "withdraw ion-activatable ripple-parent", 3, "disabled", 4, "ngIf"], [1, "networkButton", 3, "ngClass", "disabled", "click"], [1, "pasteButton", 3, "click"], [2, "color", "var(--ion-background-color) !important"], [2, "color", "rgba(var(--ion-red-color-rgb), 1)", "text-align", "left", "font-size", "16px", "margin", "-3px 0px -15px 0px"], [2, "color", "rgba(var(--ion-red-color-rgb), 1)", "text-align", "center", "font-size", "16px", "margin-bottom", "-15px"], [2, "padding", "16px"], [1, "loading", 2, "padding", "16px"], [1, "withdraw", "ion-activatable", "ripple-parent", 3, "disabled", "click"], [1, "withdraw", "ion-activatable", "ripple-parent", 3, "disabled"]],
                template: function (u, d) {
                    1 & u && (p.TgZ(0, "ion-header", 0)(1, "ion-toolbar", 1)(2, "button", 2), p.NdJ("click", function () {
                        return d.back()
                    }), p._UZ(3, "ion-icon", 3)(4, "ion-ripple-effect", 4), p.qZA(), p.TgZ(5, "ion-title", 5), p._uU(6, "Withdraw"), p.qZA(), p.TgZ(7, "button", 6), p.NdJ("click", function () {
                        return d.openHistoryModal(!1)
                    }), p._UZ(8, "ion-icon", 7)(9, "ion-ripple-effect", 4), p.qZA()()(), p.TgZ(10, "ion-content")(11, "div", 8)(12, "ion-title", 9), p._uU(13, "Network"), p.qZA(), p.TgZ(14, "div", 10), p.YNc(15, je, 3, 5, "ion-button", 11), p.qZA(), p.TgZ(16, "ion-title", 9), p._uU(17, "Address"), p.qZA(), p.TgZ(18, "ion-item", 12)(19, "ion-input", 13), p.NdJ("ionChange", function () {
                        return d.validateAddress()
                    })("ngModelChange", function (ee) {
                        return d.address = ee
                    }), p.qZA(), p.YNc(20, ke, 3, 0, "ion-button", 14), p.qZA(), p.YNc(21, Ae, 2, 0, "ion-title", 15), p.qZA(), p.TgZ(22, "div", 16)(23, "ion-title", 17), p._uU(24), p.qZA(), p.TgZ(25, "ion-title", 18), p._uU(26, "WRG"), p.qZA(), p.YNc(27, we, 2, 0, "ion-title", 19), p.YNc(28, nt, 2, 1, "ion-title", 19), p.YNc(29, pt, 2, 1, "ion-title", 19), p.YNc(30, Tt, 2, 0, "ion-title", 19), p.qZA(), p.TgZ(31, "div", 20)(32, "div", 21)(33, "div", 22)(34, "button", 23), p.NdJ("click", function () {
                        return d.key("1")
                    }), p.TgZ(35, "ion-title"), p._uU(36, "1"), p.qZA(), p._UZ(37, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(38, "div", 22)(39, "button", 23), p.NdJ("click", function () {
                        return d.key("2")
                    }), p.TgZ(40, "ion-title"), p._uU(41, "2"), p.qZA(), p._UZ(42, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(43, "div", 22)(44, "button", 23), p.NdJ("click", function () {
                        return d.key("3")
                    }), p.TgZ(45, "ion-title"), p._uU(46, "3"), p.qZA(), p._UZ(47, "ion-ripple-effect", 24), p.qZA()()(), p.TgZ(48, "div", 21)(49, "div", 22)(50, "button", 23), p.NdJ("click", function () {
                        return d.key("4")
                    }), p.TgZ(51, "ion-title"), p._uU(52, "4"), p.qZA(), p._UZ(53, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(54, "div", 22)(55, "button", 23), p.NdJ("click", function () {
                        return d.key("5")
                    }), p.TgZ(56, "ion-title"), p._uU(57, "5"), p.qZA(), p._UZ(58, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(59, "div", 22)(60, "button", 23), p.NdJ("click", function () {
                        return d.key("6")
                    }), p.TgZ(61, "ion-title"), p._uU(62, "6"), p.qZA(), p._UZ(63, "ion-ripple-effect", 24), p.qZA()()(), p.TgZ(64, "div", 21)(65, "div", 22)(66, "button", 23), p.NdJ("click", function () {
                        return d.key("7")
                    }), p.TgZ(67, "ion-title"), p._uU(68, "7"), p.qZA(), p._UZ(69, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(70, "div", 22)(71, "button", 23), p.NdJ("click", function () {
                        return d.key("8")
                    }), p.TgZ(72, "ion-title"), p._uU(73, "8"), p.qZA(), p._UZ(74, "ion-ripple-effect", 24), p.qZA()(), p.TgZ(75, "div", 22)(76, "button", 23), p.NdJ("click", function () {
                        return d.key("9")
                    }), p.TgZ(77, "ion-title"), p._uU(78, "9"), p.qZA(), p._UZ(79, "ion-ripple-effect", 24), p.qZA()()(),p.TgZ(80, "div", 21)(81, "div", 22)(82, "button", 23),p.NdJ("click", function () {
                        return d.dot(".")
                    }),p.TgZ(83, "ion-title"),p._uU(84, "."),p.qZA(),p._UZ(85, "ion-ripple-effect", 24),p.qZA()(),p.TgZ(86, "div", 22)(87, "button", 23),p.NdJ("click", function () {
                        return d.key("0")
                    }),p.TgZ(88, "ion-title"),p._uU(89, "0"),p.qZA(),p._UZ(90, "ion-ripple-effect", 24),p.qZA()(),p.TgZ(91, "div", 22)(92, "button", 23),p.NdJ("click", function () {
                        return d.undo()
                    }),p._UZ(93, "ion-icon", 25)(94, "ion-ripple-effect", 24),p.qZA()()()(),p.TgZ(95, "ion-button", 26),p.NdJ("click", function () {
                        return d.openHistoryModal(!0)
                    }),p._UZ(96, "ion-icon", 27),p.TgZ(97, "div", 28)(98, "ion-title"),p._uU(99, "Transaction confirmed!"),p.qZA(),p.TgZ(100, "p"),p._uU(101, "Tap to view this transaction."),p.qZA()(),p._UZ(102, "ion-ripple-effect", 24),p.qZA(),p.TgZ(103, "div", 29),p.YNc(104, qe, 2, 0, "div", 30),p.YNc(105, ot, 2, 0, "div", 30),p.YNc(106, Nt, 2, 0, "div", 31),p.YNc(107, bt, 3, 1, "ion-button", 32),p.YNc(108, Rt, 3, 1, "ion-button", 33),p.qZA()()), 2 & u && (p.xp6(15), p.Q6J("ngForOf", d.settings.networks), p.xp6(4), p.Q6J("ngModel", d.address)("inputmode", "text"), p.xp6(1), p.Q6J("ngIf", !d.address), p.xp6(1), p.Q6J("ngIf", !d.addressValid), p.xp6(3), p.Oqu(d.amount), p.xp6(3), p.Q6J("ngIf", !d.lastWithdraw && d.settings.coins < d.amount && d.settings.maxWithdraw > d.amount), p.xp6(1), p.Q6J("ngIf", !d.lastWithdraw && d.settings.maxWithdraw < d.amount), p.xp6(1), p.Q6J("ngIf", !d.lastWithdraw && d.minWithdraw > d.amount && 0 != d.amount && d.settings.coins >= d.amount), p.xp6(1), p.Q6J("ngIf", d.lastWithdraw), p.xp6(65), p.Q6J("ngClass", p.VKq(16, Oe, d.withdrawConfirmed)), p.xp6(9), p.Q6J("ngIf", d.loadingData && !d.withdrawLimit && !d.settings.slowInternet), p.xp6(1), p.Q6J("ngIf", !d.loadingData && d.withdrawLimit && !d.settings.slowInternet), p.xp6(1), p.Q6J("ngIf", d.loading && !d.withdrawConfirmed), p.xp6(1), p.Q6J("ngIf", !(d.loading || d.loadingData || d.settings.slowInternet || d.withdrawLimit)), p.xp6(1), p.Q6J("ngIf", d.settings.slowInternet))
                },
                directives: [D.Gu, D.sr, D.gu, D.H$, D.wd, D.W2, De.sg, D.YG, De.mk, D.Q$, D.Ie, D.pK, D.j9, He.JJ, He.On, De.O5],
                styles: ['.key-box[_ngcontent-%COMP%]{display:flex;width:33%}.circ-button[_ngcontent-%COMP%]{width:54px;height:54px;position:relative;display:block;box-shadow:none;border-radius:50px;padding:0;margin:0 auto;background-color:transparent;color:var(--ion-text-color)}.circ-button[_ngcontent-%COMP%]   ion-title[_ngcontent-%COMP%]{font-size:28px!important;margin:0;padding:0}.circ-button[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:16px!important;margin:0 0 -3px}.withdraw[_ngcontent-%COMP%]{width:100%;height:54px;position:relative;display:block;--box-shadow: none;--border-radius: 12px;padding:0;margin:0 auto;--background: rgba(var(--ion-app-color-rgb), 1);color:var(--ion-text-color)}.withdraw.button-disabled[_ngcontent-%COMP%]{opacity:1}.withdraw[_ngcontent-%COMP%]   ion-title[_ngcontent-%COMP%]{font-size:16px!important;margin:0;padding:0}.footer[_ngcontent-%COMP%]{width:100%;padding:18px;position:fixed;z-index:99999;overflow:hidden;margin-left:auto;margin-right:auto;left:0;right:0;bottom:0px;display:flex;justify-content:center;background-color:var(--ion-background-color);border-top:1px solid var(--ion-border-color)}.footer[_ngcontent-%COMP%]   .action-box[_ngcontent-%COMP%]{text-align:center;background-color:transparent;box-shadow:none;margin:0;padding:0}.networkButton[_ngcontent-%COMP%]{width:auto;height:30px;--box-shadow: 0px 0px 0px 0px rgba(0,0,0,.53);border-radius:6px;--border-radius: 6px;padding:0;margin:8px 6px 12px 2px;--background: rgba(var(--ion-text-color-rgb), .1);color:var(--ion-text-color)!important}.networkButton.active[_ngcontent-%COMP%]{--background: rgba(var(--ion-app-color-rgb), 1)}.networkButton[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:18px;margin-right:6px;margin-top:-1px}.networkButton[_ngcontent-%COMP%]   ion-label[_ngcontent-%COMP%]{font-size:14px;font-weight:600}.pasteButton[_ngcontent-%COMP%]{width:auto;height:30px;--box-shadow: 0px 0px 0px 0px rgba(0,0,0,.53);border-radius:6px;--border-radius: 6px;padding:0;position:absolute;right:26px;top:9px;z-index:99999999;--background: var(--ion-text-color);color:var(--ion-background-color)!important;text-transform:capitalize}.pasteButton[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:18px;margin-right:6px;margin-top:-1px}.pasteButton[_ngcontent-%COMP%]   ion-label[_ngcontent-%COMP%]{font-size:14px;font-weight:600}.withdrawConfirmed[_ngcontent-%COMP%]{padding:16px;--background: rgba(var(--ion-green-color-rgb), 1);--border-radius: 12px;--box-shadow: 0px 4px 10px rgba(var(--ion-green-color-rgb), .5);--color: var(--ion-text-color);position:absolute;overflow:hidden;bottom:-200px;left:50%;transform:translate(-50%,-50%);z-index:9999;width:300px;height:100px;text-transform:none;text-align:left;transition:all .4s cubic-bezier(.25,.46,.45,.94)}.withdrawConfirmed.active[_ngcontent-%COMP%]{bottom:30px}.withdrawConfirmed[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:32px;margin:0}.withdrawConfirmed[_ngcontent-%COMP%]   ion-title[_ngcontent-%COMP%]{font-size:16px;padding:0;margin:0}.withdrawConfirmed[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:12px;padding:0;margin:0;opacity:.7}.loading[_ngcontent-%COMP%]:after{position:absolute;content:"";height:100%;top:0;left:0;background-size:50%;animation:loading 1s ease infinite;opacity:1;width:100%;background-image:linear-gradient(90deg,rgba(var(--ion-app-color-rgb),.2),rgba(var(--ion-app-color-rgb),.2) 50%,transparent 50%,transparent)}@keyframes loading{to{background-position-x:100%}}']
            }), N
        })();
        const on = N => {
            const o = new D.vB, u = o.create(), d = o.create();
            d.addElement(N.querySelector("ion-backdrop"));
            const C = o.create();
            return C.addElement(N.shadowRoot.querySelector(".modal-wrapper")).fromTo("transform", "scale(0.9)", "scale(1)").fromTo("opacity", 1, 1), d.fromTo("opacity", .01, .8), u.addElement(N).easing("cubic-bezier(0.250, 0.460, 0.450, 0.940)").duration(300).beforeAddClass("show-modal").addAnimation([d, C])
        }, Cn = N => on(N).duration(200).direction("reverse")
    }, 8362: (Jt, lt, R) => {
        "use strict";
        var r = R(2313), D = R(6435), ie = R(9800), te = R(520), j = R(4182), W = R(9808), Q = R(7609), Ne = R(655),
            ve = R(5419), me = function (ye) {
                function Te() {
                    return null !== ye && ye.apply(this, arguments) || this
                }

                return (0, Ne.ZT)(Te, ye), Te.prototype.overlaysWebView = function (Be) {
                    return (0, ve.DM)(this, "overlaysWebView", {sync: !0}, arguments)
                }, Te.prototype.styleDefault = function () {
                    return (0, ve.DM)(this, "styleDefault", {sync: !0}, arguments)
                }, Te.prototype.styleLightContent = function () {
                    return (0, ve.DM)(this, "styleLightContent", {sync: !0}, arguments)
                }, Te.prototype.styleBlackTranslucent = function () {
                    return (0, ve.DM)(this, "styleBlackTranslucent", {sync: !0}, arguments)
                }, Te.prototype.styleBlackOpaque = function () {
                    return (0, ve.DM)(this, "styleBlackOpaque", {sync: !0}, arguments)
                }, Te.prototype.backgroundColorByName = function (Be) {
                    return (0, ve.DM)(this, "backgroundColorByName", {sync: !0}, arguments)
                }, Te.prototype.backgroundColorByHexString = function (Be) {
                    return (0, ve.DM)(this, "backgroundColorByHexString", {sync: !0}, arguments)
                }, Te.prototype.hide = function () {
                    return (0, ve.DM)(this, "hide", {sync: !0}, arguments)
                }, Te.prototype.show = function () {
                    return (0, ve.DM)(this, "show", {sync: !0}, arguments)
                }, Object.defineProperty(Te.prototype, "isVisible", {
                    get: function () {
                        return (0, ve.J2)(this, "isVisible")
                    }, set: function (Be) {
                        (0, ve.Iq)(this, "isVisible", Be)
                    }, enumerable: !1, configurable: !0
                }), Te.pluginName = "StatusBar", Te.plugin = "cordova-plugin-statusbar", Te.pluginRef = "StatusBar", Te.repo = "https://github.com/apache/cordova-plugin-statusbar", Te.platforms = ["Android", "iOS", "Windows"], Te.\u0275fac = function () {
                    var Be;
                    return function (Dt) {
                        return (Be || (Be = D.n5z(Te)))(Dt || Te)
                    }
                }(), Te.\u0275prov = D.Yz7({
                    token: Te, factory: function (Be) {
                        return Te.\u0275fac(Be)
                    }
                }), Te
            }(ve.KY), ae = function (ye) {
                function Te() {
                    return null !== ye && ye.apply(this, arguments) || this
                }

                return (0, Ne.ZT)(Te, ye), Te.prototype.share = function (Be, tt, Dt, Ft) {
                    return (0, ve.DM)(this, "share", {successIndex: 4, errorIndex: 5}, arguments)
                }, Te.prototype.shareWithOptions = function (Be) {
                    return (0, ve.DM)(this, "shareWithOptions", {platforms: ["iOS", "Android"]}, arguments)
                }, Te.prototype.canShareVia = function (Be, tt, Dt, Ft, zt) {
                    return (0, ve.DM)(this, "canShareVia", {
                        successIndex: 5,
                        errorIndex: 6,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaTwitter = function (Be, tt, Dt) {
                    return (0, ve.DM)(this, "shareViaTwitter", {
                        successIndex: 3,
                        errorIndex: 4,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaFacebook = function (Be, tt, Dt) {
                    return (0, ve.DM)(this, "shareViaFacebook", {
                        successIndex: 3,
                        errorIndex: 4,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaFacebookWithPasteMessageHint = function (Be, tt, Dt, Ft) {
                    return (0, ve.DM)(this, "shareViaFacebookWithPasteMessageHint", {
                        successIndex: 4,
                        errorIndex: 5,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaInstagram = function (Be, tt) {
                    return (0, ve.DM)(this, "shareViaInstagram", {platforms: ["iOS", "Android"]}, arguments)
                }, Te.prototype.shareViaWhatsApp = function (Be, tt, Dt) {
                    return (0, ve.DM)(this, "shareViaWhatsApp", {
                        successIndex: 3,
                        errorIndex: 4,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaWhatsAppToReceiver = function (Be, tt, Dt, Ft) {
                    return (0, ve.DM)(this, "shareViaWhatsAppToReceiver", {
                        successIndex: 4,
                        errorIndex: 5,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.shareViaSMS = function (Be, tt) {
                    return (0, ve.DM)(this, "shareViaSMS", {platforms: ["iOS", "Android"]}, arguments)
                }, Te.prototype.canShareViaEmail = function () {
                    return (0, ve.DM)(this, "canShareViaEmail", {platforms: ["iOS", "Android"]}, arguments)
                }, Te.prototype.shareViaEmail = function (Be, tt, Dt, Ft, zt, dn) {
                    return (0, ve.DM)(this, "shareViaEmail", {
                        platforms: ["iOS", "Android"],
                        successIndex: 6,
                        errorIndex: 7
                    }, arguments)
                }, Te.prototype.shareVia = function (Be, tt, Dt, Ft, zt) {
                    return (0, ve.DM)(this, "shareVia", {
                        successIndex: 5,
                        errorIndex: 6,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.prototype.setIPadPopupCoordinates = function (Be) {
                    return (0, ve.DM)(this, "setIPadPopupCoordinates", {sync: !0, platforms: ["iOS"]}, arguments)
                }, Te.prototype.saveToPhotoAlbum = function (Be) {
                    return (0, ve.DM)(this, "saveToPhotoAlbum", {platforms: ["iOS"]}, arguments)
                }, Te.prototype.shareViaWhatsAppToPhone = function (Be, tt, Dt, Ft) {
                    return (0, ve.DM)(this, "shareViaWhatsAppToPhone", {
                        successIndex: 5,
                        errorIndex: 6,
                        platforms: ["iOS", "Android"]
                    }, arguments)
                }, Te.pluginName = "SocialSharing", Te.plugin = "cordova-plugin-x-socialsharing", Te.pluginRef = "plugins.socialsharing", Te.repo = "https://github.com/EddyVerbruggen/SocialSharing-PhoneGap-Plugin", Te.platforms = ["Android", "Browser", "iOS", "Windows", "Windows Phone"], Te.\u0275fac = function () {
                    var Be;
                    return function (Dt) {
                        return (Be || (Be = D.n5z(Te)))(Dt || Te)
                    }
                }(), Te.\u0275prov = D.Yz7({
                    token: Te, factory: function (Be) {
                        return Te.\u0275fac(Be)
                    }
                }), Te
            }(ve.KY), X = R(2916), M = function () {
                function ye(Te, Be, tt) {
                    try {
                        tt && "string" != typeof tt && (tt = Object.keys(tt).map(function (Dt) {
                            return Dt + "=" + tt[Dt]
                        }).join(",")), this._objectInstance = cordova.InAppBrowser.open(Te, Be, tt)
                    } catch (Dt) {
                        "undefined" != typeof window && window.open(Te, Be), console.warn("Native: InAppBrowser is not installed or you are running on a browser. Falling back to window.open.")
                    }
                }

                return ye.prototype._loadAfterBeforeload = function (Te) {
                    return (0, ve.e4)(this, "_loadAfterBeforeload", {sync: !0}, arguments)
                }, ye.prototype.show = function () {
                    return (0, ve.e4)(this, "show", {sync: !0}, arguments)
                }, ye.prototype.close = function () {
                    return (0, ve.e4)(this, "close", {sync: !0}, arguments)
                }, ye.prototype.hide = function () {
                    return (0, ve.e4)(this, "hide", {sync: !0}, arguments)
                }, ye.prototype.executeScript = function (Te) {
                    return (0, ve.e4)(this, "executeScript", {}, arguments)
                }, ye.prototype.insertCSS = function (Te) {
                    return (0, ve.e4)(this, "insertCSS", {}, arguments)
                }, ye.prototype.on = function (Te) {
                    var Be = this;
                    return function () {
                        if (!0 === (0, ve.G5)(Be)) return new X.y(function (tt) {
                            return Be._objectInstance.addEventListener(Te, tt.next.bind(tt)), function () {
                                return Be._objectInstance.removeEventListener(Te, tt.next.bind(tt))
                            }
                        })
                    }()
                }, ye.prototype.on = function (Te) {
                    var Be = this;
                    return function () {
                        if (!0 === (0, ve.G5)(Be)) return new X.y(function (tt) {
                            return Be._objectInstance.addEventListener(Te, tt.next.bind(tt)), function () {
                                return Be._objectInstance.removeEventListener(Te, tt.next.bind(tt))
                            }
                        })
                    }()
                }, ye
            }(), H = function (ye) {
                function Te() {
                    return null !== ye && ye.apply(this, arguments) || this
                }

                return (0, Ne.ZT)(Te, ye), Te.prototype.create = function (Be, tt, Dt) {
                    return new M(Be, tt, Dt)
                }, Te.pluginName = "InAppBrowser", Te.plugin = "cordova-plugin-inappbrowser", Te.pluginRef = "cordova.InAppBrowser", Te.repo = "https://github.com/apache/cordova-plugin-inappbrowser", Te.platforms = ["AmazonFire OS", "Android", "Browser", "iOS", "macOS", "Windows"], Te.\u0275fac = function () {
                    var Be;
                    return function (Dt) {
                        return (Be || (Be = D.n5z(Te)))(Dt || Te)
                    }
                }(), Te.\u0275prov = D.Yz7({
                    token: Te, factory: function (Be) {
                        return Te.\u0275fac(Be)
                    }
                }), Te
            }(ve.KY), F = R(3228), oe = function (ye) {
                function Te() {
                    return null !== ye && ye.apply(this, arguments) || this
                }

                return (0, Ne.ZT)(Te, ye), Te.prototype.isAvailable = function () {
                    return (0, F.DM)(this, "isAvailable", {}, arguments)
                }, Te.prototype.isDarkModeEnabled = function () {
                    return (0, F.DM)(this, "isDarkModeEnabled", {}, arguments)
                }, Te.pluginName = "ThemeDetection", Te.plugin = "cordova-plugin-theme-detection", Te.pluginRef = "cordova.plugins.ThemeDetection", Te.repo = "https://github.com/mariusbackes/cordova-plugin-theme-detection", Te.install = "cordova plugin add cordova-plugin-theme-detection", Te.installVariables = [], Te.platforms = ["iOS", "Android"], Te.\u0275fac = function () {
                    var Be;
                    return function (Dt) {
                        return (Be || (Be = D.n5z(Te)))(Dt || Te)
                    }
                }(), Te.\u0275prov = D.Yz7({
                    token: Te, factory: function (Be) {
                        return Te.\u0275fac(Be)
                    }
                }), Te
            }(F.On), ge = R(6787), Ie = R(3489);

        function he(ye) {
            return Te => Te.lift(new xe(ye))
        }

        class xe {
            constructor(Te) {
                this.value = Te
            }

            call(Te, Be) {
                return Be.subscribe(new Ue(Te, this.value))
            }
        }

        class Ue extends Ie.L {
            constructor(Te, Be) {
                super(Te), this.value = Be
            }

            _next(Te) {
                this.destination.next(this.value)
            }
        }

        var yt = function (ye) {
            function Te() {
                var Be = null !== ye && ye.apply(this, arguments) || this;
                return Be.Connection = {
                    UNKNOWN: "unknown",
                    ETHERNET: "ethernet",
                    WIFI: "wifi",
                    CELL_2G: "2g",
                    CELL_3G: "3g",
                    CELL_4G: "4g",
                    CELL: "cellular",
                    NONE: "none"
                }, Be
            }

            return (0, Ne.ZT)(Te, ye), Te.prototype.onChange = function () {
                var Be = this;
                return function () {
                    if (!0 === (0, F.gR)(Be)) return (0, ge.T)(Be.onConnect().pipe(he("connected")), Be.onDisconnect().pipe(he("disconnected")))
                }()
            }, Te.prototype.onDisconnect = function () {
                return (0, F.DM)(this, "onDisconnect", {
                    eventObservable: !0,
                    event: "offline",
                    element: "document"
                }, arguments)
            }, Te.prototype.onConnect = function () {
                return (0, F.DM)(this, "onConnect", {
                    eventObservable: !0,
                    event: "online",
                    element: "document"
                }, arguments)
            }, Object.defineProperty(Te.prototype, "type", {
                get: function () {
                    return (0, F.J2)(this, "type")
                }, set: function (Be) {
                    (0, F.Iq)(this, "type", Be)
                }, enumerable: !1, configurable: !0
            }), Object.defineProperty(Te.prototype, "downlinkMax", {
                get: function () {
                    return (0, F.J2)(this, "downlinkMax")
                }, set: function (Be) {
                    (0, F.Iq)(this, "downlinkMax", Be)
                }, enumerable: !1, configurable: !0
            }), Te.pluginName = "Network", Te.plugin = "cordova-plugin-network-information", Te.pluginRef = "navigator.connection", Te.repo = "https://github.com/apache/cordova-plugin-network-information", Te.platforms = ["Amazon Fire OS", "Android", "Browser", "iOS", "Windows"], Te.\u0275fac = function () {
                var Be;
                return function (Dt) {
                    return (Be || (Be = D.n5z(Te)))(Dt || Te)
                }
            }(), Te.\u0275prov = D.Yz7({
                token: Te, factory: function (Be) {
                    return Te.\u0275fac(Be)
                }
            }), Te
        }(F.On), Ce = R(5956), $e = R(4299), rt = R(2869), Xe = R(9485), Ee = R(9453);
        const ce = [{path: "", redirectTo: "", pathMatch: "full"}, {
            path: "home",
            loadChildren: () => R.e(3489).then(R.bind(R, 7212)).then(ye => ye.ExtractPageModule)
        }, {
            path: "intro",
            loadChildren: () => R.e(2944).then(R.bind(R, 2944)).then(ye => ye.IntroPageModule)
        }, {
            path: "donate",
            loadChildren: () => R.e(4251).then(R.bind(R, 4251)).then(ye => ye.DonatePageModule)
        }, {
            path: "withdraw",
            loadChildren: () => Promise.resolve().then(R.bind(R, 5002)).then(ye => ye.WithdrawPageModule)
        }, {path: "nft", loadChildren: () => R.e(7325).then(R.bind(R, 7325)).then(ye => ye.NftPageModule)}];
        let I = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye}), ye.\u0275inj = D.cJS({
                imports: [[ie.Bz.forRoot(ce, {
                    preloadingStrategy: ie.wm,
                    initialNavigation: "enabled"
                })], ie.Bz]
            }), ye
        })();
        var l = R(1086), f = R(3753), g = R(546), v = R(8349), w = R(1808);

        function P(ye, Te) {
            if (1 & ye) {
                const Be = D.EpF();
                D.TgZ(0, "ion-button", 8), D.NdJ("click", function () {
                    return D.CHM(Be), D.oxw(2).getAccessToken()
                }), D._uU(1, "Refresh "), D._UZ(2, "ion-ripple-effect"), D.qZA()
            }
        }

        function B(ye, Te) {
            1 & ye && D._UZ(0, "ion-spinner", 9)
        }

        function O(ye, Te) {
            if (1 & ye && (D.TgZ(0, "div", 2)(1, "div", 3), D._UZ(2, "img", 4), D.TgZ(3, "p", 5), D._uU(4, "No internet connection, please try again."), D.qZA(), D.YNc(5, P, 3, 0, "ion-button", 6), D.YNc(6, B, 1, 0, "ion-spinner", 7), D.qZA()()), 2 & ye) {
                const Be = D.oxw();
                D.xp6(2), D.MGl("src", "assets/logo-", Be.settings.THEME, ".svg", D.LSH), D.xp6(3), D.Q6J("ngIf", !Be.settingsLoading), D.xp6(1), D.Q6J("ngIf", Be.settingsLoading)
            }
        }

        function E(ye, Te) {
            if (1 & ye && (D.TgZ(0, "div", 2)(1, "div", 3), D._UZ(2, "img", 4), D.TgZ(3, "p", 5), D._uU(4, "Work on the game is underway, we will be back soon."), D.qZA()()()), 2 & ye) {
                const Be = D.oxw();
                D.xp6(2), D.MGl("src", "assets/logo-", Be.settings.THEME, ".svg", D.LSH)
            }
        }

        function Z(ye, Te) {
            if (1 & ye) {
                const Be = D.EpF();
                D.TgZ(0, "ion-button", 8), D.NdJ("click", function () {
                    D.CHM(Be);
                    const Dt = D.oxw(2);
                    return Dt.link(Dt.settings.googlePlay)
                }), D._uU(1, "Update now "), D._UZ(2, "ion-ripple-effect"), D.qZA()
            }
        }

        function ze(ye, Te) {
            if (1 & ye && (D.TgZ(0, "div", 2)(1, "div", 3), D._UZ(2, "img", 4), D.TgZ(3, "p", 5), D._uU(4, "Please update game to new version."), D.qZA(), D.YNc(5, Z, 3, 0, "ion-button", 6), D.qZA()()), 2 & ye) {
                const Be = D.oxw();
                D.xp6(2), D.MGl("src", "assets/logo-", Be.settings.THEME, ".svg", D.LSH), D.xp6(3), D.Q6J("ngIf", Be.settings.android)
            }
        }

        function Je(ye, Te) {
            if (1 & ye && (D.TgZ(0, "div", 2)(1, "div", 3), D._UZ(2, "img", 4), D.TgZ(3, "p", 5), D._UZ(4, "ion-spinner", 10), D._uU(5, " Loading data, please wait.."), D.qZA()()()), 2 & ye) {
                const Be = D.oxw();
                D.xp6(2), D.MGl("src", "assets/logo-", Be.settings.THEME, ".svg", D.LSH)
            }
        }

        const q = function (ye) {
            return {"back-drop-popup-show": ye}
        };

        function Le(ye, Te) {
            if (1 & ye && D._UZ(0, "div", 24), 2 & ye) {
                const Be = D.oxw(2);
                D.Q6J("ngClass", D.VKq(1, q, Be.settings.experiencePop))
            }
        }

        function ut(ye, Te) {
            if (1 & ye && D._UZ(0, "div", 24), 2 & ye) {
                const Be = D.oxw(2);
                D.Q6J("ngClass", D.VKq(1, q, Be.settings.giftPop))
            }
        }

        const Ye = function (ye) {
            return {"show-info-pop": ye}
        }, Mt = function (ye) {
            return {"popup-show": ye}
        }, _t = function (ye) {
            return {showAmount: ye}
        }, Pt = function (ye, Te, Be) {
            return {hideGift: ye, openGift: Te, giftShake: Be}
        };

        function Gt(ye, Te) {
            if (1 & ye) {
                const Be = D.EpF();
                D.TgZ(0, "ion-app")(1, "div", 11), D._UZ(2, "ion-icon", 12), D.TgZ(3, "div")(4, "ion-title"), D._uU(5, "Kokosy"), D.qZA(), D.TgZ(6, "p"), D._uU(7, "scc"), D.qZA()()(), D.YNc(8, Le, 1, 3, "div", 13), D.TgZ(9, "div", 14)(10, "div", 15), D._UZ(11, "img", 16), D.qZA()(), D.YNc(12, ut, 1, 3, "div", 13), D.TgZ(13, "div", 14)(14, "div", 17)(15, "button", 18), D.NdJ("click", function () {
                    return D.CHM(Be), D.oxw().hideGift()
                }), D._UZ(16, "ion-icon", 19)(17, "ion-ripple-effect"), D.qZA(), D.TgZ(18, "div", 20)(19, "p"), D._uU(20), D.qZA(), D._UZ(21, "img", 21), D.qZA(), D.TgZ(22, "img", 22), D.NdJ("click", function () {
                    return D.CHM(Be), D.oxw().openGift()
                }), D.qZA()()(), D.TgZ(23, "ion-content"), D._UZ(24, "ion-router-outlet", 23), D.qZA()()
            }
            if (2 & ye) {
                const Be = D.oxw();
                D.xp6(1), D.Q6J("ngClass", D.VKq(8, Ye, Be.settings.infoPop)), D.xp6(7), D.Q6J("ngIf", Be.settings.experiencePop), D.xp6(1), D.Q6J("ngClass", D.VKq(10, Mt, Be.settings.experiencePop)), D.xp6(3), D.Q6J("ngIf", Be.settings.giftPop), D.xp6(1), D.Q6J("ngClass", D.VKq(12, Mt, Be.settings.giftPop)), D.xp6(5), D.Q6J("ngClass", D.VKq(14, _t, Be.settings.hideGift)), D.xp6(2), D.hij("+ ", Be.settings.giftReward, ""), D.xp6(2), D.Q6J("ngClass", D.kEZ(16, Pt, Be.settings.hideGift, Be.settings.openGift, Be.settings.shakeGift))
            }
        }

        let yn = (() => {
            class ye {
                constructor(Be, tt, Dt, Ft, zt, dn, Bt, Ht, bn, fn, rn, gn, Hn) {
                    this.router = Be, this.CFS = tt, this.platform = Dt, this.navCtrl = Ft, this.statusBar = zt, this.route = dn, this.ref = Bt, this.themeDetection = Ht, this.settings = bn, this.service = fn, this.network = rn, this.iab = gn, this.vibration = Hn, this.darkMode = !1, this.selectedPath = "", this.noConnection = !1, this.updateApp = !1, this.settingsLoading = !0, this.appIsOnline = void 0
                }

                ngOnInit() {
                    return (0, Ne.mG)(this, void 0, void 0, function* () {
                        this.platform.ready().then(() => {
                            this.platform.is("android") ? (this.settings.android = !0, this.backButtonEvent()) : this.platform.is("ios") && (this.settings.ios = !0), this.getPath(), this.detectTheme(), this.getAccessToken()
                        }), this.checkInternetFunc().subscribe(Be => {
                            this.checkInterent = Be, 1 == this.checkInterent ? this.settings.slowInternet = !1 : (this.CFS.presentToast("Slow internet connection.", "bottom", 3e3, "wifi-outline"), this.settings.slowInternet = !0, this.settings.mine = !1)
                        })
                    })
                }

                checkInternetFunc() {
                    if (window && navigator && "onLine" in navigator) return this.appIsOnline = X.y.create(Be => {
                        Be.next(!0)
                    }).pipe(he(!0)), this.appIsOnline = this.platform.is("cordova") ? (0, ge.T)(this.network.onConnect().pipe(he(!0)), this.network.onDisconnect().pipe(he(!1))) : (0, ge.T)((0, l.of)(navigator.onLine), (0, f.R)(window, "online").pipe(he(!0)), (0, f.R)(window, "offline").pipe(he(!1))), this.appIsOnline
                }

                getAccessToken() {
                    this.settingsLoading = !0, this.service.getAccessToken().then(Be => {
                        Be.error ? (this.noConnection = !0, this.settingsLoading = !1) : Be && (this.settings.token = Be.access_token, this.getSettings(), this.refreshAccessToken())
                    })
                }

                refreshAccessToken() {
                    this.countDownDate = (new Date).getTime() + 3e6, this.tokenInterval = setInterval(() => {
                        let tt = (new Date).getTime();
                        this.distance = this.countDownDate - tt, this.distance < 0 && (clearInterval(this.tokenInterval), this.service.getAccessToken().then(Dt => {
                            Dt.error ? this.noConnection = !0 : Dt && (this.settings.token = Dt.access_token, this.refreshAccessToken(), this.getSettings())
                        }))
                    }, 1e3)
                }

                getSettings() {
                    this.service.getData("Settings").then(Be => {
                        if (Be.error) this.noConnection = !0, this.settingsLoading = !1; else if (Be) if (Be.values) {
                            Be.values.splice(3).forEach(Ft => {
                                if ("" !== Ft[0] && (this.settings.api = this.settings.api.concat(Ft[0])), "" !== Ft[1]) {
                                    let zt = {};
                                    zt.wallet = Ft[1], zt.nft = Ft[2], this.settings.wallets = this.settings.wallets.concat(zt)
                                }
                            });
                            let tt = this.service.convertData(Be.values)[0];
                            if (this.settings.membership = JSON.parse(localStorage.getItem("membership")), this.settings.membership && this.loadNFT(), this.settings.networkComplexitySetting = tt.NetworkComplexity > 10 || "NaN" === tt.NetworkComplexity || NaN === tt.NetworkComplexity || null === tt.NetworkComplexity || "" === tt.NetworkComplexity ? 1e-5 : tt.NetworkComplexity, this.settings.networkComplexity = tt.NetworkComplexity, this.settings.minWithdraw = parseInt(tt.MinWithdraw), this.settings.maxWithdraw = parseInt(tt.MaxWithdraw), this.settings.maxReward = parseInt(tt.MaxReward), this.settings.miningPool = parseInt(tt.MiningPool), this.settings.withdrawsLimitPerHour = parseInt(tt.WithdrawsLimitPerHour), this.settings.googlePlay = tt.GooglePlay, this.settings.technicalBreak = JSON.parse(tt.TechnicalBreak.toLowerCase()), tt.SupportedVersion > this.settings.version && (this.updateApp = !0), this.settings.highNetwork = JSON.parse(tt.HighNetwork.toLowerCase()), JSON.parse(tt.DisableFeatures.toLowerCase()) && this.settings.version >= parseInt(tt.ForVersion) && (this.settings.disableFeatures = !0), this.noConnection = !1, this.settingsLoading = !1, localStorage.getItem("usersCards")) this.settings.usersCards = JSON.parse(localStorage.getItem("usersCards")); else {
                                let Ft = this.settings.cards.find(zt => "Paper Graphic Card" == zt.name);
                                this.settings.usersCards = this.settings.usersCards.concat(Ft), localStorage.setItem("usersCards", JSON.stringify(this.settings.usersCards))
                            }
                            localStorage.getItem("usersNFT") && (this.settings.usersNFT = JSON.parse(localStorage.getItem("usersNFT")), console.log(this.settings.usersNFT)), localStorage.getItem("experience") && (this.settings.experience = JSON.parse(localStorage.getItem("experience"))), localStorage.getItem("xpProgress") && (this.settings.xpProgress = JSON.parse(localStorage.getItem("xpProgress"))), localStorage.getItem("minerSpeeds") && (this.settings.minerSpeeds = JSON.parse(localStorage.getItem("minerSpeeds"))), localStorage.getItem("level") && (this.settings.level = JSON.parse(localStorage.getItem("level"))), localStorage.getItem("hashRate") && (this.settings.hashRate = JSON.parse(localStorage.getItem("hashRate"))), localStorage.getItem("proNetwork") && (this.settings.proNetwork = JSON.parse(localStorage.getItem("proNetwork"))), localStorage.getItem("appIcon") && (this.settings.appIcon = JSON.parse(localStorage.getItem("appIcon"))), "false" === localStorage.getItem("intro") ? (this.settings.intro = !1, this.router.navigate(["/home"])) : this.router.navigate(["/intro"])
                        } else this.noConnection = !0, this.settingsLoading = !1
                    })
                }

                loadNFT() {
                    let Be = this.settings.membership;
                    this.service.getNFT(null == Be ? void 0 : Be.nft)
                }

                backButtonEvent() {
                    this.platform.backButton.subscribeWithPriority(0, () => {
                        this.routerOutlets.forEach(Be => (0, Ne.mG)(this, void 0, void 0, function* () {
                            this.selectedPath.includes("home") || this.navCtrl.back()
                        }))
                    })
                }

                link(Be) {
                    this.iab.create(Be, "_system")
                }

                getPath() {
                    this.selectedPath = this.router.url, this.router.events.subscribe(Be => {
                        Be && Be.url && (this.selectedPath = Be.url)
                    })
                }

                detectTheme() {
                    this.themeDetection.isAvailable().then(Be => {
                        Be.value && this.themeDetection.isDarkModeEnabled().then(tt => {
                            this.settings.THEME = tt.value, this.darkMode = tt.value, this.checkDarkTheme()
                        }).catch(tt => console.error(tt))
                    }).catch(Be => console.error(Be))
                }

                checkDarkTheme() {
                    !0 === this.darkMode ? (document.body.classList.toggle("dark"), this.statusBar.overlaysWebView(!1), this.statusBar.styleLightContent(), this.statusBar.backgroundColorByHexString("#000000"), NavigationBar.backgroundColorByHexString("#000000", !1)) : (this.statusBar.overlaysWebView(!1), this.statusBar.styleDefault(), this.statusBar.backgroundColorByHexString("#ffffff"), NavigationBar.backgroundColorByHexString("#ffffff", !0))
                }

                hideGift() {
                    this.vibration.vibrate(5), this.settings.giftPop = !1, setTimeout(() => {
                        this.settings.shakeGift = !0, this.settings.openGift = !1, this.settings.hideGift = !1, this.settings.giftPop = !0, this.vibration.vibrate([1, 50, 4, 50, 6, 50, 8, 50, 10])
                    }, 12e4)
                }

                openGift() {
                    this.settings.shakeGift && (this.settings.shakeGift = !1, setTimeout(() => {
                        this.settings.openGift = !0, this.vibration.vibrate([10, 50, 10, 50, 10]), setTimeout(() => {
                            this.settings.openGift = !1, setTimeout(() => {
                                let Be;
                                this.settings.hideGift = !0, this.settings.coins <= 100 ? Be = 100 : this.settings.coins <= 1e3 ? Be = 1e3 : this.settings.coins > 1e3 && (Be = 1e4), this.settings.giftReward = Math.floor(Math.random() * Be) / 100, this.settings.coins += this.settings.giftReward, window.localStorage.setItem("coins", JSON.stringify(this.settings.coins))
                            }, 80)
                        }, 450)
                    }, 50))
                }
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)(D.Y36(ie.F0), D.Y36(g.b), D.Y36(Q.t4), D.Y36(Q.SH), D.Y36(me), D.Y36(ie.gz), D.Y36(D.sBO), D.Y36(oe), D.Y36(v.Z), D.Y36(w.t), D.Y36(yt), D.Y36(H), D.Y36(Ce.w))
            }, ye.\u0275cmp = D.Xpm({
                type: ye,
                selectors: [["app-root"]],
                viewQuery: function (Be, tt) {
                    if (1 & Be && D.Gf(Q.jP, 5), 2 & Be) {
                        let Dt;
                        D.iGM(Dt = D.CRH()) && (tt.routerOutlets = Dt)
                    }
                },
                decls: 5,
                vars: 5,
                consts: [["class", "dataContainer", 4, "ngIf"], [4, "ngIf"], [1, "dataContainer"], [1, "dataBox"], ["loading", "lazy", "alt", "Logo", 2, "width", "auto", "height", "80px", 3, "src"], [2, "margin", "6px 0px 24px 0px"], ["class", "refresh ion-activatable ripple-parent", 3, "click", 4, "ngIf"], ["name", "lines", "style", "color: var(--ion-text-color); width: 22px; height: 22px; margin: 6px;", 4, "ngIf"], [1, "refresh", "ion-activatable", "ripple-parent", 3, "click"], ["name", "lines", 2, "color", "var(--ion-text-color)", "width", "22px", "height", "22px", "margin", "6px"], ["name", "lines", 2, "color", "var(--ion-text-color)", "width", "12px", "height", "12px", "margin", "0px 3px -2px 0px"], [1, "info-pop", 3, "ngClass"], ["name", "information-circle-outline"], ["class", "back-drop-popup", 3, "ngClass", 4, "ngIf"], [1, "popup-css", 3, "ngClass"], [1, "popup-inner"], ["src", "assets/icons/8.svg"], [1, "popup-inner", 2, "background-color", "var(--ion-background-color)", "border-radius", "24px", "box-shadow", "0px 2px 12px #00000020"], [1, "close-button", "ion-activatable", "ripple-parent", 3, "click"], ["name", "close-outline"], [1, "giftAmount", 3, "ngClass"], ["src", "assets/favicon.png"], ["src", "assets/icons/9.svg", 1, "gift-img", 3, "ngClass", "click"], ["Id", "content"], [1, "back-drop-popup", 3, "ngClass"]],
                template: function (Be, tt) {
                    1 & Be && (D.YNc(0, O, 7, 3, "div", 0), D.YNc(1, E, 5, 1, "div", 0), D.YNc(2, ze, 6, 2, "div", 0), D.YNc(3, Je, 6, 1, "div", 0), D.YNc(4, Gt, 25, 20, "ion-app", 1)), 2 & Be && (D.Q6J("ngIf", tt.noConnection), D.xp6(1), D.Q6J("ngIf", tt.settings.technicalBreak), D.xp6(1), D.Q6J("ngIf", tt.updateApp), D.xp6(1), D.Q6J("ngIf", tt.settingsLoading && !tt.noConnection), D.xp6(1), D.Q6J("ngIf", !(tt.updateApp || tt.settingsLoading || tt.settings.technicalBreak || tt.noConnection)))
                },
                directives: [W.O5, Q.YG, Q.H$, Q.PQ, Q.dr, W.mk, Q.gu, Q.wd, Q.W2, Q.jP],
                styles: [".back-drop-popup[_ngcontent-%COMP%]{position:fixed;top:0;right:0;bottom:0;left:0;height:120vh;background:#000000;opacity:0;z-index:99999}.back-drop-popup-show[_ngcontent-%COMP%]{opacity:.5}.info-pop[_ngcontent-%COMP%]{position:absolute;display:flex;z-index:999999;left:50%;transform:translate(-50%,-50%);bottom:-120px;width:300px;height:auto;background-color:var(--ion-text-color);border:0px solid var(--ion-border-color);border-radius:12px;box-shadow:0 2px 12px #00000020;padding:12px;margin:0;opacity:0;transition:all .8s cubic-bezier(.075,.82,.165,1)}.info-pop[_ngcontent-%COMP%]   ion-title[_ngcontent-%COMP%]{margin:0;padding:0 0 0 6px;font-size:22px}.info-pop[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0;padding:0 0 0 6px;font-size:14px}.info-pop[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{margin:0 0 -1px;font-size:20px}.show-info-pop[_ngcontent-%COMP%]{bottom:-10px;opacity:1}.popup-css[_ngcontent-%COMP%]{position:fixed;display:flex;z-index:999999;left:0;top:0;width:100%;height:100%;background-color:transparent;padding:0;opacity:0;-webkit-transform:scale(0);transition:all .8s cubic-bezier(.075,.82,.165,1)}.popup-show[_ngcontent-%COMP%]{-webkit-transform:scale(1);opacity:1}.popup-inner[_ngcontent-%COMP%]{padding:0;margin:auto;width:100%;width:80%;max-width:300px;text-align:center;position:relative}.popup-inner[_ngcontent-%COMP%]   .close-button[_ngcontent-%COMP%]{width:40px;height:40px;position:absolute;top:12px;left:12px;z-index:999999;box-shadow:none;background-color:var(--ion-text-color);color:var(--ion-background-color);--box-shadow: none;--background: var(--ion-border-color);--color: var(--ion-text-color);border-radius:50px;margin:0;padding:0;text-align:center}.popup-inner[_ngcontent-%COMP%]   .close-button[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:20px;margin:0 0 -3px}.popup-inner[_ngcontent-%COMP%]   .gift-img[_ngcontent-%COMP%]{transition:transform .8s cubic-bezier(.075,.82,.165,1);transform:scale(1);width:100%;z-index:10}.popup-inner[_ngcontent-%COMP%]   .giftShake[_ngcontent-%COMP%]{animation:vibrate-1 .3s linear infinite both}.popup-inner[_ngcontent-%COMP%]   .openGift[_ngcontent-%COMP%]{transform:scale(2)}.popup-inner[_ngcontent-%COMP%]   .hideGift[_ngcontent-%COMP%]{transform:scale(0)}.popup-inner[_ngcontent-%COMP%]   .giftAmount[_ngcontent-%COMP%]{position:fixed;top:50%;left:50%;max-width:290px;transform:translate(-50%,-50%);transition:transform .8s cubic-bezier(.075,.82,.165,1);opacity:0;background-color:var(--ion-border-color);padding:44px 14px 36px;border-radius:16px;display:flex}.popup-inner[_ngcontent-%COMP%]   .giftAmount[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:var(--ion-text-color);font-size:40px;margin:-9px 0 0;padding:0}.popup-inner[_ngcontent-%COMP%]   .giftAmount[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:22px;height:22px;margin:0 0 0 6px;border-radius:50px}.popup-inner[_ngcontent-%COMP%]   .showAmount[_ngcontent-%COMP%]{opacity:1}.popup-inner[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:60px;padding:0}.popup-inner[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:120px;margin:0 0 -40px;padding:0}@keyframes vibrate-1{0%{transform:translate(0)}20%{transform:translate(-2px,2px)}40%{transform:translate(-2px,-2px)}60%{transform:translate(2px,2px)}80%{transform:translate(2px,-2px)}to{transform:translate(0)}}.refresh[_ngcontent-%COMP%]{color:var(--ion-text-color);border:1px solid var(--ion-border-color);background-color:var(--ion-border-color);--background: var(--ion-border-color);text-transform:none!important;font-size:16px;border-radius:0%;--border-radius: 0%;--box-shadow: none;box-shadow:none;padding:0;height:40px;margin:0}.dataContainer[_ngcontent-%COMP%]{background-color:var(--ion-background-color);z-index:999999;width:100%;height:100vh;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.dataContainer[_ngcontent-%COMP%]   .dataBox[_ngcontent-%COMP%]{text-align:center!important;width:100%;text-align:center;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:var(--ion-text-color)}"]
            }), ye
        })();
        var Xt = R(5002);
        const Fn = [{path: "", component: R(9351).n}];
        let wn = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye}), ye.\u0275inj = D.cJS({imports: [[ie.Bz.forChild(Fn)], ie.Bz]}), ye
        })(), Nn = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye}), ye.\u0275inj = D.cJS({imports: [[W.ez, j.u5, Q.Pc, wn]]}), ye
        })();
        const Me = [{path: "", component: R(2177).k}];
        let ne = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye}), ye.\u0275inj = D.cJS({imports: [[ie.Bz.forChild(Me)], ie.Bz]}), ye
        })(), U = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye}), ye.\u0275inj = D.cJS({imports: [[W.ez, j.u5, Q.Pc, ne]]}), ye
        })(), de = (() => {
            class ye {
            }

            return ye.\u0275fac = function (Be) {
                return new (Be || ye)
            }, ye.\u0275mod = D.oAB({type: ye, bootstrap: [yn]}), ye.\u0275inj = D.cJS({
                providers: [{
                    provide: W.S$,
                    useClass: W.b0
                }, {provide: ie.wN, useClass: Q.r4}, me, ae, H, oe, yt, Ce.w, $e.T, rt.E, Ee.r, v.Z, w.t],
                imports: [[r.b2, Q.Pc.forRoot({}), W.ez, te.JF, r.Cu, I, j.u5, Xe.kz, Xt.WithdrawPageModule, Nn, U], ie.Bz]
            }), ye
        })();

        function Ge() {
            r.q6().bootstrapModule(de).catch(ye => console.log(ye))
        }

        "complete" === document.readyState ? Ge() : document.addEventListener("DOMContentLoaded", Ge)
    }, 240: function (Jt) {
        "use strict";
        !function (lt) {
            function R(v) {
                return parseInt(v) === v
            }

            function r(v) {
                if (!R(v.length)) return !1;
                for (var w = 0; w < v.length; w++) if (!R(v[w]) || v[w] < 0 || v[w] > 255) return !1;
                return !0
            }

            function D(v, w) {
                if (v.buffer && ArrayBuffer.isView(v) && "Uint8Array" === v.name) return w && (v = v.slice ? v.slice() : Array.prototype.slice.call(v)), v;
                if (Array.isArray(v)) {
                    if (!r(v)) throw new Error("Array contains invalid value: " + v);
                    return new Uint8Array(v)
                }
                if (R(v.length) && r(v)) return new Uint8Array(v);
                throw new Error("unsupported array-like object")
            }

            function ie(v) {
                return new Uint8Array(v)
            }

            function te(v, w, P, B, O) {
                (null != B || null != O) && (v = v.slice ? v.slice(B, O) : Array.prototype.slice.call(v, B, O)), w.set(v, P)
            }

            var w, j = {
                    toBytes: function v(P) {
                        var B = [], O = 0;
                        for (P = encodeURI(P); O < P.length;) {
                            var E = P.charCodeAt(O++);
                            37 === E ? (B.push(parseInt(P.substr(O, 2), 16)), O += 2) : B.push(E)
                        }
                        return D(B)
                    }, fromBytes: function w(P) {
                        for (var B = [], O = 0; O < P.length;) {
                            var E = P[O];
                            E < 128 ? (B.push(String.fromCharCode(E)), O++) : E > 191 && E < 224 ? (B.push(String.fromCharCode((31 & E) << 6 | 63 & P[O + 1])), O += 2) : (B.push(String.fromCharCode((15 & E) << 12 | (63 & P[O + 1]) << 6 | 63 & P[O + 2])), O += 3)
                        }
                        return B.join("")
                    }
                }, W = (w = "0123456789abcdef", {
                    toBytes: function v(B) {
                        for (var O = [], E = 0; E < B.length; E += 2) O.push(parseInt(B.substr(E, 2), 16));
                        return O
                    }, fromBytes: function P(B) {
                        for (var O = [], E = 0; E < B.length; E++) {
                            var Z = B[E];
                            O.push(w[(240 & Z) >> 4] + w[15 & Z])
                        }
                        return O.join("")
                    }
                }), Q = {16: 10, 24: 12, 32: 14},
                Ne = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
                ve = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
                me = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
                ae = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
                X = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
                M = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
                H = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
                F = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
                oe = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
                ge = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
                Ie = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
                he = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
                xe = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
                Ue = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
                it = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

            function yt(v) {
                for (var w = [], P = 0; P < v.length; P += 4) w.push(v[P] << 24 | v[P + 1] << 16 | v[P + 2] << 8 | v[P + 3]);
                return w
            }

            var Ce = function (v) {
                if (!(this instanceof Ce)) throw Error("AES must be instanitated with `new`");
                Object.defineProperty(this, "key", {value: D(v, !0)}), this._prepare()
            };
            Ce.prototype._prepare = function () {
                var v = Q[this.key.length];
                if (null == v) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
                this._Ke = [], this._Kd = [];
                for (var w = 0; w <= v; w++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
                var E, P = 4 * (v + 1), B = this.key.length / 4, O = yt(this.key);
                for (w = 0; w < B; w++) this._Ke[E = w >> 2][w % 4] = O[w], this._Kd[v - E][w % 4] = O[w];
                for (var Je, Z = 0, ze = B; ze < P;) {
                    if (O[0] ^= ve[(Je = O[B - 1]) >> 16 & 255] << 24 ^ ve[Je >> 8 & 255] << 16 ^ ve[255 & Je] << 8 ^ ve[Je >> 24 & 255] ^ Ne[Z] << 24, Z += 1, 8 != B) for (w = 1; w < B; w++) O[w] ^= O[w - 1]; else {
                        for (w = 1; w < B / 2; w++) O[w] ^= O[w - 1];
                        for (O[B / 2] ^= ve[255 & (Je = O[B / 2 - 1])] ^ ve[Je >> 8 & 255] << 8 ^ ve[Je >> 16 & 255] << 16 ^ ve[Je >> 24 & 255] << 24, w = B / 2 + 1; w < B; w++) O[w] ^= O[w - 1]
                    }
                    for (w = 0; w < B && ze < P;) this._Ke[q = ze >> 2][Le = ze % 4] = O[w], this._Kd[v - q][Le] = O[w++], ze++
                }
                for (var q = 1; q < v; q++) for (var Le = 0; Le < 4; Le++) this._Kd[q][Le] = he[(Je = this._Kd[q][Le]) >> 24 & 255] ^ xe[Je >> 16 & 255] ^ Ue[Je >> 8 & 255] ^ it[255 & Je]
            }, Ce.prototype.encrypt = function (v) {
                if (16 != v.length) throw new Error("invalid plaintext size (must be 16 bytes)");
                for (var w = this._Ke.length - 1, P = [0, 0, 0, 0], B = yt(v), O = 0; O < 4; O++) B[O] ^= this._Ke[0][O];
                for (var E = 1; E < w; E++) {
                    for (O = 0; O < 4; O++) P[O] = ae[B[O] >> 24 & 255] ^ X[B[(O + 1) % 4] >> 16 & 255] ^ M[B[(O + 2) % 4] >> 8 & 255] ^ H[255 & B[(O + 3) % 4]] ^ this._Ke[E][O];
                    B = P.slice()
                }
                var ze, Z = ie(16);
                for (O = 0; O < 4; O++) Z[4 * O] = 255 & (ve[B[O] >> 24 & 255] ^ (ze = this._Ke[w][O]) >> 24), Z[4 * O + 1] = 255 & (ve[B[(O + 1) % 4] >> 16 & 255] ^ ze >> 16), Z[4 * O + 2] = 255 & (ve[B[(O + 2) % 4] >> 8 & 255] ^ ze >> 8), Z[4 * O + 3] = 255 & (ve[255 & B[(O + 3) % 4]] ^ ze);
                return Z
            }, Ce.prototype.decrypt = function (v) {
                if (16 != v.length) throw new Error("invalid ciphertext size (must be 16 bytes)");
                for (var w = this._Kd.length - 1, P = [0, 0, 0, 0], B = yt(v), O = 0; O < 4; O++) B[O] ^= this._Kd[0][O];
                for (var E = 1; E < w; E++) {
                    for (O = 0; O < 4; O++) P[O] = F[B[O] >> 24 & 255] ^ oe[B[(O + 3) % 4] >> 16 & 255] ^ ge[B[(O + 2) % 4] >> 8 & 255] ^ Ie[255 & B[(O + 1) % 4]] ^ this._Kd[E][O];
                    B = P.slice()
                }
                var ze, Z = ie(16);
                for (O = 0; O < 4; O++) Z[4 * O] = 255 & (me[B[O] >> 24 & 255] ^ (ze = this._Kd[w][O]) >> 24), Z[4 * O + 1] = 255 & (me[B[(O + 3) % 4] >> 16 & 255] ^ ze >> 16), Z[4 * O + 2] = 255 & (me[B[(O + 2) % 4] >> 8 & 255] ^ ze >> 8), Z[4 * O + 3] = 255 & (me[255 & B[(O + 1) % 4]] ^ ze);
                return Z
            };
            var $e = function (v) {
                if (!(this instanceof $e)) throw Error("AES must be instanitated with `new`");
                this.description = "Electronic Code Block", this.name = "ecb", this._aes = new Ce(v)
            };
            $e.prototype.encrypt = function (v) {
                if ((v = D(v)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
                for (var w = ie(v.length), P = ie(16), B = 0; B < v.length; B += 16) te(v, P, 0, B, B + 16), te(P = this._aes.encrypt(P), w, B);
                return w
            }, $e.prototype.decrypt = function (v) {
                if ((v = D(v)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
                for (var w = ie(v.length), P = ie(16), B = 0; B < v.length; B += 16) te(v, P, 0, B, B + 16), te(P = this._aes.decrypt(P), w, B);
                return w
            };
            var rt = function (v, w) {
                if (!(this instanceof rt)) throw Error("AES must be instanitated with `new`");
                if (this.description = "Cipher Block Chaining", this.name = "cbc", w) {
                    if (16 != w.length) throw new Error("invalid initialation vector size (must be 16 bytes)")
                } else w = ie(16);
                this._lastCipherblock = D(w, !0), this._aes = new Ce(v)
            };
            rt.prototype.encrypt = function (v) {
                if ((v = D(v)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
                for (var w = ie(v.length), P = ie(16), B = 0; B < v.length; B += 16) {
                    te(v, P, 0, B, B + 16);
                    for (var O = 0; O < 16; O++) P[O] ^= this._lastCipherblock[O];
                    this._lastCipherblock = this._aes.encrypt(P), te(this._lastCipherblock, w, B)
                }
                return w
            }, rt.prototype.decrypt = function (v) {
                if ((v = D(v)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
                for (var w = ie(v.length), P = ie(16), B = 0; B < v.length; B += 16) {
                    te(v, P, 0, B, B + 16), P = this._aes.decrypt(P);
                    for (var O = 0; O < 16; O++) w[B + O] = P[O] ^ this._lastCipherblock[O];
                    te(v, this._lastCipherblock, 0, B, B + 16)
                }
                return w
            };
            var Xe = function (v, w, P) {
                if (!(this instanceof Xe)) throw Error("AES must be instanitated with `new`");
                if (this.description = "Cipher Feedback", this.name = "cfb", w) {
                    if (16 != w.length) throw new Error("invalid initialation vector size (must be 16 size)")
                } else w = ie(16);
                P || (P = 1), this.segmentSize = P, this._shiftRegister = D(w, !0), this._aes = new Ce(v)
            };
            Xe.prototype.encrypt = function (v) {
                if (v.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");
                for (var P, w = D(v, !0), B = 0; B < w.length; B += this.segmentSize) {
                    P = this._aes.encrypt(this._shiftRegister);
                    for (var O = 0; O < this.segmentSize; O++) w[B + O] ^= P[O];
                    te(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), te(w, this._shiftRegister, 16 - this.segmentSize, B, B + this.segmentSize)
                }
                return w
            }, Xe.prototype.decrypt = function (v) {
                if (v.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");
                for (var P, w = D(v, !0), B = 0; B < w.length; B += this.segmentSize) {
                    P = this._aes.encrypt(this._shiftRegister);
                    for (var O = 0; O < this.segmentSize; O++) w[B + O] ^= P[O];
                    te(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), te(v, this._shiftRegister, 16 - this.segmentSize, B, B + this.segmentSize)
                }
                return w
            };
            var Ee = function (v, w) {
                if (!(this instanceof Ee)) throw Error("AES must be instanitated with `new`");
                if (this.description = "Output Feedback", this.name = "ofb", w) {
                    if (16 != w.length) throw new Error("invalid initialation vector size (must be 16 bytes)")
                } else w = ie(16);
                this._lastPrecipher = D(w, !0), this._lastPrecipherIndex = 16, this._aes = new Ce(v)
            };
            Ee.prototype.encrypt = function (v) {
                for (var w = D(v, !0), P = 0; P < w.length; P++) 16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), w[P] ^= this._lastPrecipher[this._lastPrecipherIndex++];
                return w
            }, Ee.prototype.decrypt = Ee.prototype.encrypt;
            var ce = function (v) {
                if (!(this instanceof ce)) throw Error("Counter must be instanitated with `new`");
                0 !== v && !v && (v = 1), "number" == typeof v ? (this._counter = ie(16), this.setValue(v)) : this.setBytes(v)
            };
            ce.prototype.setValue = function (v) {
                if ("number" != typeof v || parseInt(v) != v) throw new Error("invalid counter value (must be an integer)");
                for (var w = 15; w >= 0; --w) this._counter[w] = v % 256, v >>= 8
            }, ce.prototype.setBytes = function (v) {
                if (16 != (v = D(v, !0)).length) throw new Error("invalid counter bytes size (must be 16 bytes)");
                this._counter = v
            }, ce.prototype.increment = function () {
                for (var v = 15; v >= 0; v--) {
                    if (255 !== this._counter[v]) {
                        this._counter[v]++;
                        break
                    }
                    this._counter[v] = 0
                }
            };
            var I = function (v, w) {
                if (!(this instanceof I)) throw Error("AES must be instanitated with `new`");
                this.description = "Counter", this.name = "ctr", w instanceof ce || (w = new ce(w)), this._counter = w, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new Ce(v)
            };
            I.prototype.encrypt = function (v) {
                for (var w = D(v, !0), P = 0; P < w.length; P++) 16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), w[P] ^= this._remainingCounter[this._remainingCounterIndex++];
                return w
            }, I.prototype.decrypt = I.prototype.encrypt;
            var g = {
                AES: Ce,
                Counter: ce,
                ModeOfOperation: {ecb: $e, cbc: rt, cfb: Xe, ofb: Ee, ctr: I},
                utils: {hex: W, utf8: j},
                padding: {
                    pkcs7: {
                        pad: function l(v) {
                            var w = 16 - (v = D(v, !0)).length % 16, P = ie(v.length + w);
                            te(v, P);
                            for (var B = v.length; B < P.length; B++) P[B] = w;
                            return P
                        }, strip: function f(v) {
                            if ((v = D(v, !0)).length < 16) throw new Error("PKCS#7 invalid length");
                            var w = v[v.length - 1];
                            if (w > 16) throw new Error("PKCS#7 padding byte out of range");
                            for (var P = v.length - w, B = 0; B < w; B++) if (v[P + B] !== w) throw new Error("PKCS#7 invalid padding byte");
                            var O = ie(P);
                            return te(v, O, 0, 0, P), O
                        }
                    }
                },
                _arrayTest: {coerceArray: D, createArray: ie, copyArray: te}
            };
            Jt.exports = g
        }()
    }, 988: Jt => {
        "use strict";
        for (var lt = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", R = {}, r = 0; r < lt.length; r++) {
            var D = lt.charAt(r);
            if (void 0 !== R[D]) throw new TypeError(D + " is ambiguous");
            R[D] = r
        }

        function ie(H) {
            var F = H >> 25;
            return (33554431 & H) << 5 ^ 996825010 & -(F >> 0 & 1) ^ 642813549 & -(F >> 1 & 1) ^ 513874426 & -(F >> 2 & 1) ^ 1027748829 & -(F >> 3 & 1) ^ 705979059 & -(F >> 4 & 1)
        }

        function te(H) {
            for (var F = 1, oe = 0; oe < H.length; ++oe) {
                var ge = H.charCodeAt(oe);
                if (ge < 33 || ge > 126) return "Invalid prefix (" + H + ")";
                F = ie(F) ^ ge >> 5
            }
            for (F = ie(F), oe = 0; oe < H.length; ++oe) {
                var Ie = H.charCodeAt(oe);
                F = ie(F) ^ 31 & Ie
            }
            return F
        }

        function W(H, F) {
            if (H.length < 8) return H + " too short";
            if (H.length > (F = F || 90)) return "Exceeds length limit";
            var oe = H.toLowerCase(), ge = H.toUpperCase();
            if (H !== oe && H !== ge) return "Mixed-case string " + H;
            var Ie = (H = oe).lastIndexOf("1");
            if (-1 === Ie) return "No separator character for " + H;
            if (0 === Ie) return "Missing prefix for " + H;
            var he = H.slice(0, Ie), xe = H.slice(Ie + 1);
            if (xe.length < 6) return "Data too short";
            var Ue = te(he);
            if ("string" == typeof Ue) return Ue;
            for (var it = [], yt = 0; yt < xe.length; ++yt) {
                var Ce = xe.charAt(yt), $e = R[Ce];
                if (void 0 === $e) return "Unknown character " + Ce;
                Ue = ie(Ue) ^ $e, !(yt + 6 >= xe.length) && it.push($e)
            }
            return 1 !== Ue ? "Invalid checksum for " + H : {prefix: he, words: it}
        }

        function ve(H, F, oe, ge) {
            for (var Ie = 0, he = 0, xe = (1 << oe) - 1, Ue = [], it = 0; it < H.length; ++it) for (Ie = Ie << F | H[it], he += F; he >= oe;) Ue.push(Ie >> (he -= oe) & xe);
            if (ge) he > 0 && Ue.push(Ie << oe - he & xe); else {
                if (he >= F) return "Excess padding";
                if (Ie << oe - he & xe) return "Non-zero padding"
            }
            return Ue
        }

        Jt.exports = {
            decodeUnsafe: function Q() {
                var H = W.apply(null, arguments);
                if ("object" == typeof H) return H
            }, decode: function Ne(H) {
                var F = W.apply(null, arguments);
                if ("object" == typeof F) return F;
                throw new Error(F)
            }, encode: function j(H, F, oe) {
                if (H.length + 7 + F.length > (oe = oe || 90)) throw new TypeError("Exceeds length limit");
                var ge = te(H = H.toLowerCase());
                if ("string" == typeof ge) throw new Error(ge);
                for (var Ie = H + "1", he = 0; he < F.length; ++he) {
                    var xe = F[he];
                    if (xe >> 5 != 0) throw new Error("Non 5-bit word");
                    ge = ie(ge) ^ xe, Ie += lt.charAt(xe)
                }
                for (he = 0; he < 6; ++he) ge = ie(ge);
                for (ge ^= 1, he = 0; he < 6; ++he) Ie += lt.charAt(ge >> 5 * (5 - he) & 31);
                return Ie
            }, toWordsUnsafe: function me(H) {
                var F = ve(H, 8, 5, !0);
                if (Array.isArray(F)) return F
            }, toWords: function ae(H) {
                var F = ve(H, 8, 5, !0);
                if (Array.isArray(F)) return F;
                throw new Error(F)
            }, fromWordsUnsafe: function X(H) {
                var F = ve(H, 5, 8, !1);
                if (Array.isArray(F)) return F
            }, fromWords: function M(H) {
                var F = ve(H, 5, 8, !1);
                if (Array.isArray(F)) return F;
                throw new Error(F)
            }
        }
    }, 8538: function (Jt, lt, R) {
        !function (r, D) {
            "use strict";

            function ie(I, l) {
                if (!I) throw new Error(l || "Assertion failed")
            }

            function te(I, l) {
                I.super_ = l;
                var f = function () {
                };
                f.prototype = l.prototype, I.prototype = new f, I.prototype.constructor = I
            }

            function j(I, l, f) {
                if (j.isBN(I)) return I;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== I && (("le" === l || "be" === l) && (f = l, l = 10), this._init(I || 0, l || 10, f || "be"))
            }

            var W;
            "object" == typeof r ? r.exports = j : D.BN = j, j.BN = j, j.wordSize = 26;
            try {
                W = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : R(6601).Buffer
            } catch (I) {
            }

            function Q(I, l) {
                var f = I.charCodeAt(l);
                return f >= 48 && f <= 57 ? f - 48 : f >= 65 && f <= 70 ? f - 55 : f >= 97 && f <= 102 ? f - 87 : void ie(!1, "Invalid character in " + I)
            }

            function Ne(I, l, f) {
                var g = Q(I, f);
                return f - 1 >= l && (g |= Q(I, f - 1) << 4), g
            }

            function ve(I, l, f, g) {
                for (var v = 0, w = 0, P = Math.min(I.length, f), B = l; B < P; B++) {
                    var O = I.charCodeAt(B) - 48;
                    v *= g, w = O >= 49 ? O - 49 + 10 : O >= 17 ? O - 17 + 10 : O, ie(O >= 0 && w < g, "Invalid character"), v += w
                }
                return v
            }

            function me(I, l) {
                I.words = l.words, I.length = l.length, I.negative = l.negative, I.red = l.red
            }

            if (j.isBN = function (l) {
                return l instanceof j || null !== l && "object" == typeof l && l.constructor.wordSize === j.wordSize && Array.isArray(l.words)
            }, j.max = function (l, f) {
                return l.cmp(f) > 0 ? l : f
            }, j.min = function (l, f) {
                return l.cmp(f) < 0 ? l : f
            }, j.prototype._init = function (l, f, g) {
                if ("number" == typeof l) return this._initNumber(l, f, g);
                if ("object" == typeof l) return this._initArray(l, f, g);
                "hex" === f && (f = 16), ie(f === (0 | f) && f >= 2 && f <= 36);
                var v = 0;
                "-" === (l = l.toString().replace(/\s+/g, ""))[0] && (v++, this.negative = 1), v < l.length && (16 === f ? this._parseHex(l, v, g) : (this._parseBase(l, f, v), "le" === g && this._initArray(this.toArray(), f, g)))
            }, j.prototype._initNumber = function (l, f, g) {
                l < 0 && (this.negative = 1, l = -l), l < 67108864 ? (this.words = [67108863 & l], this.length = 1) : l < 4503599627370496 ? (this.words = [67108863 & l, l / 67108864 & 67108863], this.length = 2) : (ie(l < 9007199254740992), this.words = [67108863 & l, l / 67108864 & 67108863, 1], this.length = 3), "le" === g && this._initArray(this.toArray(), f, g)
            }, j.prototype._initArray = function (l, f, g) {
                if (ie("number" == typeof l.length), l.length <= 0) return this.words = [0], this.length = 1, this;
                this.length = Math.ceil(l.length / 3), this.words = new Array(this.length);
                for (var v = 0; v < this.length; v++) this.words[v] = 0;
                var w, P, B = 0;
                if ("be" === g) for (v = l.length - 1, w = 0; v >= 0; v -= 3) this.words[w] |= (P = l[v] | l[v - 1] << 8 | l[v - 2] << 16) << B & 67108863, this.words[w + 1] = P >>> 26 - B & 67108863, (B += 24) >= 26 && (B -= 26, w++); else if ("le" === g) for (v = 0, w = 0; v < l.length; v += 3) this.words[w] |= (P = l[v] | l[v + 1] << 8 | l[v + 2] << 16) << B & 67108863, this.words[w + 1] = P >>> 26 - B & 67108863, (B += 24) >= 26 && (B -= 26, w++);
                return this._strip()
            }, j.prototype._parseHex = function (l, f, g) {
                this.length = Math.ceil((l.length - f) / 6), this.words = new Array(this.length);
                for (var v = 0; v < this.length; v++) this.words[v] = 0;
                var B, w = 0, P = 0;
                if ("be" === g) for (v = l.length - 1; v >= f; v -= 2) B = Ne(l, f, v) << w, this.words[P] |= 67108863 & B, w >= 18 ? (w -= 18, this.words[P += 1] |= B >>> 26) : w += 8; else for (v = (l.length - f) % 2 == 0 ? f + 1 : f; v < l.length; v += 2) B = Ne(l, f, v) << w, this.words[P] |= 67108863 & B, w >= 18 ? (w -= 18, this.words[P += 1] |= B >>> 26) : w += 8;
                this._strip()
            }, j.prototype._parseBase = function (l, f, g) {
                this.words = [0], this.length = 1;
                for (var v = 0, w = 1; w <= 67108863; w *= f) v++;
                v--, w = w / f | 0;
                for (var P = l.length - g, B = P % v, O = Math.min(P, P - B) + g, E = 0, Z = g; Z < O; Z += v) E = ve(l, Z, Z + v, f), this.imuln(w), this.words[0] + E < 67108864 ? this.words[0] += E : this._iaddn(E);
                if (0 !== B) {
                    var ze = 1;
                    for (E = ve(l, Z, l.length, f), Z = 0; Z < B; Z++) ze *= f;
                    this.imuln(ze), this.words[0] + E < 67108864 ? this.words[0] += E : this._iaddn(E)
                }
                this._strip()
            }, j.prototype.copy = function (l) {
                l.words = new Array(this.length);
                for (var f = 0; f < this.length; f++) l.words[f] = this.words[f];
                l.length = this.length, l.negative = this.negative, l.red = this.red
            }, j.prototype._move = function (l) {
                me(l, this)
            }, j.prototype.clone = function () {
                var l = new j(null);
                return this.copy(l), l
            }, j.prototype._expand = function (l) {
                for (; this.length < l;) this.words[this.length++] = 0;
                return this
            }, j.prototype._strip = function () {
                for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
                return this._normSign()
            }, j.prototype._normSign = function () {
                return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
            }, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
                j.prototype[Symbol.for("nodejs.util.inspect.custom")] = ae
            } catch (I) {
                j.prototype.inspect = ae
            } else j.prototype.inspect = ae;

            function ae() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }

            var X = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                M = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                H = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

            function ge(I, l, f) {
                f.negative = l.negative ^ I.negative;
                var g = I.length + l.length | 0;
                f.length = g, g = g - 1 | 0;
                var v = 0 | I.words[0], w = 0 | l.words[0], P = v * w, O = P / 67108864 | 0;
                f.words[0] = 67108863 & P;
                for (var E = 1; E < g; E++) {
                    for (var Z = O >>> 26, ze = 67108863 & O, Je = Math.min(E, l.length - 1), q = Math.max(0, E - I.length + 1); q <= Je; q++) Z += (P = (v = 0 | I.words[E - q | 0]) * (w = 0 | l.words[q]) + ze) / 67108864 | 0, ze = 67108863 & P;
                    f.words[E] = 0 | ze, O = 0 | Z
                }
                return 0 !== O ? f.words[E] = 0 | O : f.length--, f._strip()
            }

            j.prototype.toString = function (l, f) {
                var g;
                if (f = 0 | f || 1, 16 === (l = l || 10) || "hex" === l) {
                    g = "";
                    for (var v = 0, w = 0, P = 0; P < this.length; P++) {
                        var B = this.words[P], O = (16777215 & (B << v | w)).toString(16);
                        w = B >>> 24 - v & 16777215, (v += 2) >= 26 && (v -= 26, P--), g = 0 !== w || P !== this.length - 1 ? X[6 - O.length] + O + g : O + g
                    }
                    for (0 !== w && (g = w.toString(16) + g); g.length % f != 0;) g = "0" + g;
                    return 0 !== this.negative && (g = "-" + g), g
                }
                if (l === (0 | l) && l >= 2 && l <= 36) {
                    var E = M[l], Z = H[l];
                    g = "";
                    var ze = this.clone();
                    for (ze.negative = 0; !ze.isZero();) {
                        var Je = ze.modrn(Z).toString(l);
                        g = (ze = ze.idivn(Z)).isZero() ? Je + g : X[E - Je.length] + Je + g
                    }
                    for (this.isZero() && (g = "0" + g); g.length % f != 0;) g = "0" + g;
                    return 0 !== this.negative && (g = "-" + g), g
                }
                ie(!1, "Base should be between 2 and 36")
            }, j.prototype.toNumber = function () {
                var l = this.words[0];
                return 2 === this.length ? l += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? l += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && ie(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -l : l
            }, j.prototype.toJSON = function () {
                return this.toString(16, 2)
            }, W && (j.prototype.toBuffer = function (l, f) {
                return this.toArrayLike(W, l, f)
            }), j.prototype.toArray = function (l, f) {
                return this.toArrayLike(Array, l, f)
            }, j.prototype.toArrayLike = function (l, f, g) {
                this._strip();
                var v = this.byteLength(), w = g || Math.max(1, v);
                ie(v <= w, "byte array longer than desired length"), ie(w > 0, "Requested array length <= 0");
                var P = function (l, f) {
                    return l.allocUnsafe ? l.allocUnsafe(f) : new l(f)
                }(l, w);
                return this["_toArrayLike" + ("le" === f ? "LE" : "BE")](P, v), P
            }, j.prototype._toArrayLikeLE = function (l, f) {
                for (var g = 0, v = 0, w = 0, P = 0; w < this.length; w++) {
                    var B = this.words[w] << P | v;
                    l[g++] = 255 & B, g < l.length && (l[g++] = B >> 8 & 255), g < l.length && (l[g++] = B >> 16 & 255), 6 === P ? (g < l.length && (l[g++] = B >> 24 & 255), v = 0, P = 0) : (v = B >>> 24, P += 2)
                }
                if (g < l.length) for (l[g++] = v; g < l.length;) l[g++] = 0
            }, j.prototype._toArrayLikeBE = function (l, f) {
                for (var g = l.length - 1, v = 0, w = 0, P = 0; w < this.length; w++) {
                    var B = this.words[w] << P | v;
                    l[g--] = 255 & B, g >= 0 && (l[g--] = B >> 8 & 255), g >= 0 && (l[g--] = B >> 16 & 255), 6 === P ? (g >= 0 && (l[g--] = B >> 24 & 255), v = 0, P = 0) : (v = B >>> 24, P += 2)
                }
                if (g >= 0) for (l[g--] = v; g >= 0;) l[g--] = 0
            }, j.prototype._countBits = Math.clz32 ? function (l) {
                return 32 - Math.clz32(l)
            } : function (l) {
                var f = l, g = 0;
                return f >= 4096 && (g += 13, f >>>= 13), f >= 64 && (g += 7, f >>>= 7), f >= 8 && (g += 4, f >>>= 4), f >= 2 && (g += 2, f >>>= 2), g + f
            }, j.prototype._zeroBits = function (l) {
                if (0 === l) return 26;
                var f = l, g = 0;
                return 0 == (8191 & f) && (g += 13, f >>>= 13), 0 == (127 & f) && (g += 7, f >>>= 7), 0 == (15 & f) && (g += 4, f >>>= 4), 0 == (3 & f) && (g += 2, f >>>= 2), 0 == (1 & f) && g++, g
            }, j.prototype.bitLength = function () {
                var f = this._countBits(this.words[this.length - 1]);
                return 26 * (this.length - 1) + f
            }, j.prototype.zeroBits = function () {
                if (this.isZero()) return 0;
                for (var l = 0, f = 0; f < this.length; f++) {
                    var g = this._zeroBits(this.words[f]);
                    if (l += g, 26 !== g) break
                }
                return l
            }, j.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }, j.prototype.toTwos = function (l) {
                return 0 !== this.negative ? this.abs().inotn(l).iaddn(1) : this.clone()
            }, j.prototype.fromTwos = function (l) {
                return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone()
            }, j.prototype.isNeg = function () {
                return 0 !== this.negative
            }, j.prototype.neg = function () {
                return this.clone().ineg()
            }, j.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }, j.prototype.iuor = function (l) {
                for (; this.length < l.length;) this.words[this.length++] = 0;
                for (var f = 0; f < l.length; f++) this.words[f] = this.words[f] | l.words[f];
                return this._strip()
            }, j.prototype.ior = function (l) {
                return ie(0 == (this.negative | l.negative)), this.iuor(l)
            }, j.prototype.or = function (l) {
                return this.length > l.length ? this.clone().ior(l) : l.clone().ior(this)
            }, j.prototype.uor = function (l) {
                return this.length > l.length ? this.clone().iuor(l) : l.clone().iuor(this)
            }, j.prototype.iuand = function (l) {
                var f;
                f = this.length > l.length ? l : this;
                for (var g = 0; g < f.length; g++) this.words[g] = this.words[g] & l.words[g];
                return this.length = f.length, this._strip()
            }, j.prototype.iand = function (l) {
                return ie(0 == (this.negative | l.negative)), this.iuand(l)
            }, j.prototype.and = function (l) {
                return this.length > l.length ? this.clone().iand(l) : l.clone().iand(this)
            }, j.prototype.uand = function (l) {
                return this.length > l.length ? this.clone().iuand(l) : l.clone().iuand(this)
            }, j.prototype.iuxor = function (l) {
                var f, g;
                this.length > l.length ? (f = this, g = l) : (f = l, g = this);
                for (var v = 0; v < g.length; v++) this.words[v] = f.words[v] ^ g.words[v];
                if (this !== f) for (; v < f.length; v++) this.words[v] = f.words[v];
                return this.length = f.length, this._strip()
            }, j.prototype.ixor = function (l) {
                return ie(0 == (this.negative | l.negative)), this.iuxor(l)
            }, j.prototype.xor = function (l) {
                return this.length > l.length ? this.clone().ixor(l) : l.clone().ixor(this)
            }, j.prototype.uxor = function (l) {
                return this.length > l.length ? this.clone().iuxor(l) : l.clone().iuxor(this)
            }, j.prototype.inotn = function (l) {
                ie("number" == typeof l && l >= 0);
                var f = 0 | Math.ceil(l / 26), g = l % 26;
                this._expand(f), g > 0 && f--;
                for (var v = 0; v < f; v++) this.words[v] = 67108863 & ~this.words[v];
                return g > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - g), this._strip()
            }, j.prototype.notn = function (l) {
                return this.clone().inotn(l)
            }, j.prototype.setn = function (l, f) {
                ie("number" == typeof l && l >= 0);
                var g = l / 26 | 0, v = l % 26;
                return this._expand(g + 1), this.words[g] = f ? this.words[g] | 1 << v : this.words[g] & ~(1 << v), this._strip()
            }, j.prototype.iadd = function (l) {
                var f, g, v;
                if (0 !== this.negative && 0 === l.negative) return this.negative = 0, f = this.isub(l), this.negative ^= 1, this._normSign();
                if (0 === this.negative && 0 !== l.negative) return l.negative = 0, f = this.isub(l), l.negative = 1, f._normSign();
                this.length > l.length ? (g = this, v = l) : (g = l, v = this);
                for (var w = 0, P = 0; P < v.length; P++) this.words[P] = 67108863 & (f = (0 | g.words[P]) + (0 | v.words[P]) + w), w = f >>> 26;
                for (; 0 !== w && P < g.length; P++) this.words[P] = 67108863 & (f = (0 | g.words[P]) + w), w = f >>> 26;
                if (this.length = g.length, 0 !== w) this.words[this.length] = w, this.length++; else if (g !== this) for (; P < g.length; P++) this.words[P] = g.words[P];
                return this
            }, j.prototype.add = function (l) {
                var f;
                return 0 !== l.negative && 0 === this.negative ? (l.negative = 0, f = this.sub(l), l.negative ^= 1, f) : 0 === l.negative && 0 !== this.negative ? (this.negative = 0, f = l.sub(this), this.negative = 1, f) : this.length > l.length ? this.clone().iadd(l) : l.clone().iadd(this)
            }, j.prototype.isub = function (l) {
                if (0 !== l.negative) {
                    l.negative = 0;
                    var f = this.iadd(l);
                    return l.negative = 1, f._normSign()
                }
                if (0 !== this.negative) return this.negative = 0, this.iadd(l), this.negative = 1, this._normSign();
                var v, w, g = this.cmp(l);
                if (0 === g) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                g > 0 ? (v = this, w = l) : (v = l, w = this);
                for (var P = 0, B = 0; B < w.length; B++) P = (f = (0 | v.words[B]) - (0 | w.words[B]) + P) >> 26, this.words[B] = 67108863 & f;
                for (; 0 !== P && B < v.length; B++) P = (f = (0 | v.words[B]) + P) >> 26, this.words[B] = 67108863 & f;
                if (0 === P && B < v.length && v !== this) for (; B < v.length; B++) this.words[B] = v.words[B];
                return this.length = Math.max(this.length, B), v !== this && (this.negative = 1), this._strip()
            }, j.prototype.sub = function (l) {
                return this.clone().isub(l)
            };
            var Ie = function (l, f, g) {
                var O, E, Z, v = l.words, w = f.words, P = g.words, B = 0, ze = 0 | v[0], Je = 8191 & ze, q = ze >>> 13,
                    Le = 0 | v[1], ut = 8191 & Le, Ye = Le >>> 13, Mt = 0 | v[2], _t = 8191 & Mt, Pt = Mt >>> 13,
                    Gt = 0 | v[3], yn = 8191 & Gt, Xt = Gt >>> 13, xn = 0 | v[4], Fn = 8191 & xn, wn = xn >>> 13,
                    Nn = 0 | v[5], On = 8191 & Nn, Me = Nn >>> 13, ne = 0 | v[6], U = 8191 & ne, de = ne >>> 13,
                    Ze = 0 | v[7], Ge = 8191 & Ze, ye = Ze >>> 13, Te = 0 | v[8], Be = 8191 & Te, tt = Te >>> 13,
                    Dt = 0 | v[9], Ft = 8191 & Dt, zt = Dt >>> 13, dn = 0 | w[0], Bt = 8191 & dn, Ht = dn >>> 13,
                    bn = 0 | w[1], fn = 8191 & bn, rn = bn >>> 13, gn = 0 | w[2], Hn = 8191 & gn, jn = gn >>> 13,
                    fr = 0 | w[3], qn = 8191 & fr, Yn = fr >>> 13, Qn = 0 | w[4], Wn = 8191 & Qn, Xn = Qn >>> 13,
                    Dr = 0 | w[5], It = 8191 & Dr, vt = Dr >>> 13, Qe = 0 | w[6], ht = 8191 & Qe, jt = Qe >>> 13,
                    gt = 0 | w[7], dt = 8191 & gt, wt = gt >>> 13, Ut = 0 | w[8], Qt = 8191 & Ut, sn = Ut >>> 13,
                    un = 0 | w[9], Pn = 8191 & un, mn = un >>> 13;
                g.negative = l.negative ^ f.negative, g.length = 19;
                var Mn = (B + (O = Math.imul(Je, Bt)) | 0) + ((8191 & (E = (E = Math.imul(Je, Ht)) + Math.imul(q, Bt) | 0)) << 13) | 0;
                B = ((Z = Math.imul(q, Ht)) + (E >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, O = Math.imul(ut, Bt), E = (E = Math.imul(ut, Ht)) + Math.imul(Ye, Bt) | 0, Z = Math.imul(Ye, Ht);
                var an = (B + (O = O + Math.imul(Je, fn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, rn) | 0) + Math.imul(q, fn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, rn) | 0) + (E >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, O = Math.imul(_t, Bt), E = (E = Math.imul(_t, Ht)) + Math.imul(Pt, Bt) | 0, Z = Math.imul(Pt, Ht), O = O + Math.imul(ut, fn) | 0, E = (E = E + Math.imul(ut, rn) | 0) + Math.imul(Ye, fn) | 0, Z = Z + Math.imul(Ye, rn) | 0;
                var En = (B + (O = O + Math.imul(Je, Hn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, jn) | 0) + Math.imul(q, Hn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, jn) | 0) + (E >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, O = Math.imul(yn, Bt), E = (E = Math.imul(yn, Ht)) + Math.imul(Xt, Bt) | 0, Z = Math.imul(Xt, Ht), O = O + Math.imul(_t, fn) | 0, E = (E = E + Math.imul(_t, rn) | 0) + Math.imul(Pt, fn) | 0, Z = Z + Math.imul(Pt, rn) | 0, O = O + Math.imul(ut, Hn) | 0, E = (E = E + Math.imul(ut, jn) | 0) + Math.imul(Ye, Hn) | 0, Z = Z + Math.imul(Ye, jn) | 0;
                var Sn = (B + (O = O + Math.imul(Je, qn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, Yn) | 0) + Math.imul(q, qn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, Yn) | 0) + (E >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, O = Math.imul(Fn, Bt), E = (E = Math.imul(Fn, Ht)) + Math.imul(wn, Bt) | 0, Z = Math.imul(wn, Ht), O = O + Math.imul(yn, fn) | 0, E = (E = E + Math.imul(yn, rn) | 0) + Math.imul(Xt, fn) | 0, Z = Z + Math.imul(Xt, rn) | 0, O = O + Math.imul(_t, Hn) | 0, E = (E = E + Math.imul(_t, jn) | 0) + Math.imul(Pt, Hn) | 0, Z = Z + Math.imul(Pt, jn) | 0, O = O + Math.imul(ut, qn) | 0, E = (E = E + Math.imul(ut, Yn) | 0) + Math.imul(Ye, qn) | 0, Z = Z + Math.imul(Ye, Yn) | 0;
                var ar = (B + (O = O + Math.imul(Je, Wn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, Xn) | 0) + Math.imul(q, Wn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, Xn) | 0) + (E >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, O = Math.imul(On, Bt), E = (E = Math.imul(On, Ht)) + Math.imul(Me, Bt) | 0, Z = Math.imul(Me, Ht), O = O + Math.imul(Fn, fn) | 0, E = (E = E + Math.imul(Fn, rn) | 0) + Math.imul(wn, fn) | 0, Z = Z + Math.imul(wn, rn) | 0, O = O + Math.imul(yn, Hn) | 0, E = (E = E + Math.imul(yn, jn) | 0) + Math.imul(Xt, Hn) | 0, Z = Z + Math.imul(Xt, jn) | 0, O = O + Math.imul(_t, qn) | 0, E = (E = E + Math.imul(_t, Yn) | 0) + Math.imul(Pt, qn) | 0, Z = Z + Math.imul(Pt, Yn) | 0, O = O + Math.imul(ut, Wn) | 0, E = (E = E + Math.imul(ut, Xn) | 0) + Math.imul(Ye, Wn) | 0, Z = Z + Math.imul(Ye, Xn) | 0;
                var Un = (B + (O = O + Math.imul(Je, It) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, vt) | 0) + Math.imul(q, It) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, vt) | 0) + (E >>> 13) | 0) + (Un >>> 26) | 0, Un &= 67108863, O = Math.imul(U, Bt), E = (E = Math.imul(U, Ht)) + Math.imul(de, Bt) | 0, Z = Math.imul(de, Ht), O = O + Math.imul(On, fn) | 0, E = (E = E + Math.imul(On, rn) | 0) + Math.imul(Me, fn) | 0, Z = Z + Math.imul(Me, rn) | 0, O = O + Math.imul(Fn, Hn) | 0, E = (E = E + Math.imul(Fn, jn) | 0) + Math.imul(wn, Hn) | 0, Z = Z + Math.imul(wn, jn) | 0, O = O + Math.imul(yn, qn) | 0, E = (E = E + Math.imul(yn, Yn) | 0) + Math.imul(Xt, qn) | 0, Z = Z + Math.imul(Xt, Yn) | 0, O = O + Math.imul(_t, Wn) | 0, E = (E = E + Math.imul(_t, Xn) | 0) + Math.imul(Pt, Wn) | 0, Z = Z + Math.imul(Pt, Xn) | 0, O = O + Math.imul(ut, It) | 0, E = (E = E + Math.imul(ut, vt) | 0) + Math.imul(Ye, It) | 0, Z = Z + Math.imul(Ye, vt) | 0;
                var nn = (B + (O = O + Math.imul(Je, ht) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, jt) | 0) + Math.imul(q, ht) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, jt) | 0) + (E >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, O = Math.imul(Ge, Bt), E = (E = Math.imul(Ge, Ht)) + Math.imul(ye, Bt) | 0, Z = Math.imul(ye, Ht), O = O + Math.imul(U, fn) | 0, E = (E = E + Math.imul(U, rn) | 0) + Math.imul(de, fn) | 0, Z = Z + Math.imul(de, rn) | 0, O = O + Math.imul(On, Hn) | 0, E = (E = E + Math.imul(On, jn) | 0) + Math.imul(Me, Hn) | 0, Z = Z + Math.imul(Me, jn) | 0, O = O + Math.imul(Fn, qn) | 0, E = (E = E + Math.imul(Fn, Yn) | 0) + Math.imul(wn, qn) | 0, Z = Z + Math.imul(wn, Yn) | 0, O = O + Math.imul(yn, Wn) | 0, E = (E = E + Math.imul(yn, Xn) | 0) + Math.imul(Xt, Wn) | 0, Z = Z + Math.imul(Xt, Xn) | 0, O = O + Math.imul(_t, It) | 0, E = (E = E + Math.imul(_t, vt) | 0) + Math.imul(Pt, It) | 0, Z = Z + Math.imul(Pt, vt) | 0, O = O + Math.imul(ut, ht) | 0, E = (E = E + Math.imul(ut, jt) | 0) + Math.imul(Ye, ht) | 0, Z = Z + Math.imul(Ye, jt) | 0;
                var _n = (B + (O = O + Math.imul(Je, dt) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, wt) | 0) + Math.imul(q, dt) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, wt) | 0) + (E >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, O = Math.imul(Be, Bt), E = (E = Math.imul(Be, Ht)) + Math.imul(tt, Bt) | 0, Z = Math.imul(tt, Ht), O = O + Math.imul(Ge, fn) | 0, E = (E = E + Math.imul(Ge, rn) | 0) + Math.imul(ye, fn) | 0, Z = Z + Math.imul(ye, rn) | 0, O = O + Math.imul(U, Hn) | 0, E = (E = E + Math.imul(U, jn) | 0) + Math.imul(de, Hn) | 0, Z = Z + Math.imul(de, jn) | 0, O = O + Math.imul(On, qn) | 0, E = (E = E + Math.imul(On, Yn) | 0) + Math.imul(Me, qn) | 0, Z = Z + Math.imul(Me, Yn) | 0, O = O + Math.imul(Fn, Wn) | 0, E = (E = E + Math.imul(Fn, Xn) | 0) + Math.imul(wn, Wn) | 0, Z = Z + Math.imul(wn, Xn) | 0, O = O + Math.imul(yn, It) | 0, E = (E = E + Math.imul(yn, vt) | 0) + Math.imul(Xt, It) | 0, Z = Z + Math.imul(Xt, vt) | 0, O = O + Math.imul(_t, ht) | 0, E = (E = E + Math.imul(_t, jt) | 0) + Math.imul(Pt, ht) | 0, Z = Z + Math.imul(Pt, jt) | 0, O = O + Math.imul(ut, dt) | 0, E = (E = E + Math.imul(ut, wt) | 0) + Math.imul(Ye, dt) | 0, Z = Z + Math.imul(Ye, wt) | 0;
                var tr = (B + (O = O + Math.imul(Je, Qt) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, sn) | 0) + Math.imul(q, Qt) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, sn) | 0) + (E >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, O = Math.imul(Ft, Bt), E = (E = Math.imul(Ft, Ht)) + Math.imul(zt, Bt) | 0, Z = Math.imul(zt, Ht), O = O + Math.imul(Be, fn) | 0, E = (E = E + Math.imul(Be, rn) | 0) + Math.imul(tt, fn) | 0, Z = Z + Math.imul(tt, rn) | 0, O = O + Math.imul(Ge, Hn) | 0, E = (E = E + Math.imul(Ge, jn) | 0) + Math.imul(ye, Hn) | 0, Z = Z + Math.imul(ye, jn) | 0, O = O + Math.imul(U, qn) | 0, E = (E = E + Math.imul(U, Yn) | 0) + Math.imul(de, qn) | 0, Z = Z + Math.imul(de, Yn) | 0, O = O + Math.imul(On, Wn) | 0, E = (E = E + Math.imul(On, Xn) | 0) + Math.imul(Me, Wn) | 0, Z = Z + Math.imul(Me, Xn) | 0, O = O + Math.imul(Fn, It) | 0, E = (E = E + Math.imul(Fn, vt) | 0) + Math.imul(wn, It) | 0, Z = Z + Math.imul(wn, vt) | 0, O = O + Math.imul(yn, ht) | 0, E = (E = E + Math.imul(yn, jt) | 0) + Math.imul(Xt, ht) | 0, Z = Z + Math.imul(Xt, jt) | 0, O = O + Math.imul(_t, dt) | 0, E = (E = E + Math.imul(_t, wt) | 0) + Math.imul(Pt, dt) | 0, Z = Z + Math.imul(Pt, wt) | 0, O = O + Math.imul(ut, Qt) | 0, E = (E = E + Math.imul(ut, sn) | 0) + Math.imul(Ye, Qt) | 0, Z = Z + Math.imul(Ye, sn) | 0;
                var nr = (B + (O = O + Math.imul(Je, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Je, mn) | 0) + Math.imul(q, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(q, mn) | 0) + (E >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, O = Math.imul(Ft, fn), E = (E = Math.imul(Ft, rn)) + Math.imul(zt, fn) | 0, Z = Math.imul(zt, rn), O = O + Math.imul(Be, Hn) | 0, E = (E = E + Math.imul(Be, jn) | 0) + Math.imul(tt, Hn) | 0, Z = Z + Math.imul(tt, jn) | 0, O = O + Math.imul(Ge, qn) | 0, E = (E = E + Math.imul(Ge, Yn) | 0) + Math.imul(ye, qn) | 0, Z = Z + Math.imul(ye, Yn) | 0, O = O + Math.imul(U, Wn) | 0, E = (E = E + Math.imul(U, Xn) | 0) + Math.imul(de, Wn) | 0, Z = Z + Math.imul(de, Xn) | 0, O = O + Math.imul(On, It) | 0, E = (E = E + Math.imul(On, vt) | 0) + Math.imul(Me, It) | 0, Z = Z + Math.imul(Me, vt) | 0, O = O + Math.imul(Fn, ht) | 0, E = (E = E + Math.imul(Fn, jt) | 0) + Math.imul(wn, ht) | 0, Z = Z + Math.imul(wn, jt) | 0, O = O + Math.imul(yn, dt) | 0, E = (E = E + Math.imul(yn, wt) | 0) + Math.imul(Xt, dt) | 0, Z = Z + Math.imul(Xt, wt) | 0, O = O + Math.imul(_t, Qt) | 0, E = (E = E + Math.imul(_t, sn) | 0) + Math.imul(Pt, Qt) | 0, Z = Z + Math.imul(Pt, sn) | 0;
                var Er = (B + (O = O + Math.imul(ut, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(ut, mn) | 0) + Math.imul(Ye, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(Ye, mn) | 0) + (E >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, O = Math.imul(Ft, Hn), E = (E = Math.imul(Ft, jn)) + Math.imul(zt, Hn) | 0, Z = Math.imul(zt, jn), O = O + Math.imul(Be, qn) | 0, E = (E = E + Math.imul(Be, Yn) | 0) + Math.imul(tt, qn) | 0, Z = Z + Math.imul(tt, Yn) | 0, O = O + Math.imul(Ge, Wn) | 0, E = (E = E + Math.imul(Ge, Xn) | 0) + Math.imul(ye, Wn) | 0, Z = Z + Math.imul(ye, Xn) | 0, O = O + Math.imul(U, It) | 0, E = (E = E + Math.imul(U, vt) | 0) + Math.imul(de, It) | 0, Z = Z + Math.imul(de, vt) | 0, O = O + Math.imul(On, ht) | 0, E = (E = E + Math.imul(On, jt) | 0) + Math.imul(Me, ht) | 0, Z = Z + Math.imul(Me, jt) | 0, O = O + Math.imul(Fn, dt) | 0, E = (E = E + Math.imul(Fn, wt) | 0) + Math.imul(wn, dt) | 0, Z = Z + Math.imul(wn, wt) | 0, O = O + Math.imul(yn, Qt) | 0, E = (E = E + Math.imul(yn, sn) | 0) + Math.imul(Xt, Qt) | 0, Z = Z + Math.imul(Xt, sn) | 0;
                var gr = (B + (O = O + Math.imul(_t, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(_t, mn) | 0) + Math.imul(Pt, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(Pt, mn) | 0) + (E >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, O = Math.imul(Ft, qn), E = (E = Math.imul(Ft, Yn)) + Math.imul(zt, qn) | 0, Z = Math.imul(zt, Yn), O = O + Math.imul(Be, Wn) | 0, E = (E = E + Math.imul(Be, Xn) | 0) + Math.imul(tt, Wn) | 0, Z = Z + Math.imul(tt, Xn) | 0, O = O + Math.imul(Ge, It) | 0, E = (E = E + Math.imul(Ge, vt) | 0) + Math.imul(ye, It) | 0, Z = Z + Math.imul(ye, vt) | 0, O = O + Math.imul(U, ht) | 0, E = (E = E + Math.imul(U, jt) | 0) + Math.imul(de, ht) | 0, Z = Z + Math.imul(de, jt) | 0, O = O + Math.imul(On, dt) | 0, E = (E = E + Math.imul(On, wt) | 0) + Math.imul(Me, dt) | 0, Z = Z + Math.imul(Me, wt) | 0, O = O + Math.imul(Fn, Qt) | 0, E = (E = E + Math.imul(Fn, sn) | 0) + Math.imul(wn, Qt) | 0, Z = Z + Math.imul(wn, sn) | 0;
                var Ir = (B + (O = O + Math.imul(yn, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(yn, mn) | 0) + Math.imul(Xt, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(Xt, mn) | 0) + (E >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, O = Math.imul(Ft, Wn), E = (E = Math.imul(Ft, Xn)) + Math.imul(zt, Wn) | 0, Z = Math.imul(zt, Xn), O = O + Math.imul(Be, It) | 0, E = (E = E + Math.imul(Be, vt) | 0) + Math.imul(tt, It) | 0, Z = Z + Math.imul(tt, vt) | 0, O = O + Math.imul(Ge, ht) | 0, E = (E = E + Math.imul(Ge, jt) | 0) + Math.imul(ye, ht) | 0, Z = Z + Math.imul(ye, jt) | 0, O = O + Math.imul(U, dt) | 0, E = (E = E + Math.imul(U, wt) | 0) + Math.imul(de, dt) | 0, Z = Z + Math.imul(de, wt) | 0, O = O + Math.imul(On, Qt) | 0, E = (E = E + Math.imul(On, sn) | 0) + Math.imul(Me, Qt) | 0, Z = Z + Math.imul(Me, sn) | 0;
                var rr = (B + (O = O + Math.imul(Fn, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Fn, mn) | 0) + Math.imul(wn, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(wn, mn) | 0) + (E >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, O = Math.imul(Ft, It), E = (E = Math.imul(Ft, vt)) + Math.imul(zt, It) | 0, Z = Math.imul(zt, vt), O = O + Math.imul(Be, ht) | 0, E = (E = E + Math.imul(Be, jt) | 0) + Math.imul(tt, ht) | 0, Z = Z + Math.imul(tt, jt) | 0, O = O + Math.imul(Ge, dt) | 0, E = (E = E + Math.imul(Ge, wt) | 0) + Math.imul(ye, dt) | 0, Z = Z + Math.imul(ye, wt) | 0, O = O + Math.imul(U, Qt) | 0, E = (E = E + Math.imul(U, sn) | 0) + Math.imul(de, Qt) | 0, Z = Z + Math.imul(de, sn) | 0;
                var br = (B + (O = O + Math.imul(On, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(On, mn) | 0) + Math.imul(Me, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(Me, mn) | 0) + (E >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, O = Math.imul(Ft, ht), E = (E = Math.imul(Ft, jt)) + Math.imul(zt, ht) | 0, Z = Math.imul(zt, jt), O = O + Math.imul(Be, dt) | 0, E = (E = E + Math.imul(Be, wt) | 0) + Math.imul(tt, dt) | 0, Z = Z + Math.imul(tt, wt) | 0, O = O + Math.imul(Ge, Qt) | 0, E = (E = E + Math.imul(Ge, sn) | 0) + Math.imul(ye, Qt) | 0, Z = Z + Math.imul(ye, sn) | 0;
                var Vn = (B + (O = O + Math.imul(U, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(U, mn) | 0) + Math.imul(de, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(de, mn) | 0) + (E >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, O = Math.imul(Ft, dt), E = (E = Math.imul(Ft, wt)) + Math.imul(zt, dt) | 0, Z = Math.imul(zt, wt), O = O + Math.imul(Be, Qt) | 0, E = (E = E + Math.imul(Be, sn) | 0) + Math.imul(tt, Qt) | 0, Z = Z + Math.imul(tt, sn) | 0;
                var $n = (B + (O = O + Math.imul(Ge, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Ge, mn) | 0) + Math.imul(ye, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(ye, mn) | 0) + (E >>> 13) | 0) + ($n >>> 26) | 0, $n &= 67108863, O = Math.imul(Ft, Qt), E = (E = Math.imul(Ft, sn)) + Math.imul(zt, Qt) | 0, Z = Math.imul(zt, sn);
                var Br = (B + (O = O + Math.imul(Be, Pn) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Be, mn) | 0) + Math.imul(tt, Pn) | 0)) << 13) | 0;
                B = ((Z = Z + Math.imul(tt, mn) | 0) + (E >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863;
                var _r = (B + (O = Math.imul(Ft, Pn)) | 0) + ((8191 & (E = (E = Math.imul(Ft, mn)) + Math.imul(zt, Pn) | 0)) << 13) | 0;
                return B = ((Z = Math.imul(zt, mn)) + (E >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, P[0] = Mn, P[1] = an, P[2] = En, P[3] = Sn, P[4] = ar, P[5] = Un, P[6] = nn, P[7] = _n, P[8] = tr, P[9] = nr, P[10] = Er, P[11] = gr, P[12] = Ir, P[13] = rr, P[14] = br, P[15] = Vn, P[16] = $n, P[17] = Br, P[18] = _r, 0 !== B && (P[19] = B, g.length++), g
            };

            function he(I, l, f) {
                f.negative = l.negative ^ I.negative, f.length = I.length + l.length;
                for (var g = 0, v = 0, w = 0; w < f.length - 1; w++) {
                    var P = v;
                    v = 0;
                    for (var B = 67108863 & g, O = Math.min(w, l.length - 1), E = Math.max(0, w - I.length + 1); E <= O; E++) {
                        var q = (0 | I.words[w - E]) * (0 | l.words[E]), Le = 67108863 & q;
                        B = 67108863 & (Le = Le + B | 0), v += (P = (P = P + (q / 67108864 | 0) | 0) + (Le >>> 26) | 0) >>> 26, P &= 67108863
                    }
                    f.words[w] = B, g = P, P = v
                }
                return 0 !== g ? f.words[w] = g : f.length--, f._strip()
            }

            function xe(I, l, f) {
                return he(I, l, f)
            }

            function Ue(I, l) {
                this.x = I, this.y = l
            }

            Math.imul || (Ie = ge), j.prototype.mulTo = function (l, f) {
                var v = this.length + l.length;
                return 10 === this.length && 10 === l.length ? Ie(this, l, f) : v < 63 ? ge(this, l, f) : v < 1024 ? he(this, l, f) : xe(this, l, f)
            }, Ue.prototype.makeRBT = function (l) {
                for (var f = new Array(l), g = j.prototype._countBits(l) - 1, v = 0; v < l; v++) f[v] = this.revBin(v, g, l);
                return f
            }, Ue.prototype.revBin = function (l, f, g) {
                if (0 === l || l === g - 1) return l;
                for (var v = 0, w = 0; w < f; w++) v |= (1 & l) << f - w - 1, l >>= 1;
                return v
            }, Ue.prototype.permute = function (l, f, g, v, w, P) {
                for (var B = 0; B < P; B++) v[B] = f[l[B]], w[B] = g[l[B]]
            }, Ue.prototype.transform = function (l, f, g, v, w, P) {
                this.permute(P, l, f, g, v, w);
                for (var B = 1; B < w; B <<= 1) for (var O = B << 1, E = Math.cos(2 * Math.PI / O), Z = Math.sin(2 * Math.PI / O), ze = 0; ze < w; ze += O) for (var Je = E, q = Z, Le = 0; Le < B; Le++) {
                    var ut = g[ze + Le], Ye = v[ze + Le], Mt = g[ze + Le + B], _t = v[ze + Le + B],
                        Pt = Je * Mt - q * _t;
                    _t = Je * _t + q * Mt, g[ze + Le] = ut + (Mt = Pt), v[ze + Le] = Ye + _t, g[ze + Le + B] = ut - Mt, v[ze + Le + B] = Ye - _t, Le !== O && (Pt = E * Je - Z * q, q = E * q + Z * Je, Je = Pt)
                }
            }, Ue.prototype.guessLen13b = function (l, f) {
                var g = 1 | Math.max(f, l), v = 1 & g, w = 0;
                for (g = g / 2 | 0; g; g >>>= 1) w++;
                return 1 << w + 1 + v
            }, Ue.prototype.conjugate = function (l, f, g) {
                if (!(g <= 1)) for (var v = 0; v < g / 2; v++) {
                    var w = l[v];
                    l[v] = l[g - v - 1], l[g - v - 1] = w, w = f[v], f[v] = -f[g - v - 1], f[g - v - 1] = -w
                }
            }, Ue.prototype.normalize13b = function (l, f) {
                for (var g = 0, v = 0; v < f / 2; v++) {
                    var w = 8192 * Math.round(l[2 * v + 1] / f) + Math.round(l[2 * v] / f) + g;
                    l[v] = 67108863 & w, g = w < 67108864 ? 0 : w / 67108864 | 0
                }
                return l
            }, Ue.prototype.convert13b = function (l, f, g, v) {
                for (var w = 0, P = 0; P < f; P++) g[2 * P] = 8191 & (w += 0 | l[P]), g[2 * P + 1] = 8191 & (w >>>= 13), w >>>= 13;
                for (P = 2 * f; P < v; ++P) g[P] = 0;
                ie(0 === w), ie(0 == (-8192 & w))
            }, Ue.prototype.stub = function (l) {
                for (var f = new Array(l), g = 0; g < l; g++) f[g] = 0;
                return f
            }, Ue.prototype.mulp = function (l, f, g) {
                var v = 2 * this.guessLen13b(l.length, f.length), w = this.makeRBT(v), P = this.stub(v),
                    B = new Array(v), O = new Array(v), E = new Array(v), Z = new Array(v), ze = new Array(v),
                    Je = new Array(v), q = g.words;
                q.length = v, this.convert13b(l.words, l.length, B, v), this.convert13b(f.words, f.length, Z, v), this.transform(B, P, O, E, v, w), this.transform(Z, P, ze, Je, v, w);
                for (var Le = 0; Le < v; Le++) {
                    var ut = O[Le] * ze[Le] - E[Le] * Je[Le];
                    E[Le] = O[Le] * Je[Le] + E[Le] * ze[Le], O[Le] = ut
                }
                return this.conjugate(O, E, v), this.transform(O, E, q, P, v, w), this.conjugate(q, P, v), this.normalize13b(q, v), g.negative = l.negative ^ f.negative, g.length = l.length + f.length, g._strip()
            }, j.prototype.mul = function (l) {
                var f = new j(null);
                return f.words = new Array(this.length + l.length), this.mulTo(l, f)
            }, j.prototype.mulf = function (l) {
                var f = new j(null);
                return f.words = new Array(this.length + l.length), xe(this, l, f)
            }, j.prototype.imul = function (l) {
                return this.clone().mulTo(l, this)
            }, j.prototype.imuln = function (l) {
                var f = l < 0;
                f && (l = -l), ie("number" == typeof l), ie(l < 67108864);
                for (var g = 0, v = 0; v < this.length; v++) {
                    var w = (0 | this.words[v]) * l, P = (67108863 & w) + (67108863 & g);
                    g >>= 26, g += w / 67108864 | 0, g += P >>> 26, this.words[v] = 67108863 & P
                }
                return 0 !== g && (this.words[v] = g, this.length++), f ? this.ineg() : this
            }, j.prototype.muln = function (l) {
                return this.clone().imuln(l)
            }, j.prototype.sqr = function () {
                return this.mul(this)
            }, j.prototype.isqr = function () {
                return this.imul(this.clone())
            }, j.prototype.pow = function (l) {
                var f = function oe(I) {
                    for (var l = new Array(I.bitLength()), f = 0; f < l.length; f++) l[f] = I.words[f / 26 | 0] >>> f % 26 & 1;
                    return l
                }(l);
                if (0 === f.length) return new j(1);
                for (var g = this, v = 0; v < f.length && 0 === f[v]; v++, g = g.sqr()) ;
                if (++v < f.length) for (var w = g.sqr(); v < f.length; v++, w = w.sqr()) 0 !== f[v] && (g = g.mul(w));
                return g
            }, j.prototype.iushln = function (l) {
                ie("number" == typeof l && l >= 0);
                var w, f = l % 26, g = (l - f) / 26, v = 67108863 >>> 26 - f << 26 - f;
                if (0 !== f) {
                    var P = 0;
                    for (w = 0; w < this.length; w++) {
                        var B = this.words[w] & v;
                        this.words[w] = (0 | this.words[w]) - B << f | P, P = B >>> 26 - f
                    }
                    P && (this.words[w] = P, this.length++)
                }
                if (0 !== g) {
                    for (w = this.length - 1; w >= 0; w--) this.words[w + g] = this.words[w];
                    for (w = 0; w < g; w++) this.words[w] = 0;
                    this.length += g
                }
                return this._strip()
            }, j.prototype.ishln = function (l) {
                return ie(0 === this.negative), this.iushln(l)
            }, j.prototype.iushrn = function (l, f, g) {
                var v;
                ie("number" == typeof l && l >= 0), v = f ? (f - f % 26) / 26 : 0;
                var w = l % 26, P = Math.min((l - w) / 26, this.length), B = 67108863 ^ 67108863 >>> w << w, O = g;
                if (v -= P, v = Math.max(0, v), O) {
                    for (var E = 0; E < P; E++) O.words[E] = this.words[E];
                    O.length = P
                }
                if (0 !== P) if (this.length > P) for (this.length -= P, E = 0; E < this.length; E++) this.words[E] = this.words[E + P]; else this.words[0] = 0, this.length = 1;
                var Z = 0;
                for (E = this.length - 1; E >= 0 && (0 !== Z || E >= v); E--) {
                    var ze = 0 | this.words[E];
                    this.words[E] = Z << 26 - w | ze >>> w, Z = ze & B
                }
                return O && 0 !== Z && (O.words[O.length++] = Z), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
            }, j.prototype.ishrn = function (l, f, g) {
                return ie(0 === this.negative), this.iushrn(l, f, g)
            }, j.prototype.shln = function (l) {
                return this.clone().ishln(l)
            }, j.prototype.ushln = function (l) {
                return this.clone().iushln(l)
            }, j.prototype.shrn = function (l) {
                return this.clone().ishrn(l)
            }, j.prototype.ushrn = function (l) {
                return this.clone().iushrn(l)
            }, j.prototype.testn = function (l) {
                ie("number" == typeof l && l >= 0);
                var f = l % 26, g = (l - f) / 26;
                return !(this.length <= g || !(this.words[g] & 1 << f))
            }, j.prototype.imaskn = function (l) {
                ie("number" == typeof l && l >= 0);
                var f = l % 26, g = (l - f) / 26;
                return ie(0 === this.negative, "imaskn works only with positive numbers"), this.length <= g ? this : (0 !== f && g++, this.length = Math.min(g, this.length), 0 !== f && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> f << f), this._strip())
            }, j.prototype.maskn = function (l) {
                return this.clone().imaskn(l)
            }, j.prototype.iaddn = function (l) {
                return ie("number" == typeof l), ie(l < 67108864), l < 0 ? this.isubn(-l) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= l ? (this.words[0] = l - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(l), this.negative = 1, this) : this._iaddn(l)
            }, j.prototype._iaddn = function (l) {
                this.words[0] += l;
                for (var f = 0; f < this.length && this.words[f] >= 67108864; f++) this.words[f] -= 67108864, f === this.length - 1 ? this.words[f + 1] = 1 : this.words[f + 1]++;
                return this.length = Math.max(this.length, f + 1), this
            }, j.prototype.isubn = function (l) {
                if (ie("number" == typeof l), ie(l < 67108864), l < 0) return this.iaddn(-l);
                if (0 !== this.negative) return this.negative = 0, this.iaddn(l), this.negative = 1, this;
                if (this.words[0] -= l, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var f = 0; f < this.length && this.words[f] < 0; f++) this.words[f] += 67108864, this.words[f + 1] -= 1;
                return this._strip()
            }, j.prototype.addn = function (l) {
                return this.clone().iaddn(l)
            }, j.prototype.subn = function (l) {
                return this.clone().isubn(l)
            }, j.prototype.iabs = function () {
                return this.negative = 0, this
            }, j.prototype.abs = function () {
                return this.clone().iabs()
            }, j.prototype._ishlnsubmul = function (l, f, g) {
                var w;
                this._expand(l.length + g);
                var P, B = 0;
                for (w = 0; w < l.length; w++) {
                    P = (0 | this.words[w + g]) + B;
                    var O = (0 | l.words[w]) * f;
                    B = ((P -= 67108863 & O) >> 26) - (O / 67108864 | 0), this.words[w + g] = 67108863 & P
                }
                for (; w < this.length - g; w++) B = (P = (0 | this.words[w + g]) + B) >> 26, this.words[w + g] = 67108863 & P;
                if (0 === B) return this._strip();
                for (ie(-1 === B), B = 0, w = 0; w < this.length; w++) B = (P = -(0 | this.words[w]) + B) >> 26, this.words[w] = 67108863 & P;
                return this.negative = 1, this._strip()
            }, j.prototype._wordDiv = function (l, f) {
                var g, v = this.clone(), w = l, P = 0 | w.words[w.length - 1];
                0 != (g = 26 - this._countBits(P)) && (w = w.ushln(g), v.iushln(g), P = 0 | w.words[w.length - 1]);
                var E, O = v.length - w.length;
                if ("mod" !== f) {
                    (E = new j(null)).length = O + 1, E.words = new Array(E.length);
                    for (var Z = 0; Z < E.length; Z++) E.words[Z] = 0
                }
                var ze = v.clone()._ishlnsubmul(w, 1, O);
                0 === ze.negative && (v = ze, E && (E.words[O] = 1));
                for (var Je = O - 1; Je >= 0; Je--) {
                    var q = 67108864 * (0 | v.words[w.length + Je]) + (0 | v.words[w.length + Je - 1]);
                    for (q = Math.min(q / P | 0, 67108863), v._ishlnsubmul(w, q, Je); 0 !== v.negative;) q--, v.negative = 0, v._ishlnsubmul(w, 1, Je), v.isZero() || (v.negative ^= 1);
                    E && (E.words[Je] = q)
                }
                return E && E._strip(), v._strip(), "div" !== f && 0 !== g && v.iushrn(g), {div: E || null, mod: v}
            }, j.prototype.divmod = function (l, f, g) {
                return ie(!l.isZero()), this.isZero() ? {
                    div: new j(0),
                    mod: new j(0)
                } : 0 !== this.negative && 0 === l.negative ? (P = this.neg().divmod(l, f), "mod" !== f && (v = P.div.neg()), "div" !== f && (w = P.mod.neg(), g && 0 !== w.negative && w.iadd(l)), {
                    div: v,
                    mod: w
                }) : 0 === this.negative && 0 !== l.negative ? (P = this.divmod(l.neg(), f), "mod" !== f && (v = P.div.neg()), {
                    div: v,
                    mod: P.mod
                }) : 0 != (this.negative & l.negative) ? (P = this.neg().divmod(l.neg(), f), "div" !== f && (w = P.mod.neg(), g && 0 !== w.negative && w.isub(l)), {
                    div: P.div,
                    mod: w
                }) : l.length > this.length || this.cmp(l) < 0 ? {
                    div: new j(0),
                    mod: this
                } : 1 === l.length ? "div" === f ? {div: this.divn(l.words[0]), mod: null} : "mod" === f ? {
                    div: null,
                    mod: new j(this.modrn(l.words[0]))
                } : {div: this.divn(l.words[0]), mod: new j(this.modrn(l.words[0]))} : this._wordDiv(l, f);
                var v, w, P
            }, j.prototype.div = function (l) {
                return this.divmod(l, "div", !1).div
            }, j.prototype.mod = function (l) {
                return this.divmod(l, "mod", !1).mod
            }, j.prototype.umod = function (l) {
                return this.divmod(l, "mod", !0).mod
            }, j.prototype.divRound = function (l) {
                var f = this.divmod(l);
                if (f.mod.isZero()) return f.div;
                var g = 0 !== f.div.negative ? f.mod.isub(l) : f.mod, v = l.ushrn(1), w = l.andln(1), P = g.cmp(v);
                return P < 0 || 1 === w && 0 === P ? f.div : 0 !== f.div.negative ? f.div.isubn(1) : f.div.iaddn(1)
            }, j.prototype.modrn = function (l) {
                var f = l < 0;
                f && (l = -l), ie(l <= 67108863);
                for (var g = (1 << 26) % l, v = 0, w = this.length - 1; w >= 0; w--) v = (g * v + (0 | this.words[w])) % l;
                return f ? -v : v
            }, j.prototype.modn = function (l) {
                return this.modrn(l)
            }, j.prototype.idivn = function (l) {
                var f = l < 0;
                f && (l = -l), ie(l <= 67108863);
                for (var g = 0, v = this.length - 1; v >= 0; v--) {
                    var w = (0 | this.words[v]) + 67108864 * g;
                    this.words[v] = w / l | 0, g = w % l
                }
                return this._strip(), f ? this.ineg() : this
            }, j.prototype.divn = function (l) {
                return this.clone().idivn(l)
            }, j.prototype.egcd = function (l) {
                ie(0 === l.negative), ie(!l.isZero());
                var f = this, g = l.clone();
                f = 0 !== f.negative ? f.umod(l) : f.clone();
                for (var v = new j(1), w = new j(0), P = new j(0), B = new j(1), O = 0; f.isEven() && g.isEven();) f.iushrn(1), g.iushrn(1), ++O;
                for (var E = g.clone(), Z = f.clone(); !f.isZero();) {
                    for (var ze = 0, Je = 1; 0 == (f.words[0] & Je) && ze < 26; ++ze, Je <<= 1) ;
                    if (ze > 0) for (f.iushrn(ze); ze-- > 0;) (v.isOdd() || w.isOdd()) && (v.iadd(E), w.isub(Z)), v.iushrn(1), w.iushrn(1);
                    for (var q = 0, Le = 1; 0 == (g.words[0] & Le) && q < 26; ++q, Le <<= 1) ;
                    if (q > 0) for (g.iushrn(q); q-- > 0;) (P.isOdd() || B.isOdd()) && (P.iadd(E), B.isub(Z)), P.iushrn(1), B.iushrn(1);
                    f.cmp(g) >= 0 ? (f.isub(g), v.isub(P), w.isub(B)) : (g.isub(f), P.isub(v), B.isub(w))
                }
                return {a: P, b: B, gcd: g.iushln(O)}
            }, j.prototype._invmp = function (l) {
                ie(0 === l.negative), ie(!l.isZero());
                var ze, f = this, g = l.clone();
                f = 0 !== f.negative ? f.umod(l) : f.clone();
                for (var v = new j(1), w = new j(0), P = g.clone(); f.cmpn(1) > 0 && g.cmpn(1) > 0;) {
                    for (var B = 0, O = 1; 0 == (f.words[0] & O) && B < 26; ++B, O <<= 1) ;
                    if (B > 0) for (f.iushrn(B); B-- > 0;) v.isOdd() && v.iadd(P), v.iushrn(1);
                    for (var E = 0, Z = 1; 0 == (g.words[0] & Z) && E < 26; ++E, Z <<= 1) ;
                    if (E > 0) for (g.iushrn(E); E-- > 0;) w.isOdd() && w.iadd(P), w.iushrn(1);
                    f.cmp(g) >= 0 ? (f.isub(g), v.isub(w)) : (g.isub(f), w.isub(v))
                }
                return (ze = 0 === f.cmpn(1) ? v : w).cmpn(0) < 0 && ze.iadd(l), ze
            }, j.prototype.gcd = function (l) {
                if (this.isZero()) return l.abs();
                if (l.isZero()) return this.abs();
                var f = this.clone(), g = l.clone();
                f.negative = 0, g.negative = 0;
                for (var v = 0; f.isEven() && g.isEven(); v++) f.iushrn(1), g.iushrn(1);
                for (; ;) {
                    for (; f.isEven();) f.iushrn(1);
                    for (; g.isEven();) g.iushrn(1);
                    var w = f.cmp(g);
                    if (w < 0) {
                        var P = f;
                        f = g, g = P
                    } else if (0 === w || 0 === g.cmpn(1)) break;
                    f.isub(g)
                }
                return g.iushln(v)
            }, j.prototype.invm = function (l) {
                return this.egcd(l).a.umod(l)
            }, j.prototype.isEven = function () {
                return 0 == (1 & this.words[0])
            }, j.prototype.isOdd = function () {
                return 1 == (1 & this.words[0])
            }, j.prototype.andln = function (l) {
                return this.words[0] & l
            }, j.prototype.bincn = function (l) {
                ie("number" == typeof l);
                var f = l % 26, g = (l - f) / 26, v = 1 << f;
                if (this.length <= g) return this._expand(g + 1), this.words[g] |= v, this;
                for (var w = v, P = g; 0 !== w && P < this.length; P++) {
                    var B = 0 | this.words[P];
                    w = (B += w) >>> 26, this.words[P] = B &= 67108863
                }
                return 0 !== w && (this.words[P] = w, this.length++), this
            }, j.prototype.isZero = function () {
                return 1 === this.length && 0 === this.words[0]
            }, j.prototype.cmpn = function (l) {
                var g, f = l < 0;
                if (0 !== this.negative && !f) return -1;
                if (0 === this.negative && f) return 1;
                if (this._strip(), this.length > 1) g = 1; else {
                    f && (l = -l), ie(l <= 67108863, "Number is too big");
                    var v = 0 | this.words[0];
                    g = v === l ? 0 : v < l ? -1 : 1
                }
                return 0 !== this.negative ? 0 | -g : g
            }, j.prototype.cmp = function (l) {
                if (0 !== this.negative && 0 === l.negative) return -1;
                if (0 === this.negative && 0 !== l.negative) return 1;
                var f = this.ucmp(l);
                return 0 !== this.negative ? 0 | -f : f
            }, j.prototype.ucmp = function (l) {
                if (this.length > l.length) return 1;
                if (this.length < l.length) return -1;
                for (var f = 0, g = this.length - 1; g >= 0; g--) {
                    var v = 0 | this.words[g], w = 0 | l.words[g];
                    if (v !== w) {
                        v < w ? f = -1 : v > w && (f = 1);
                        break
                    }
                }
                return f
            }, j.prototype.gtn = function (l) {
                return 1 === this.cmpn(l)
            }, j.prototype.gt = function (l) {
                return 1 === this.cmp(l)
            }, j.prototype.gten = function (l) {
                return this.cmpn(l) >= 0
            }, j.prototype.gte = function (l) {
                return this.cmp(l) >= 0
            }, j.prototype.ltn = function (l) {
                return -1 === this.cmpn(l)
            }, j.prototype.lt = function (l) {
                return -1 === this.cmp(l)
            }, j.prototype.lten = function (l) {
                return this.cmpn(l) <= 0
            }, j.prototype.lte = function (l) {
                return this.cmp(l) <= 0
            }, j.prototype.eqn = function (l) {
                return 0 === this.cmpn(l)
            }, j.prototype.eq = function (l) {
                return 0 === this.cmp(l)
            }, j.red = function (l) {
                return new Ee(l)
            }, j.prototype.toRed = function (l) {
                return ie(!this.red, "Already a number in reduction context"), ie(0 === this.negative, "red works only with positives"), l.convertTo(this)._forceRed(l)
            }, j.prototype.fromRed = function () {
                return ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }, j.prototype._forceRed = function (l) {
                return this.red = l, this
            }, j.prototype.forceRed = function (l) {
                return ie(!this.red, "Already a number in reduction context"), this._forceRed(l)
            }, j.prototype.redAdd = function (l) {
                return ie(this.red, "redAdd works only with red numbers"), this.red.add(this, l)
            }, j.prototype.redIAdd = function (l) {
                return ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, l)
            }, j.prototype.redSub = function (l) {
                return ie(this.red, "redSub works only with red numbers"), this.red.sub(this, l)
            }, j.prototype.redISub = function (l) {
                return ie(this.red, "redISub works only with red numbers"), this.red.isub(this, l)
            }, j.prototype.redShl = function (l) {
                return ie(this.red, "redShl works only with red numbers"), this.red.shl(this, l)
            }, j.prototype.redMul = function (l) {
                return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.mul(this, l)
            }, j.prototype.redIMul = function (l) {
                return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.imul(this, l)
            }, j.prototype.redSqr = function () {
                return ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }, j.prototype.redISqr = function () {
                return ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }, j.prototype.redSqrt = function () {
                return ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }, j.prototype.redInvm = function () {
                return ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }, j.prototype.redNeg = function () {
                return ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }, j.prototype.redPow = function (l) {
                return ie(this.red && !l.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, l)
            };
            var it = {k256: null, p224: null, p192: null, p25519: null};

            function yt(I, l) {
                this.name = I, this.p = new j(l, 16), this.n = this.p.bitLength(), this.k = new j(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
            }

            function Ce() {
                yt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }

            function $e() {
                yt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }

            function rt() {
                yt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }

            function Xe() {
                yt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }

            function Ee(I) {
                if ("string" == typeof I) {
                    var l = j._prime(I);
                    this.m = l.p, this.prime = l
                } else ie(I.gtn(1), "modulus must be greater than 1"), this.m = I, this.prime = null
            }

            function ce(I) {
                Ee.call(this, I), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new j(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
            }

            yt.prototype._tmp = function () {
                var l = new j(null);
                return l.words = new Array(Math.ceil(this.n / 13)), l
            }, yt.prototype.ireduce = function (l) {
                var g, f = l;
                do {
                    this.split(f, this.tmp), g = (f = (f = this.imulK(f)).iadd(this.tmp)).bitLength()
                } while (g > this.n);
                var v = g < this.n ? -1 : f.ucmp(this.p);
                return 0 === v ? (f.words[0] = 0, f.length = 1) : v > 0 ? f.isub(this.p) : void 0 !== f.strip ? f.strip() : f._strip(), f
            }, yt.prototype.split = function (l, f) {
                l.iushrn(this.n, 0, f)
            }, yt.prototype.imulK = function (l) {
                return l.imul(this.k)
            }, te(Ce, yt), Ce.prototype.split = function (l, f) {
                for (var g = 4194303, v = Math.min(l.length, 9), w = 0; w < v; w++) f.words[w] = l.words[w];
                if (f.length = v, l.length <= 9) return l.words[0] = 0, void (l.length = 1);
                var P = l.words[9];
                for (f.words[f.length++] = P & g, w = 10; w < l.length; w++) {
                    var B = 0 | l.words[w];
                    l.words[w - 10] = (B & g) << 4 | P >>> 22, P = B
                }
                l.words[w - 10] = P >>>= 22, l.length -= 0 === P && l.length > 10 ? 10 : 9
            }, Ce.prototype.imulK = function (l) {
                l.words[l.length] = 0, l.words[l.length + 1] = 0, l.length += 2;
                for (var f = 0, g = 0; g < l.length; g++) {
                    var v = 0 | l.words[g];
                    l.words[g] = 67108863 & (f += 977 * v), f = 64 * v + (f / 67108864 | 0)
                }
                return 0 === l.words[l.length - 1] && (l.length--, 0 === l.words[l.length - 1] && l.length--), l
            }, te($e, yt), te(rt, yt), te(Xe, yt), Xe.prototype.imulK = function (l) {
                for (var f = 0, g = 0; g < l.length; g++) {
                    var v = 19 * (0 | l.words[g]) + f, w = 67108863 & v;
                    v >>>= 26, l.words[g] = w, f = v
                }
                return 0 !== f && (l.words[l.length++] = f), l
            }, j._prime = function (l) {
                if (it[l]) return it[l];
                var f;
                if ("k256" === l) f = new Ce; else if ("p224" === l) f = new $e; else if ("p192" === l) f = new rt; else {
                    if ("p25519" !== l) throw new Error("Unknown prime " + l);
                    f = new Xe
                }
                return it[l] = f, f
            }, Ee.prototype._verify1 = function (l) {
                ie(0 === l.negative, "red works only with positives"), ie(l.red, "red works only with red numbers")
            }, Ee.prototype._verify2 = function (l, f) {
                ie(0 == (l.negative | f.negative), "red works only with positives"), ie(l.red && l.red === f.red, "red works only with red numbers")
            }, Ee.prototype.imod = function (l) {
                return this.prime ? this.prime.ireduce(l)._forceRed(this) : (me(l, l.umod(this.m)._forceRed(this)), l)
            }, Ee.prototype.neg = function (l) {
                return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this)
            }, Ee.prototype.add = function (l, f) {
                this._verify2(l, f);
                var g = l.add(f);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this)
            }, Ee.prototype.iadd = function (l, f) {
                this._verify2(l, f);
                var g = l.iadd(f);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g
            }, Ee.prototype.sub = function (l, f) {
                this._verify2(l, f);
                var g = l.sub(f);
                return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this)
            }, Ee.prototype.isub = function (l, f) {
                this._verify2(l, f);
                var g = l.isub(f);
                return g.cmpn(0) < 0 && g.iadd(this.m), g
            }, Ee.prototype.shl = function (l, f) {
                return this._verify1(l), this.imod(l.ushln(f))
            }, Ee.prototype.imul = function (l, f) {
                return this._verify2(l, f), this.imod(l.imul(f))
            }, Ee.prototype.mul = function (l, f) {
                return this._verify2(l, f), this.imod(l.mul(f))
            }, Ee.prototype.isqr = function (l) {
                return this.imul(l, l.clone())
            }, Ee.prototype.sqr = function (l) {
                return this.mul(l, l)
            }, Ee.prototype.sqrt = function (l) {
                if (l.isZero()) return l.clone();
                var f = this.m.andln(3);
                if (ie(f % 2 == 1), 3 === f) {
                    var g = this.m.add(new j(1)).iushrn(2);
                    return this.pow(l, g)
                }
                for (var v = this.m.subn(1), w = 0; !v.isZero() && 0 === v.andln(1);) w++, v.iushrn(1);
                ie(!v.isZero());
                var P = new j(1).toRed(this), B = P.redNeg(), O = this.m.subn(1).iushrn(1), E = this.m.bitLength();
                for (E = new j(2 * E * E).toRed(this); 0 !== this.pow(E, O).cmp(B);) E.redIAdd(B);
                for (var Z = this.pow(E, v), ze = this.pow(l, v.addn(1).iushrn(1)), Je = this.pow(l, v), q = w; 0 !== Je.cmp(P);) {
                    for (var Le = Je, ut = 0; 0 !== Le.cmp(P); ut++) Le = Le.redSqr();
                    ie(ut < q);
                    var Ye = this.pow(Z, new j(1).iushln(q - ut - 1));
                    ze = ze.redMul(Ye), Z = Ye.redSqr(), Je = Je.redMul(Z), q = ut
                }
                return ze
            }, Ee.prototype.invm = function (l) {
                var f = l._invmp(this.m);
                return 0 !== f.negative ? (f.negative = 0, this.imod(f).redNeg()) : this.imod(f)
            }, Ee.prototype.pow = function (l, f) {
                if (f.isZero()) return new j(1).toRed(this);
                if (0 === f.cmpn(1)) return l.clone();
                var v = new Array(16);
                v[0] = new j(1).toRed(this), v[1] = l;
                for (var w = 2; w < v.length; w++) v[w] = this.mul(v[w - 1], l);
                var P = v[0], B = 0, O = 0, E = f.bitLength() % 26;
                for (0 === E && (E = 26), w = f.length - 1; w >= 0; w--) {
                    for (var Z = f.words[w], ze = E - 1; ze >= 0; ze--) {
                        var Je = Z >> ze & 1;
                        P !== v[0] && (P = this.sqr(P)), 0 !== Je || 0 !== B ? (B <<= 1, B |= Je, (4 == ++O || 0 === w && 0 === ze) && (P = this.mul(P, v[B]), O = 0, B = 0)) : O = 0
                    }
                    E = 26
                }
                return P
            }, Ee.prototype.convertTo = function (l) {
                var f = l.umod(this.m);
                return f === l ? f.clone() : f
            }, Ee.prototype.convertFrom = function (l) {
                var f = l.clone();
                return f.red = null, f
            }, j.mont = function (l) {
                return new ce(l)
            }, te(ce, Ee), ce.prototype.convertTo = function (l) {
                return this.imod(l.ushln(this.shift))
            }, ce.prototype.convertFrom = function (l) {
                var f = this.imod(l.mul(this.rinv));
                return f.red = null, f
            }, ce.prototype.imul = function (l, f) {
                if (l.isZero() || f.isZero()) return l.words[0] = 0, l.length = 1, l;
                var g = l.imul(f), v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    w = g.isub(v).iushrn(this.shift), P = w;
                return w.cmp(this.m) >= 0 ? P = w.isub(this.m) : w.cmpn(0) < 0 && (P = w.iadd(this.m)), P._forceRed(this)
            }, ce.prototype.mul = function (l, f) {
                if (l.isZero() || f.isZero()) return new j(0)._forceRed(this);
                var g = l.mul(f), v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    w = g.isub(v).iushrn(this.shift), P = w;
                return w.cmp(this.m) >= 0 ? P = w.isub(this.m) : w.cmpn(0) < 0 && (P = w.iadd(this.m)), P._forceRed(this)
            }, ce.prototype.invm = function (l) {
                return this.imod(l._invmp(this.m).mul(this.r2))._forceRed(this)
            }
        }(Jt = R.nmd(Jt), this)
    }, 7084: (Jt, lt, R) => {
        var r = lt;
        r.utils = R(9299), r.common = R(3800), r.sha = R(4962), r.ripemd = R(9458), r.hmac = R(2194), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160
    }, 3800: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(2391);

        function ie() {
            this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
        }

        lt.BlockHash = ie, ie.prototype.update = function (j, W) {
            if (j = r.toArray(j, W), this.pending = this.pending ? this.pending.concat(j) : j, this.pendingTotal += j.length, this.pending.length >= this._delta8) {
                var Q = (j = this.pending).length % this._delta8;
                this.pending = j.slice(j.length - Q, j.length), 0 === this.pending.length && (this.pending = null), j = r.join32(j, 0, j.length - Q, this.endian);
                for (var Ne = 0; Ne < j.length; Ne += this._delta32) this._update(j, Ne, Ne + this._delta32)
            }
            return this
        }, ie.prototype.digest = function (j) {
            return this.update(this._pad()), D(null === this.pending), this._digest(j)
        }, ie.prototype._pad = function () {
            var j = this.pendingTotal, W = this._delta8, Q = W - (j + this.padLength) % W,
                Ne = new Array(Q + this.padLength);
            Ne[0] = 128;
            for (var ve = 1; ve < Q; ve++) Ne[ve] = 0;
            if (j <<= 3, "big" === this.endian) {
                for (var me = 8; me < this.padLength; me++) Ne[ve++] = 0;
                Ne[ve++] = 0, Ne[ve++] = 0, Ne[ve++] = 0, Ne[ve++] = 0, Ne[ve++] = j >>> 24 & 255, Ne[ve++] = j >>> 16 & 255, Ne[ve++] = j >>> 8 & 255, Ne[ve++] = 255 & j
            } else for (Ne[ve++] = 255 & j, Ne[ve++] = j >>> 8 & 255, Ne[ve++] = j >>> 16 & 255, Ne[ve++] = j >>> 24 & 255, Ne[ve++] = 0, Ne[ve++] = 0, Ne[ve++] = 0, Ne[ve++] = 0, me = 8; me < this.padLength; me++) Ne[ve++] = 0;
            return Ne
        }
    }, 2194: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(2391);

        function ie(te, j, W) {
            if (!(this instanceof ie)) return new ie(te, j, W);
            this.Hash = te, this.blockSize = te.blockSize / 8, this.outSize = te.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(j, W))
        }

        Jt.exports = ie, ie.prototype._init = function (j) {
            j.length > this.blockSize && (j = (new this.Hash).update(j).digest()), D(j.length <= this.blockSize);
            for (var W = j.length; W < this.blockSize; W++) j.push(0);
            for (W = 0; W < j.length; W++) j[W] ^= 54;
            for (this.inner = (new this.Hash).update(j), W = 0; W < j.length; W++) j[W] ^= 106;
            this.outer = (new this.Hash).update(j)
        }, ie.prototype.update = function (j, W) {
            return this.inner.update(j, W), this
        }, ie.prototype.digest = function (j) {
            return this.outer.update(this.inner.digest()), this.outer.digest(j)
        }
    }, 9458: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(3800), ie = r.rotl32, te = r.sum32, j = r.sum32_3, W = r.sum32_4, Q = D.BlockHash;

        function Ne() {
            if (!(this instanceof Ne)) return new Ne;
            Q.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
        }

        function ve(oe, ge, Ie, he) {
            return oe <= 15 ? ge ^ Ie ^ he : oe <= 31 ? ge & Ie | ~ge & he : oe <= 47 ? (ge | ~Ie) ^ he : oe <= 63 ? ge & he | Ie & ~he : ge ^ (Ie | ~he)
        }

        function ae(oe) {
            return oe <= 15 ? 1352829926 : oe <= 31 ? 1548603684 : oe <= 47 ? 1836072691 : oe <= 63 ? 2053994217 : 0
        }

        r.inherits(Ne, Q), lt.ripemd160 = Ne, Ne.blockSize = 512, Ne.outSize = 160, Ne.hmacStrength = 192, Ne.padLength = 64, Ne.prototype._update = function (ge, Ie) {
            for (var he = this.h[0], xe = this.h[1], Ue = this.h[2], it = this.h[3], yt = this.h[4], Ce = he, $e = xe, rt = Ue, Xe = it, Ee = yt, ce = 0; ce < 80; ce++) {
                var I = te(ie(W(he, ve(ce, xe, Ue, it), ge[X[ce] + Ie], (oe = ce) <= 15 ? 0 : oe <= 31 ? 1518500249 : oe <= 47 ? 1859775393 : oe <= 63 ? 2400959708 : 2840853838), H[ce]), yt);
                he = yt, yt = it, it = ie(Ue, 10), Ue = xe, xe = I, I = te(ie(W(Ce, ve(79 - ce, $e, rt, Xe), ge[M[ce] + Ie], ae(ce)), F[ce]), Ee), Ce = Ee, Ee = Xe, Xe = ie(rt, 10), rt = $e, $e = I
            }
            var oe;
            I = j(this.h[1], Ue, Xe), this.h[1] = j(this.h[2], it, Ee), this.h[2] = j(this.h[3], yt, Ce), this.h[3] = j(this.h[4], he, $e), this.h[4] = j(this.h[0], xe, rt), this.h[0] = I
        }, Ne.prototype._digest = function (ge) {
            return "hex" === ge ? r.toHex32(this.h, "little") : r.split32(this.h, "little")
        };
        var X = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
            M = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
            H = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
            F = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
    }, 4962: (Jt, lt, R) => {
        "use strict";
        lt.sha1 = R(9007), lt.sha224 = R(55), lt.sha256 = R(9342), lt.sha384 = R(8634), lt.sha512 = R(39)
    }, 9007: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(3800), ie = R(3113), te = r.rotl32, j = r.sum32, W = r.sum32_5, Q = ie.ft_1,
            Ne = D.BlockHash, ve = [1518500249, 1859775393, 2400959708, 3395469782];

        function me() {
            if (!(this instanceof me)) return new me;
            Ne.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
        }

        r.inherits(me, Ne), Jt.exports = me, me.blockSize = 512, me.outSize = 160, me.hmacStrength = 80, me.padLength = 64, me.prototype._update = function (X, M) {
            for (var H = this.W, F = 0; F < 16; F++) H[F] = X[M + F];
            for (; F < H.length; F++) H[F] = te(H[F - 3] ^ H[F - 8] ^ H[F - 14] ^ H[F - 16], 1);
            var oe = this.h[0], ge = this.h[1], Ie = this.h[2], he = this.h[3], xe = this.h[4];
            for (F = 0; F < H.length; F++) {
                var Ue = ~~(F / 20), it = W(te(oe, 5), Q(Ue, ge, Ie, he), xe, H[F], ve[Ue]);
                xe = he, he = Ie, Ie = te(ge, 30), ge = oe, oe = it
            }
            this.h[0] = j(this.h[0], oe), this.h[1] = j(this.h[1], ge), this.h[2] = j(this.h[2], Ie), this.h[3] = j(this.h[3], he), this.h[4] = j(this.h[4], xe)
        }, me.prototype._digest = function (X) {
            return "hex" === X ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
        }
    }, 55: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(9342);

        function ie() {
            if (!(this instanceof ie)) return new ie;
            D.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
        }

        r.inherits(ie, D), Jt.exports = ie, ie.blockSize = 512, ie.outSize = 224, ie.hmacStrength = 192, ie.padLength = 64, ie.prototype._digest = function (j) {
            return "hex" === j ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big")
        }
    }, 9342: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(3800), ie = R(3113), te = R(2391), j = r.sum32, W = r.sum32_4, Q = r.sum32_5,
            Ne = ie.ch32, ve = ie.maj32, me = ie.s0_256, ae = ie.s1_256, X = ie.g0_256, M = ie.g1_256, H = D.BlockHash,
            F = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

        function oe() {
            if (!(this instanceof oe)) return new oe;
            H.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = F, this.W = new Array(64)
        }

        r.inherits(oe, H), Jt.exports = oe, oe.blockSize = 512, oe.outSize = 256, oe.hmacStrength = 192, oe.padLength = 64, oe.prototype._update = function (Ie, he) {
            for (var xe = this.W, Ue = 0; Ue < 16; Ue++) xe[Ue] = Ie[he + Ue];
            for (; Ue < xe.length; Ue++) xe[Ue] = W(M(xe[Ue - 2]), xe[Ue - 7], X(xe[Ue - 15]), xe[Ue - 16]);
            var it = this.h[0], yt = this.h[1], Ce = this.h[2], $e = this.h[3], rt = this.h[4], Xe = this.h[5],
                Ee = this.h[6], ce = this.h[7];
            for (te(this.k.length === xe.length), Ue = 0; Ue < xe.length; Ue++) {
                var I = Q(ce, ae(rt), Ne(rt, Xe, Ee), this.k[Ue], xe[Ue]), l = j(me(it), ve(it, yt, Ce));
                ce = Ee, Ee = Xe, Xe = rt, rt = j($e, I), $e = Ce, Ce = yt, yt = it, it = j(I, l)
            }
            this.h[0] = j(this.h[0], it), this.h[1] = j(this.h[1], yt), this.h[2] = j(this.h[2], Ce), this.h[3] = j(this.h[3], $e), this.h[4] = j(this.h[4], rt), this.h[5] = j(this.h[5], Xe), this.h[6] = j(this.h[6], Ee), this.h[7] = j(this.h[7], ce)
        }, oe.prototype._digest = function (Ie) {
            return "hex" === Ie ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
        }
    }, 8634: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(39);

        function ie() {
            if (!(this instanceof ie)) return new ie;
            D.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
        }

        r.inherits(ie, D), Jt.exports = ie, ie.blockSize = 1024, ie.outSize = 384, ie.hmacStrength = 192, ie.padLength = 128, ie.prototype._digest = function (j) {
            return "hex" === j ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big")
        }
    }, 39: (Jt, lt, R) => {
        "use strict";
        var r = R(9299), D = R(3800), ie = R(2391), te = r.rotr64_hi, j = r.rotr64_lo, W = r.shr64_hi, Q = r.shr64_lo,
            Ne = r.sum64, ve = r.sum64_hi, me = r.sum64_lo, ae = r.sum64_4_hi, X = r.sum64_4_lo, M = r.sum64_5_hi,
            H = r.sum64_5_lo, F = D.BlockHash,
            oe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

        function ge() {
            if (!(this instanceof ge)) return new ge;
            F.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = oe, this.W = new Array(160)
        }

        function Ie(I, l, f, g, v) {
            var w = I & f ^ ~I & v;
            return w < 0 && (w += 4294967296), w
        }

        function he(I, l, f, g, v, w) {
            var P = l & g ^ ~l & w;
            return P < 0 && (P += 4294967296), P
        }

        function xe(I, l, f, g, v) {
            var w = I & f ^ I & v ^ f & v;
            return w < 0 && (w += 4294967296), w
        }

        function Ue(I, l, f, g, v, w) {
            var P = l & g ^ l & w ^ g & w;
            return P < 0 && (P += 4294967296), P
        }

        function it(I, l) {
            var w = te(I, l, 28) ^ te(l, I, 2) ^ te(l, I, 7);
            return w < 0 && (w += 4294967296), w
        }

        function yt(I, l) {
            var w = j(I, l, 28) ^ j(l, I, 2) ^ j(l, I, 7);
            return w < 0 && (w += 4294967296), w
        }

        function Ce(I, l) {
            var w = te(I, l, 14) ^ te(I, l, 18) ^ te(l, I, 9);
            return w < 0 && (w += 4294967296), w
        }

        function $e(I, l) {
            var w = j(I, l, 14) ^ j(I, l, 18) ^ j(l, I, 9);
            return w < 0 && (w += 4294967296), w
        }

        function rt(I, l) {
            var w = te(I, l, 1) ^ te(I, l, 8) ^ W(I, l, 7);
            return w < 0 && (w += 4294967296), w
        }

        function Xe(I, l) {
            var w = j(I, l, 1) ^ j(I, l, 8) ^ Q(I, l, 7);
            return w < 0 && (w += 4294967296), w
        }

        function Ee(I, l) {
            var w = te(I, l, 19) ^ te(l, I, 29) ^ W(I, l, 6);
            return w < 0 && (w += 4294967296), w
        }

        function ce(I, l) {
            var w = j(I, l, 19) ^ j(l, I, 29) ^ Q(I, l, 6);
            return w < 0 && (w += 4294967296), w
        }

        r.inherits(ge, F), Jt.exports = ge, ge.blockSize = 1024, ge.outSize = 512, ge.hmacStrength = 192, ge.padLength = 128, ge.prototype._prepareBlock = function (l, f) {
            for (var g = this.W, v = 0; v < 32; v++) g[v] = l[f + v];
            for (; v < g.length; v += 2) {
                var w = Ee(g[v - 4], g[v - 3]), P = ce(g[v - 4], g[v - 3]), B = g[v - 14], O = g[v - 13],
                    E = rt(g[v - 30], g[v - 29]), Z = Xe(g[v - 30], g[v - 29]), ze = g[v - 32], Je = g[v - 31];
                g[v] = ae(w, P, B, O, E, Z, ze, Je), g[v + 1] = X(w, P, B, O, E, Z, ze, Je)
            }
        }, ge.prototype._update = function (l, f) {
            this._prepareBlock(l, f);
            var g = this.W, v = this.h[0], w = this.h[1], P = this.h[2], B = this.h[3], O = this.h[4], E = this.h[5],
                Z = this.h[6], ze = this.h[7], Je = this.h[8], q = this.h[9], Le = this.h[10], ut = this.h[11],
                Ye = this.h[12], Mt = this.h[13], _t = this.h[14], Pt = this.h[15];
            ie(this.k.length === g.length);
            for (var Gt = 0; Gt < g.length; Gt += 2) {
                var yn = _t, Xt = Pt, xn = Ce(Je, q), Fn = $e(Je, q), wn = Ie(Je, 0, Le, 0, Ye),
                    Nn = he(0, q, 0, ut, 0, Mt), On = this.k[Gt], Me = this.k[Gt + 1], ne = g[Gt], U = g[Gt + 1],
                    de = M(yn, Xt, xn, Fn, wn, Nn, On, Me, ne, U), Ze = H(yn, Xt, xn, Fn, wn, Nn, On, Me, ne, U);
                yn = it(v, w), Xt = yt(v, w), xn = xe(v, 0, P, 0, O), Fn = Ue(0, w, 0, B, 0, E);
                var Ge = ve(yn, Xt, xn, Fn), ye = me(yn, Xt, xn, Fn);
                _t = Ye, Pt = Mt, Ye = Le, Mt = ut, Le = Je, ut = q, Je = ve(Z, ze, de, Ze), q = me(ze, ze, de, Ze), Z = O, ze = E, O = P, E = B, P = v, B = w, v = ve(de, Ze, Ge, ye), w = me(de, Ze, Ge, ye)
            }
            Ne(this.h, 0, v, w), Ne(this.h, 2, P, B), Ne(this.h, 4, O, E), Ne(this.h, 6, Z, ze), Ne(this.h, 8, Je, q), Ne(this.h, 10, Le, ut), Ne(this.h, 12, Ye, Mt), Ne(this.h, 14, _t, Pt)
        }, ge.prototype._digest = function (l) {
            return "hex" === l ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
        }
    }, 3113: (Jt, lt, R) => {
        "use strict";
        var D = R(9299).rotr32;

        function te(ae, X, M) {
            return ae & X ^ ~ae & M
        }

        function j(ae, X, M) {
            return ae & X ^ ae & M ^ X & M
        }

        function W(ae, X, M) {
            return ae ^ X ^ M
        }

        lt.ft_1 = function ie(ae, X, M, H) {
            return 0 === ae ? te(X, M, H) : 1 === ae || 3 === ae ? W(X, M, H) : 2 === ae ? j(X, M, H) : void 0
        }, lt.ch32 = te, lt.maj32 = j, lt.p32 = W, lt.s0_256 = function Q(ae) {
            return D(ae, 2) ^ D(ae, 13) ^ D(ae, 22)
        }, lt.s1_256 = function Ne(ae) {
            return D(ae, 6) ^ D(ae, 11) ^ D(ae, 25)
        }, lt.g0_256 = function ve(ae) {
            return D(ae, 7) ^ D(ae, 18) ^ ae >>> 3
        }, lt.g1_256 = function me(ae) {
            return D(ae, 17) ^ D(ae, 19) ^ ae >>> 10
        }
    }, 9299: (Jt, lt, R) => {
        "use strict";
        var r = R(2391), D = R(3894);

        function ie(ce, I) {
            return !(55296 != (64512 & ce.charCodeAt(I)) || I < 0 || I + 1 >= ce.length) && 56320 == (64512 & ce.charCodeAt(I + 1))
        }

        function W(ce) {
            return (ce >>> 24 | ce >>> 8 & 65280 | ce << 8 & 16711680 | (255 & ce) << 24) >>> 0
        }

        function Ne(ce) {
            return 1 === ce.length ? "0" + ce : ce
        }

        function ve(ce) {
            return 7 === ce.length ? "0" + ce : 6 === ce.length ? "00" + ce : 5 === ce.length ? "000" + ce : 4 === ce.length ? "0000" + ce : 3 === ce.length ? "00000" + ce : 2 === ce.length ? "000000" + ce : 1 === ce.length ? "0000000" + ce : ce
        }

        lt.inherits = D, lt.toArray = function te(ce, I) {
            if (Array.isArray(ce)) return ce.slice();
            if (!ce) return [];
            var l = [];
            if ("string" == typeof ce) if (I) {
                if ("hex" === I) for ((ce = ce.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (ce = "0" + ce), g = 0; g < ce.length; g += 2) l.push(parseInt(ce[g] + ce[g + 1], 16))
            } else for (var f = 0, g = 0; g < ce.length; g++) {
                var v = ce.charCodeAt(g);
                v < 128 ? l[f++] = v : v < 2048 ? (l[f++] = v >> 6 | 192, l[f++] = 63 & v | 128) : ie(ce, g) ? (v = 65536 + ((1023 & v) << 10) + (1023 & ce.charCodeAt(++g)), l[f++] = v >> 18 | 240, l[f++] = v >> 12 & 63 | 128, l[f++] = v >> 6 & 63 | 128, l[f++] = 63 & v | 128) : (l[f++] = v >> 12 | 224, l[f++] = v >> 6 & 63 | 128, l[f++] = 63 & v | 128)
            } else for (g = 0; g < ce.length; g++) l[g] = 0 | ce[g];
            return l
        }, lt.toHex = function j(ce) {
            for (var I = "", l = 0; l < ce.length; l++) I += Ne(ce[l].toString(16));
            return I
        }, lt.htonl = W, lt.toHex32 = function Q(ce, I) {
            for (var l = "", f = 0; f < ce.length; f++) {
                var g = ce[f];
                "little" === I && (g = W(g)), l += ve(g.toString(16))
            }
            return l
        }, lt.zero2 = Ne, lt.zero8 = ve, lt.join32 = function me(ce, I, l, f) {
            var g = l - I;
            r(g % 4 == 0);
            for (var v = new Array(g / 4), w = 0, P = I; w < v.length; w++, P += 4) v[w] = ("big" === f ? ce[P] << 24 | ce[P + 1] << 16 | ce[P + 2] << 8 | ce[P + 3] : ce[P + 3] << 24 | ce[P + 2] << 16 | ce[P + 1] << 8 | ce[P]) >>> 0;
            return v
        }, lt.split32 = function ae(ce, I) {
            for (var l = new Array(4 * ce.length), f = 0, g = 0; f < ce.length; f++, g += 4) {
                var v = ce[f];
                "big" === I ? (l[g] = v >>> 24, l[g + 1] = v >>> 16 & 255, l[g + 2] = v >>> 8 & 255, l[g + 3] = 255 & v) : (l[g + 3] = v >>> 24, l[g + 2] = v >>> 16 & 255, l[g + 1] = v >>> 8 & 255, l[g] = 255 & v)
            }
            return l
        }, lt.rotr32 = function X(ce, I) {
            return ce >>> I | ce << 32 - I
        }, lt.rotl32 = function M(ce, I) {
            return ce << I | ce >>> 32 - I
        }, lt.sum32 = function H(ce, I) {
            return ce + I >>> 0
        }, lt.sum32_3 = function F(ce, I, l) {
            return ce + I + l >>> 0
        }, lt.sum32_4 = function oe(ce, I, l, f) {
            return ce + I + l + f >>> 0
        }, lt.sum32_5 = function ge(ce, I, l, f, g) {
            return ce + I + l + f + g >>> 0
        }, lt.sum64 = function Ie(ce, I, l, f) {
            var w = f + ce[I + 1] >>> 0;
            ce[I] = (w < f ? 1 : 0) + l + ce[I] >>> 0, ce[I + 1] = w
        }, lt.sum64_hi = function he(ce, I, l, f) {
            return (I + f >>> 0 < I ? 1 : 0) + ce + l >>> 0
        }, lt.sum64_lo = function xe(ce, I, l, f) {
            return I + f >>> 0
        }, lt.sum64_4_hi = function Ue(ce, I, l, f, g, v, w, P) {
            var B = 0, O = I;
            return B += (O = O + f >>> 0) < I ? 1 : 0, B += (O = O + v >>> 0) < v ? 1 : 0, ce + l + g + w + (B += (O = O + P >>> 0) < P ? 1 : 0) >>> 0
        }, lt.sum64_4_lo = function it(ce, I, l, f, g, v, w, P) {
            return I + f + v + P >>> 0
        }, lt.sum64_5_hi = function yt(ce, I, l, f, g, v, w, P, B, O) {
            var E = 0, Z = I;
            return E += (Z = Z + f >>> 0) < I ? 1 : 0, E += (Z = Z + v >>> 0) < v ? 1 : 0, E += (Z = Z + P >>> 0) < P ? 1 : 0, ce + l + g + w + B + (E += (Z = Z + O >>> 0) < O ? 1 : 0) >>> 0
        }, lt.sum64_5_lo = function Ce(ce, I, l, f, g, v, w, P, B, O) {
            return I + f + v + P + O >>> 0
        }, lt.rotr64_hi = function $e(ce, I, l) {
            return (I << 32 - l | ce >>> l) >>> 0
        }, lt.rotr64_lo = function rt(ce, I, l) {
            return (ce << 32 - l | I >>> l) >>> 0
        }, lt.shr64_hi = function Xe(ce, I, l) {
            return ce >>> l
        }, lt.shr64_lo = function Ee(ce, I, l) {
            return (ce << 32 - l | I >>> l) >>> 0
        }
    }, 3894: Jt => {
        Jt.exports = "function" == typeof Object.create ? function (R, r) {
            r && (R.super_ = r, R.prototype = Object.create(r.prototype, {
                constructor: {
                    value: R,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }))
        } : function (R, r) {
            if (r) {
                R.super_ = r;
                var D = function () {
                };
                D.prototype = r.prototype, R.prototype = new D, R.prototype.constructor = R
            }
        }
    }, 4237: (Jt, lt, R) => {
        var r;
        !function () {
            "use strict";
            var D = "input is invalid type", te = "object" == typeof window, j = te ? window : {};
            j.JS_SHA3_NO_WINDOW && (te = !1);
            var W = !te && "object" == typeof self;
            !j.JS_SHA3_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node ? j = global : W && (j = self);
            var Ne = !j.JS_SHA3_NO_COMMON_JS && Jt.exports, ve = R.amdO,
                me = !j.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer, ae = "0123456789abcdef".split(""),
                M = [4, 1024, 262144, 67108864], oe = [0, 8, 16, 24],
                ge = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
                Ie = [224, 256, 384, 512], he = [128, 256], xe = ["hex", "buffer", "arrayBuffer", "array", "digest"],
                Ue = {128: 168, 256: 136};
            (j.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function (q) {
                return "[object Array]" === Object.prototype.toString.call(q)
            }), me && (j.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function (q) {
                return "object" == typeof q && q.buffer && q.buffer.constructor === ArrayBuffer
            });
            for (var it = function (q, Le, ut) {
                return function (Ye) {
                    return new Z(q, Le, q).update(Ye)[ut]()
                }
            }, yt = function (q, Le, ut) {
                return function (Ye, Mt) {
                    return new Z(q, Le, Mt).update(Ye)[ut]()
                }
            }, Ce = function (q, Le, ut) {
                return function (Ye, Mt, _t, Pt) {
                    return f["cshake" + q].update(Ye, Mt, _t, Pt)[ut]()
                }
            }, $e = function (q, Le, ut) {
                return function (Ye, Mt, _t, Pt) {
                    return f["kmac" + q].update(Ye, Mt, _t, Pt)[ut]()
                }
            }, rt = function (q, Le, ut, Ye) {
                for (var Mt = 0; Mt < xe.length; ++Mt) {
                    var _t = xe[Mt];
                    q[_t] = Le(ut, Ye, _t)
                }
                return q
            }, Xe = function (q, Le) {
                var ut = it(q, Le, "hex");
                return ut.create = function () {
                    return new Z(q, Le, q)
                }, ut.update = function (Ye) {
                    return ut.create().update(Ye)
                }, rt(ut, it, q, Le)
            }, l = [{name: "keccak", padding: [1, 256, 65536, 16777216], bits: Ie, createMethod: Xe}, {
                name: "sha3",
                padding: [6, 1536, 393216, 100663296],
                bits: Ie,
                createMethod: Xe
            }, {
                name: "shake", padding: [31, 7936, 2031616, 520093696], bits: he, createMethod: function (q, Le) {
                    var ut = yt(q, Le, "hex");
                    return ut.create = function (Ye) {
                        return new Z(q, Le, Ye)
                    }, ut.update = function (Ye, Mt) {
                        return ut.create(Mt).update(Ye)
                    }, rt(ut, yt, q, Le)
                }
            }, {
                name: "cshake", padding: M, bits: he, createMethod: function (q, Le) {
                    var ut = Ue[q], Ye = Ce(q, 0, "hex");
                    return Ye.create = function (Mt, _t, Pt) {
                        return _t || Pt ? new Z(q, Le, Mt).bytepad([_t, Pt], ut) : f["shake" + q].create(Mt)
                    }, Ye.update = function (Mt, _t, Pt, Gt) {
                        return Ye.create(_t, Pt, Gt).update(Mt)
                    }, rt(Ye, Ce, q, Le)
                }
            }, {
                name: "kmac", padding: M, bits: he, createMethod: function (q, Le) {
                    var ut = Ue[q], Ye = $e(q, 0, "hex");
                    return Ye.create = function (Mt, _t, Pt) {
                        return new ze(q, Le, _t).bytepad(["KMAC", Pt], ut).bytepad([Mt], ut)
                    }, Ye.update = function (Mt, _t, Pt, Gt) {
                        return Ye.create(Mt, Pt, Gt).update(_t)
                    }, rt(Ye, $e, q, Le)
                }
            }], f = {}, g = [], v = 0; v < l.length; ++v) for (var w = l[v], P = w.bits, B = 0; B < P.length; ++B) {
                var O = w.name + "_" + P[B];
                if (g.push(O), f[O] = w.createMethod(P[B], w.padding), "sha3" !== w.name) {
                    var E = w.name + P[B];
                    g.push(E), f[E] = f[O]
                }
            }

            function Z(q, Le, ut) {
                this.blocks = [], this.s = [], this.padding = Le, this.outputBits = ut, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (q << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = ut >> 5, this.extraBytes = (31 & ut) >> 3;
                for (var Ye = 0; Ye < 50; ++Ye) this.s[Ye] = 0
            }

            function ze(q, Le, ut) {
                Z.call(this, q, Le, ut)
            }

            Z.prototype.update = function (q) {
                if (this.finalized) throw new Error("finalize already called");
                var Le, ut = typeof q;
                if ("string" !== ut) {
                    if ("object" !== ut) throw new Error(D);
                    if (null === q) throw new Error(D);
                    if (me && q.constructor === ArrayBuffer) q = new Uint8Array(q); else if (!(Array.isArray(q) || me && ArrayBuffer.isView(q))) throw new Error(D);
                    Le = !0
                }
                for (var Xt, xn, Ye = this.blocks, Mt = this.byteCount, _t = q.length, Pt = this.blockCount, Gt = 0, yn = this.s; Gt < _t;) {
                    if (this.reset) for (this.reset = !1, Ye[0] = this.block, Xt = 1; Xt < Pt + 1; ++Xt) Ye[Xt] = 0;
                    if (Le) for (Xt = this.start; Gt < _t && Xt < Mt; ++Gt) Ye[Xt >> 2] |= q[Gt] << oe[3 & Xt++]; else for (Xt = this.start; Gt < _t && Xt < Mt; ++Gt) (xn = q.charCodeAt(Gt)) < 128 ? Ye[Xt >> 2] |= xn << oe[3 & Xt++] : xn < 2048 ? (Ye[Xt >> 2] |= (192 | xn >> 6) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | 63 & xn) << oe[3 & Xt++]) : xn < 55296 || xn >= 57344 ? (Ye[Xt >> 2] |= (224 | xn >> 12) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | xn >> 6 & 63) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | 63 & xn) << oe[3 & Xt++]) : (xn = 65536 + ((1023 & xn) << 10 | 1023 & q.charCodeAt(++Gt)), Ye[Xt >> 2] |= (240 | xn >> 18) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | xn >> 12 & 63) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | xn >> 6 & 63) << oe[3 & Xt++], Ye[Xt >> 2] |= (128 | 63 & xn) << oe[3 & Xt++]);
                    if (this.lastByteIndex = Xt, Xt >= Mt) {
                        for (this.start = Xt - Mt, this.block = Ye[Pt], Xt = 0; Xt < Pt; ++Xt) yn[Xt] ^= Ye[Xt];
                        Je(yn), this.reset = !0
                    } else this.start = Xt
                }
                return this
            }, Z.prototype.encode = function (q, Le) {
                var ut = 255 & q, Ye = 1, Mt = [ut];
                for (ut = 255 & (q >>= 8); ut > 0;) Mt.unshift(ut), ut = 255 & (q >>= 8), ++Ye;
                return Le ? Mt.push(Ye) : Mt.unshift(Ye), this.update(Mt), Mt.length
            }, Z.prototype.encodeString = function (q) {
                var Le, ut = typeof q;
                if ("string" !== ut) {
                    if ("object" !== ut) throw new Error(D);
                    if (null === q) throw new Error(D);
                    if (me && q.constructor === ArrayBuffer) q = new Uint8Array(q); else if (!(Array.isArray(q) || me && ArrayBuffer.isView(q))) throw new Error(D);
                    Le = !0
                }
                var Ye = 0;
                if (Le) Ye = q.length; else for (var _t = 0; _t < q.length; ++_t) {
                    var Pt = q.charCodeAt(_t);
                    Pt < 128 ? Ye += 1 : Pt < 2048 ? Ye += 2 : Pt < 55296 || Pt >= 57344 ? Ye += 3 : (Pt = 65536 + ((1023 & Pt) << 10 | 1023 & q.charCodeAt(++_t)), Ye += 4)
                }
                return Ye += this.encode(8 * Ye), this.update(q), Ye
            }, Z.prototype.bytepad = function (q, Le) {
                for (var ut = this.encode(Le), Ye = 0; Ye < q.length; ++Ye) ut += this.encodeString(q[Ye]);
                var _t = [];
                return _t.length = Le - ut % Le, this.update(_t), this
            }, Z.prototype.finalize = function () {
                if (!this.finalized) {
                    this.finalized = !0;
                    var q = this.blocks, Le = this.lastByteIndex, ut = this.blockCount, Ye = this.s;
                    if (q[Le >> 2] |= this.padding[3 & Le], this.lastByteIndex === this.byteCount) for (q[0] = q[ut], Le = 1; Le < ut + 1; ++Le) q[Le] = 0;
                    for (q[ut - 1] |= 2147483648, Le = 0; Le < ut; ++Le) Ye[Le] ^= q[Le];
                    Je(Ye)
                }
            }, Z.prototype.toString = Z.prototype.hex = function () {
                this.finalize();
                for (var Gt, q = this.blockCount, Le = this.s, ut = this.outputBlocks, Ye = this.extraBytes, Mt = 0, _t = 0, Pt = ""; _t < ut;) {
                    for (Mt = 0; Mt < q && _t < ut; ++Mt, ++_t) Pt += ae[(Gt = Le[Mt]) >> 4 & 15] + ae[15 & Gt] + ae[Gt >> 12 & 15] + ae[Gt >> 8 & 15] + ae[Gt >> 20 & 15] + ae[Gt >> 16 & 15] + ae[Gt >> 28 & 15] + ae[Gt >> 24 & 15];
                    _t % q == 0 && (Je(Le), Mt = 0)
                }
                return Ye && (Pt += ae[(Gt = Le[Mt]) >> 4 & 15] + ae[15 & Gt], Ye > 1 && (Pt += ae[Gt >> 12 & 15] + ae[Gt >> 8 & 15]), Ye > 2 && (Pt += ae[Gt >> 20 & 15] + ae[Gt >> 16 & 15])), Pt
            }, Z.prototype.buffer = Z.prototype.arrayBuffer = function () {
                this.finalize();
                var Gt, q = this.blockCount, Le = this.s, ut = this.outputBlocks, Ye = this.extraBytes, Mt = 0, _t = 0,
                    Pt = this.outputBits >> 3;
                Gt = Ye ? new ArrayBuffer(ut + 1 << 2) : new ArrayBuffer(Pt);
                for (var yn = new Uint32Array(Gt); _t < ut;) {
                    for (Mt = 0; Mt < q && _t < ut; ++Mt, ++_t) yn[_t] = Le[Mt];
                    _t % q == 0 && Je(Le)
                }
                return Ye && (yn[Mt] = Le[Mt], Gt = Gt.slice(0, Pt)), Gt
            }, Z.prototype.digest = Z.prototype.array = function () {
                this.finalize();
                for (var Gt, yn, q = this.blockCount, Le = this.s, ut = this.outputBlocks, Ye = this.extraBytes, Mt = 0, _t = 0, Pt = []; _t < ut;) {
                    for (Mt = 0; Mt < q && _t < ut; ++Mt, ++_t) Pt[Gt = _t << 2] = 255 & (yn = Le[Mt]), Pt[Gt + 1] = yn >> 8 & 255, Pt[Gt + 2] = yn >> 16 & 255, Pt[Gt + 3] = yn >> 24 & 255;
                    _t % q == 0 && Je(Le)
                }
                return Ye && (Pt[Gt = _t << 2] = 255 & (yn = Le[Mt]), Ye > 1 && (Pt[Gt + 1] = yn >> 8 & 255), Ye > 2 && (Pt[Gt + 2] = yn >> 16 & 255)), Pt
            }, (ze.prototype = new Z).finalize = function () {
                return this.encode(this.outputBits, !0), Z.prototype.finalize.call(this)
            };
            var Je = function (q) {
                var Le, ut, Ye, Mt, _t, Pt, Gt, yn, Xt, xn, Fn, wn, Nn, On, Me, ne, U, de, Ze, Ge, ye, Te, Be, tt, Dt,
                    Ft, zt, dn, Bt, Ht, bn, fn, rn, gn, Hn, jn, fr, qn, Yn, Qn, Wn, Xn, Dr, It, vt, Qe, ht, jt, gt, dt,
                    wt, Ut, Qt, sn, un, Pn, mn, Mn, an, En, Sn, ar, Un;
                for (Ye = 0; Ye < 48; Ye += 2) Mt = q[0] ^ q[10] ^ q[20] ^ q[30] ^ q[40], _t = q[1] ^ q[11] ^ q[21] ^ q[31] ^ q[41], yn = q[4] ^ q[14] ^ q[24] ^ q[34] ^ q[44], Xt = q[5] ^ q[15] ^ q[25] ^ q[35] ^ q[45], xn = q[6] ^ q[16] ^ q[26] ^ q[36] ^ q[46], Fn = q[7] ^ q[17] ^ q[27] ^ q[37] ^ q[47], ut = (Nn = q[9] ^ q[19] ^ q[29] ^ q[39] ^ q[49]) ^ ((Gt = q[3] ^ q[13] ^ q[23] ^ q[33] ^ q[43]) << 1 | (Pt = q[2] ^ q[12] ^ q[22] ^ q[32] ^ q[42]) >>> 31), q[0] ^= Le = (wn = q[8] ^ q[18] ^ q[28] ^ q[38] ^ q[48]) ^ (Pt << 1 | Gt >>> 31), q[1] ^= ut, q[10] ^= Le, q[11] ^= ut, q[20] ^= Le, q[21] ^= ut, q[30] ^= Le, q[31] ^= ut, q[40] ^= Le, q[41] ^= ut, ut = _t ^ (Xt << 1 | yn >>> 31), q[2] ^= Le = Mt ^ (yn << 1 | Xt >>> 31), q[3] ^= ut, q[12] ^= Le, q[13] ^= ut, q[22] ^= Le, q[23] ^= ut, q[32] ^= Le, q[33] ^= ut, q[42] ^= Le, q[43] ^= ut, ut = Gt ^ (Fn << 1 | xn >>> 31), q[4] ^= Le = Pt ^ (xn << 1 | Fn >>> 31), q[5] ^= ut, q[14] ^= Le, q[15] ^= ut, q[24] ^= Le, q[25] ^= ut, q[34] ^= Le, q[35] ^= ut, q[44] ^= Le, q[45] ^= ut, ut = Xt ^ (Nn << 1 | wn >>> 31), q[6] ^= Le = yn ^ (wn << 1 | Nn >>> 31), q[7] ^= ut, q[16] ^= Le, q[17] ^= ut, q[26] ^= Le, q[27] ^= ut, q[36] ^= Le, q[37] ^= ut, q[46] ^= Le, q[47] ^= ut, ut = Fn ^ (_t << 1 | Mt >>> 31), q[8] ^= Le = xn ^ (Mt << 1 | _t >>> 31), q[9] ^= ut, q[18] ^= Le, q[19] ^= ut, q[28] ^= Le, q[29] ^= ut, q[38] ^= Le, q[39] ^= ut, q[48] ^= Le, q[49] ^= ut, Me = q[1], Qe = q[11] << 4 | q[10] >>> 28, ht = q[10] << 4 | q[11] >>> 28, dn = q[20] << 3 | q[21] >>> 29, Bt = q[21] << 3 | q[20] >>> 29, En = q[31] << 9 | q[30] >>> 23, Sn = q[30] << 9 | q[31] >>> 23, Xn = q[40] << 18 | q[41] >>> 14, Dr = q[41] << 18 | q[40] >>> 14, gn = q[2] << 1 | q[3] >>> 31, Hn = q[3] << 1 | q[2] >>> 31, U = q[12] << 12 | q[13] >>> 20, jt = q[22] << 10 | q[23] >>> 22, gt = q[23] << 10 | q[22] >>> 22, Ht = q[33] << 13 | q[32] >>> 19, bn = q[32] << 13 | q[33] >>> 19, ar = q[42] << 2 | q[43] >>> 30, Un = q[43] << 2 | q[42] >>> 30, sn = q[5] << 30 | q[4] >>> 2, un = q[4] << 30 | q[5] >>> 2, jn = q[14] << 6 | q[15] >>> 26, fr = q[15] << 6 | q[14] >>> 26, Ze = q[24] << 11 | q[25] >>> 21, dt = q[34] << 15 | q[35] >>> 17, wt = q[35] << 15 | q[34] >>> 17, fn = q[45] << 29 | q[44] >>> 3, rn = q[44] << 29 | q[45] >>> 3, tt = q[6] << 28 | q[7] >>> 4, Dt = q[7] << 28 | q[6] >>> 4, Pn = q[17] << 23 | q[16] >>> 9, mn = q[16] << 23 | q[17] >>> 9, qn = q[26] << 25 | q[27] >>> 7, Yn = q[27] << 25 | q[26] >>> 7, Ge = q[36] << 21 | q[37] >>> 11, ye = q[37] << 21 | q[36] >>> 11, Ut = q[47] << 24 | q[46] >>> 8, Qt = q[46] << 24 | q[47] >>> 8, It = q[8] << 27 | q[9] >>> 5, vt = q[9] << 27 | q[8] >>> 5, Ft = q[18] << 20 | q[19] >>> 12,zt = q[19] << 20 | q[18] >>> 12,Mn = q[29] << 7 | q[28] >>> 25,an = q[28] << 7 | q[29] >>> 25,Qn = q[38] << 8 | q[39] >>> 24,Wn = q[39] << 8 | q[38] >>> 24,Te = q[48] << 14 | q[49] >>> 18,Be = q[49] << 14 | q[48] >>> 18,q[0] = (On = q[0]) ^ ~(ne = q[13] << 12 | q[12] >>> 20) & (de = q[25] << 11 | q[24] >>> 21),q[1] = Me ^ ~U & Ze,q[10] = tt ^ ~Ft & dn,q[11] = Dt ^ ~zt & Bt,q[20] = gn ^ ~jn & qn,q[21] = Hn ^ ~fr & Yn,q[30] = It ^ ~Qe & jt,q[31] = vt ^ ~ht & gt,q[40] = sn ^ ~Pn & Mn,q[41] = un ^ ~mn & an,q[2] = ne ^ ~de & Ge,q[3] = U ^ ~Ze & ye,q[12] = Ft ^ ~dn & Ht,q[13] = zt ^ ~Bt & bn,q[22] = jn ^ ~qn & Qn,q[23] = fr ^ ~Yn & Wn,q[32] = Qe ^ ~jt & dt,q[33] = ht ^ ~gt & wt,q[42] = Pn ^ ~Mn & En,q[43] = mn ^ ~an & Sn,q[4] = de ^ ~Ge & Te,q[5] = Ze ^ ~ye & Be,q[14] = dn ^ ~Ht & fn,q[15] = Bt ^ ~bn & rn,q[24] = qn ^ ~Qn & Xn,q[25] = Yn ^ ~Wn & Dr,q[34] = jt ^ ~dt & Ut,q[35] = gt ^ ~wt & Qt,q[44] = Mn ^ ~En & ar,q[45] = an ^ ~Sn & Un,q[6] = Ge ^ ~Te & On,q[7] = ye ^ ~Be & Me,q[16] = Ht ^ ~fn & tt,q[17] = bn ^ ~rn & Dt,q[26] = Qn ^ ~Xn & gn,q[27] = Wn ^ ~Dr & Hn,q[36] = dt ^ ~Ut & It,q[37] = wt ^ ~Qt & vt,q[46] = En ^ ~ar & sn,q[47] = Sn ^ ~Un & un,q[8] = Te ^ ~On & ne,q[9] = Be ^ ~Me & U,q[18] = fn ^ ~tt & Ft,q[19] = rn ^ ~Dt & zt,q[28] = Xn ^ ~gn & jn,q[29] = Dr ^ ~Hn & fr,q[38] = Ut ^ ~It & Qe,q[39] = Qt ^ ~vt & ht,q[48] = ar ^ ~sn & Pn,q[49] = Un ^ ~un & mn,q[0] ^= ge[Ye],q[1] ^= ge[Ye + 1]
            };
            if (Ne) Jt.exports = f; else {
                for (v = 0; v < g.length; ++v) j[g[v]] = f[g[v]];
                ve && void 0 !== (r = function () {
                    return f
                }.call(lt, R, lt, Jt)) && (Jt.exports = r)
            }
        }()
    }, 2391: Jt => {
        function lt(R, r) {
            if (!R) throw new Error(r || "Assertion failed")
        }

        Jt.exports = lt, lt.equal = function (r, D, ie) {
            if (r != D) throw new Error(ie || "Assertion failed: " + r + " != " + D)
        }
    }, 591: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {X: () => ie});
        var r = R(5529), D = R(5279);

        class ie extends r.xQ {
            constructor(j) {
                super(), this._value = j
            }

            get value() {
                return this.getValue()
            }

            _subscribe(j) {
                const W = super._subscribe(j);
                return W && !W.closed && j.next(this._value), W
            }

            getValue() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new D.N;
                return this._value
            }

            next(j) {
                super.next(this._value = j)
            }
        }
    }, 2916: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {y: () => ae});
        var r = R(3489), ie = R(7668), te = R(3292), W = R(3821), Q = R(5379);
        var me = R(2830);
        let ae = (() => {
            class M {
                constructor(F) {
                    this._isScalar = !1, F && (this._subscribe = F)
                }

                lift(F) {
                    const oe = new M;
                    return oe.source = this, oe.operator = F, oe
                }

                subscribe(F, oe, ge) {
                    const {operator: Ie} = this, he = function j(M, H, F) {
                        if (M) {
                            if (M instanceof r.L) return M;
                            if (M[ie.b]) return M[ie.b]()
                        }
                        return M || H || F ? new r.L(M, H, F) : new r.L(te.c)
                    }(F, oe, ge);
                    if (he.add(Ie ? Ie.call(he, this.source) : this.source || me.v.useDeprecatedSynchronousErrorHandling && !he.syncErrorThrowable ? this._subscribe(he) : this._trySubscribe(he)), me.v.useDeprecatedSynchronousErrorHandling && he.syncErrorThrowable && (he.syncErrorThrowable = !1, he.syncErrorThrown)) throw he.syncErrorValue;
                    return he
                }

                _trySubscribe(F) {
                    try {
                        return this._subscribe(F)
                    } catch (oe) {
                        me.v.useDeprecatedSynchronousErrorHandling && (F.syncErrorThrown = !0, F.syncErrorValue = oe), function D(M) {
                            for (; M;) {
                                const {closed: H, destination: F, isStopped: oe} = M;
                                if (H || oe) return !1;
                                M = F && F instanceof r.L ? F : null
                            }
                            return !0
                        }(F) ? F.error(oe) : console.warn(oe)
                    }
                }

                forEach(F, oe) {
                    return new (oe = X(oe))((ge, Ie) => {
                        let he;
                        he = this.subscribe(xe => {
                            try {
                                F(xe)
                            } catch (Ue) {
                                Ie(Ue), he && he.unsubscribe()
                            }
                        }, Ie, ge)
                    })
                }

                _subscribe(F) {
                    const {source: oe} = this;
                    return oe && oe.subscribe(F)
                }

                [W.L]() {
                    return this
                }

                pipe(...F) {
                    return 0 === F.length ? this : function ve(M) {
                        return 0 === M.length ? Q.y : 1 === M.length ? M[0] : function (F) {
                            return M.reduce((oe, ge) => ge(oe), F)
                        }
                    }(F)(this)
                }

                toPromise(F) {
                    return new (F = X(F))((oe, ge) => {
                        let Ie;
                        this.subscribe(he => Ie = he, he => ge(he), () => oe(Ie))
                    })
                }
            }

            return M.create = H => new M(H), M
        })();

        function X(M) {
            if (M || (M = me.v.Promise || Promise), !M) throw new Error("no Promise impl found");
            return M
        }
    }, 3292: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {c: () => ie});
        var r = R(2830), D = R(2782);
        const ie = {
            closed: !0, next(te) {
            }, error(te) {
                if (r.v.useDeprecatedSynchronousErrorHandling) throw te;
                (0, D.z)(te)
            }, complete() {
            }
        }
    }, 5529: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {xQ: () => Ne, Yc: () => Q});
        var r = R(2916), D = R(3489), ie = R(2654), te = R(5279);

        class j extends ie.w {
            constructor(ae, X) {
                super(), this.subject = ae, this.subscriber = X, this.closed = !1
            }

            unsubscribe() {
                if (this.closed) return;
                this.closed = !0;
                const ae = this.subject, X = ae.observers;
                if (this.subject = null, !X || 0 === X.length || ae.isStopped || ae.closed) return;
                const M = X.indexOf(this.subscriber);
                -1 !== M && X.splice(M, 1)
            }
        }

        var W = R(7668);

        class Q extends D.L {
            constructor(ae) {
                super(ae), this.destination = ae
            }
        }

        let Ne = (() => {
            class me extends r.y {
                constructor() {
                    super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null
                }

                [W.b]() {
                    return new Q(this)
                }

                lift(X) {
                    const M = new ve(this, this);
                    return M.operator = X, M
                }

                next(X) {
                    if (this.closed) throw new te.N;
                    if (!this.isStopped) {
                        const {observers: M} = this, H = M.length, F = M.slice();
                        for (let oe = 0; oe < H; oe++) F[oe].next(X)
                    }
                }

                error(X) {
                    if (this.closed) throw new te.N;
                    this.hasError = !0, this.thrownError = X, this.isStopped = !0;
                    const {observers: M} = this, H = M.length, F = M.slice();
                    for (let oe = 0; oe < H; oe++) F[oe].error(X);
                    this.observers.length = 0
                }

                complete() {
                    if (this.closed) throw new te.N;
                    this.isStopped = !0;
                    const {observers: X} = this, M = X.length, H = X.slice();
                    for (let F = 0; F < M; F++) H[F].complete();
                    this.observers.length = 0
                }

                unsubscribe() {
                    this.isStopped = !0, this.closed = !0, this.observers = null
                }

                _trySubscribe(X) {
                    if (this.closed) throw new te.N;
                    return super._trySubscribe(X)
                }

                _subscribe(X) {
                    if (this.closed) throw new te.N;
                    return this.hasError ? (X.error(this.thrownError), ie.w.EMPTY) : this.isStopped ? (X.complete(), ie.w.EMPTY) : (this.observers.push(X), new j(this, X))
                }

                asObservable() {
                    const X = new r.y;
                    return X.source = this, X
                }
            }

            return me.create = (ae, X) => new ve(ae, X), me
        })();

        class ve extends Ne {
            constructor(ae, X) {
                super(), this.destination = ae, this.source = X
            }

            next(ae) {
                const {destination: X} = this;
                X && X.next && X.next(ae)
            }

            error(ae) {
                const {destination: X} = this;
                X && X.error && this.destination.error(ae)
            }

            complete() {
                const {destination: ae} = this;
                ae && ae.complete && this.destination.complete()
            }

            _subscribe(ae) {
                const {source: X} = this;
                return X ? this.source.subscribe(ae) : ie.w.EMPTY
            }
        }
    }, 3489: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {L: () => Q});
        var r = R(7043), D = R(3292), ie = R(2654), te = R(7668), j = R(2830), W = R(2782);

        class Q extends ie.w {
            constructor(me, ae, X) {
                switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) {
                    case 0:
                        this.destination = D.c;
                        break;
                    case 1:
                        if (!me) {
                            this.destination = D.c;
                            break
                        }
                        if ("object" == typeof me) {
                            me instanceof Q ? (this.syncErrorThrowable = me.syncErrorThrowable, this.destination = me, me.add(this)) : (this.syncErrorThrowable = !0, this.destination = new Ne(this, me));
                            break
                        }
                    default:
                        this.syncErrorThrowable = !0, this.destination = new Ne(this, me, ae, X)
                }
            }

            [te.b]() {
                return this
            }

            static create(me, ae, X) {
                const M = new Q(me, ae, X);
                return M.syncErrorThrowable = !1, M
            }

            next(me) {
                this.isStopped || this._next(me)
            }

            error(me) {
                this.isStopped || (this.isStopped = !0, this._error(me))
            }

            complete() {
                this.isStopped || (this.isStopped = !0, this._complete())
            }

            unsubscribe() {
                this.closed || (this.isStopped = !0, super.unsubscribe())
            }

            _next(me) {
                this.destination.next(me)
            }

            _error(me) {
                this.destination.error(me), this.unsubscribe()
            }

            _complete() {
                this.destination.complete(), this.unsubscribe()
            }

            _unsubscribeAndRecycle() {
                const {_parentOrParents: me} = this;
                return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = me, this
            }
        }

        class Ne extends Q {
            constructor(me, ae, X, M) {
                super(), this._parentSubscriber = me;
                let H, F = this;
                (0, r.m)(ae) ? H = ae : ae && (H = ae.next, X = ae.error, M = ae.complete, ae !== D.c && (F = Object.create(ae), (0, r.m)(F.unsubscribe) && this.add(F.unsubscribe.bind(F)), F.unsubscribe = this.unsubscribe.bind(this))), this._context = F, this._next = H, this._error = X, this._complete = M
            }

            next(me) {
                if (!this.isStopped && this._next) {
                    const {_parentSubscriber: ae} = this;
                    j.v.useDeprecatedSynchronousErrorHandling && ae.syncErrorThrowable ? this.__tryOrSetError(ae, this._next, me) && this.unsubscribe() : this.__tryOrUnsub(this._next, me)
                }
            }

            error(me) {
                if (!this.isStopped) {
                    const {_parentSubscriber: ae} = this, {useDeprecatedSynchronousErrorHandling: X} = j.v;
                    if (this._error) X && ae.syncErrorThrowable ? (this.__tryOrSetError(ae, this._error, me), this.unsubscribe()) : (this.__tryOrUnsub(this._error, me), this.unsubscribe()); else if (ae.syncErrorThrowable) X ? (ae.syncErrorValue = me, ae.syncErrorThrown = !0) : (0, W.z)(me), this.unsubscribe(); else {
                        if (this.unsubscribe(), X) throw me;
                        (0, W.z)(me)
                    }
                }
            }

            complete() {
                if (!this.isStopped) {
                    const {_parentSubscriber: me} = this;
                    if (this._complete) {
                        const ae = () => this._complete.call(this._context);
                        j.v.useDeprecatedSynchronousErrorHandling && me.syncErrorThrowable ? (this.__tryOrSetError(me, ae), this.unsubscribe()) : (this.__tryOrUnsub(ae), this.unsubscribe())
                    } else this.unsubscribe()
                }
            }

            __tryOrUnsub(me, ae) {
                try {
                    me.call(this._context, ae)
                } catch (X) {
                    if (this.unsubscribe(), j.v.useDeprecatedSynchronousErrorHandling) throw X;
                    (0, W.z)(X)
                }
            }

            __tryOrSetError(me, ae, X) {
                if (!j.v.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    ae.call(this._context, X)
                } catch (M) {
                    return j.v.useDeprecatedSynchronousErrorHandling ? (me.syncErrorValue = M, me.syncErrorThrown = !0, !0) : ((0, W.z)(M), !0)
                }
                return !1
            }

            _unsubscribe() {
                const {_parentSubscriber: me} = this;
                this._context = null, this._parentSubscriber = null, me.unsubscribe()
            }
        }
    }, 2654: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {w: () => W});
        var r = R(6688), D = R(7830), ie = R(7043);
        const j = (() => {
            function Ne(ve) {
                return Error.call(this), this.message = ve ? `${ve.length} errors occurred during unsubscription:\n${ve.map((me, ae) => `${ae + 1}) ${me.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = ve, this
            }

            return Ne.prototype = Object.create(Error.prototype), Ne
        })();

        class W {
            constructor(ve) {
                this.closed = !1, this._parentOrParents = null, this._subscriptions = null, ve && (this._ctorUnsubscribe = !0, this._unsubscribe = ve)
            }

            unsubscribe() {
                let ve;
                if (this.closed) return;
                let {_parentOrParents: me, _ctorUnsubscribe: ae, _unsubscribe: X, _subscriptions: M} = this;
                if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, me instanceof W) me.remove(this); else if (null !== me) for (let H = 0; H < me.length; ++H) me[H].remove(this);
                if ((0, ie.m)(X)) {
                    ae && (this._unsubscribe = void 0);
                    try {
                        X.call(this)
                    } catch (H) {
                        ve = H instanceof j ? Q(H.errors) : [H]
                    }
                }
                if ((0, r.k)(M)) {
                    let H = -1, F = M.length;
                    for (; ++H < F;) {
                        const oe = M[H];
                        if ((0, D.K)(oe)) try {
                            oe.unsubscribe()
                        } catch (ge) {
                            ve = ve || [], ge instanceof j ? ve = ve.concat(Q(ge.errors)) : ve.push(ge)
                        }
                    }
                }
                if (ve) throw new j(ve)
            }

            add(ve) {
                let me = ve;
                if (!ve) return W.EMPTY;
                switch (typeof ve) {
                    case"function":
                        me = new W(ve);
                    case"object":
                        if (me === this || me.closed || "function" != typeof me.unsubscribe) return me;
                        if (this.closed) return me.unsubscribe(), me;
                        if (!(me instanceof W)) {
                            const M = me;
                            me = new W, me._subscriptions = [M]
                        }
                        break;
                    default:
                        throw new Error("unrecognized teardown " + ve + " added to Subscription.")
                }
                let {_parentOrParents: ae} = me;
                if (null === ae) me._parentOrParents = this; else if (ae instanceof W) {
                    if (ae === this) return me;
                    me._parentOrParents = [ae, this]
                } else {
                    if (-1 !== ae.indexOf(this)) return me;
                    ae.push(this)
                }
                const X = this._subscriptions;
                return null === X ? this._subscriptions = [me] : X.push(me), me
            }

            remove(ve) {
                const me = this._subscriptions;
                if (me) {
                    const ae = me.indexOf(ve);
                    -1 !== ae && me.splice(ae, 1)
                }
            }
        }

        var Ne;

        function Q(Ne) {
            return Ne.reduce((ve, me) => ve.concat(me instanceof j ? me.errors : me), [])
        }

        W.EMPTY = ((Ne = new W).closed = !0, Ne)
    }, 2830: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {v: () => D});
        let r = !1;
        const D = {
            Promise: void 0, set useDeprecatedSynchronousErrorHandling(ie) {
                if (ie) {
                    const te = new Error;
                    console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + te.stack)
                } else r && console.log("RxJS: Back to a better error behavior. Thank you. <3");
                r = ie
            }, get useDeprecatedSynchronousErrorHandling() {
                return r
            }
        }
    }, 1177: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {IY: () => te, Ds: () => W, ft: () => Ne});
        var r = R(3489), D = R(2916), ie = R(9249);

        class te extends r.L {
            constructor(me) {
                super(), this.parent = me
            }

            _next(me) {
                this.parent.notifyNext(me)
            }

            _error(me) {
                this.parent.notifyError(me), this.unsubscribe()
            }

            _complete() {
                this.parent.notifyComplete(), this.unsubscribe()
            }
        }

        class W extends r.L {
            notifyNext(me) {
                this.destination.next(me)
            }

            notifyError(me) {
                this.destination.error(me)
            }

            notifyComplete() {
                this.destination.complete()
            }
        }

        function Ne(ve, me) {
            if (me.closed) return;
            if (ve instanceof D.y) return ve.subscribe(me);
            let ae;
            try {
                ae = (0, ie.s)(ve)(me)
            } catch (X) {
                me.error(X)
            }
            return ae
        }
    }, 1762: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {c: () => j, N: () => W});
        var r = R(5529), D = R(2916), ie = R(2654), te = R(4327);

        class j extends D.y {
            constructor(ae, X) {
                super(), this.source = ae, this.subjectFactory = X, this._refCount = 0, this._isComplete = !1
            }

            _subscribe(ae) {
                return this.getSubject().subscribe(ae)
            }

            getSubject() {
                const ae = this._subject;
                return (!ae || ae.isStopped) && (this._subject = this.subjectFactory()), this._subject
            }

            connect() {
                let ae = this._connection;
                return ae || (this._isComplete = !1, ae = this._connection = new ie.w, ae.add(this.source.subscribe(new Q(this.getSubject(), this))), ae.closed && (this._connection = null, ae = ie.w.EMPTY)), ae
            }

            refCount() {
                return (0, te.x)()(this)
            }
        }

        const W = (() => {
            const me = j.prototype;
            return {
                operator: {value: null},
                _refCount: {value: 0, writable: !0},
                _subject: {value: null, writable: !0},
                _connection: {value: null, writable: !0},
                _subscribe: {value: me._subscribe},
                _isComplete: {value: me._isComplete, writable: !0},
                getSubject: {value: me.getSubject},
                connect: {value: me.connect},
                refCount: {value: me.refCount}
            }
        })();

        class Q extends r.Yc {
            constructor(ae, X) {
                super(ae), this.connectable = X
            }

            _error(ae) {
                this._unsubscribe(), super._error(ae)
            }

            _complete() {
                this.connectable._isComplete = !0, this._unsubscribe(), super._complete()
            }

            _unsubscribe() {
                const ae = this.connectable;
                if (ae) {
                    this.connectable = null;
                    const X = ae._connection;
                    ae._refCount = 0, ae._subject = null, ae._connection = null, X && X.unsubscribe()
                }
            }
        }
    }, 5254: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {D: () => F});
        var r = R(2916), D = R(9249), ie = R(2654), te = R(3821), Q = R(6454), Ne = R(5430), ae = R(8955), X = R(8515);

        function F(oe, ge) {
            return ge ? function H(oe, ge) {
                if (null != oe) {
                    if (function me(oe) {
                        return oe && "function" == typeof oe[te.L]
                    }(oe)) return function j(oe, ge) {
                        return new r.y(Ie => {
                            const he = new ie.w;
                            return he.add(ge.schedule(() => {
                                const xe = oe[te.L]();
                                he.add(xe.subscribe({
                                    next(Ue) {
                                        he.add(ge.schedule(() => Ie.next(Ue)))
                                    }, error(Ue) {
                                        he.add(ge.schedule(() => Ie.error(Ue)))
                                    }, complete() {
                                        he.add(ge.schedule(() => Ie.complete()))
                                    }
                                }))
                            })), he
                        })
                    }(oe, ge);
                    if ((0, ae.t)(oe)) return function W(oe, ge) {
                        return new r.y(Ie => {
                            const he = new ie.w;
                            return he.add(ge.schedule(() => oe.then(xe => {
                                he.add(ge.schedule(() => {
                                    Ie.next(xe), he.add(ge.schedule(() => Ie.complete()))
                                }))
                            }, xe => {
                                he.add(ge.schedule(() => Ie.error(xe)))
                            }))), he
                        })
                    }(oe, ge);
                    if ((0, X.z)(oe)) return (0, Q.r)(oe, ge);
                    if (function M(oe) {
                        return oe && "function" == typeof oe[Ne.hZ]
                    }(oe) || "string" == typeof oe) return function ve(oe, ge) {
                        if (!oe) throw new Error("Iterable cannot be null");
                        return new r.y(Ie => {
                            const he = new ie.w;
                            let xe;
                            return he.add(() => {
                                xe && "function" == typeof xe.return && xe.return()
                            }), he.add(ge.schedule(() => {
                                xe = oe[Ne.hZ](), he.add(ge.schedule(function () {
                                    if (Ie.closed) return;
                                    let Ue, it;
                                    try {
                                        const yt = xe.next();
                                        Ue = yt.value, it = yt.done
                                    } catch (yt) {
                                        return void Ie.error(yt)
                                    }
                                    it ? Ie.complete() : (Ie.next(Ue), this.schedule())
                                }))
                            })), he
                        })
                    }(oe, ge)
                }
                throw new TypeError((null !== oe && typeof oe || oe) + " is not observable")
            }(oe, ge) : oe instanceof r.y ? oe : new r.y((0, D.s)(oe))
        }
    }, 3009: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {n: () => te});
        var r = R(2916), D = R(3650), ie = R(6454);

        function te(j, W) {
            return W ? (0, ie.r)(j, W) : new r.y((0, D.V)(j))
        }
    }, 3753: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {R: () => W});
        var r = R(2916), D = R(6688), ie = R(7043), te = R(4850);

        function W(ae, X, M, H) {
            return (0, ie.m)(M) && (H = M, M = void 0), H ? W(ae, X, M).pipe((0, te.U)(F => (0, D.k)(F) ? H(...F) : H(F))) : new r.y(F => {
                Q(ae, X, function oe(ge) {
                    F.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : ge)
                }, F, M)
            })
        }

        function Q(ae, X, M, H, F) {
            let oe;
            if (function me(ae) {
                return ae && "function" == typeof ae.addEventListener && "function" == typeof ae.removeEventListener
            }(ae)) {
                const ge = ae;
                ae.addEventListener(X, M, F), oe = () => ge.removeEventListener(X, M, F)
            } else if (function ve(ae) {
                return ae && "function" == typeof ae.on && "function" == typeof ae.off
            }(ae)) {
                const ge = ae;
                ae.on(X, M), oe = () => ge.off(X, M)
            } else if (function Ne(ae) {
                return ae && "function" == typeof ae.addListener && "function" == typeof ae.removeListener
            }(ae)) {
                const ge = ae;
                ae.addListener(X, M), oe = () => ge.removeListener(X, M)
            } else {
                if (!ae || !ae.length) throw new TypeError("Invalid event target");
                for (let ge = 0, Ie = ae.length; ge < Ie; ge++) Q(ae[ge], X, M, H, F)
            }
            H.add(oe)
        }
    }, 6787: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {T: () => j});
        var r = R(2916), D = R(2866), ie = R(9146), te = R(3009);

        function j(...W) {
            let Q = Number.POSITIVE_INFINITY, Ne = null, ve = W[W.length - 1];
            return (0, D.K)(ve) ? (Ne = W.pop(), W.length > 1 && "number" == typeof W[W.length - 1] && (Q = W.pop())) : "number" == typeof ve && (Q = W.pop()), null === Ne && 1 === W.length && W[0] instanceof r.y ? W[0] : (0, ie.J)(Q)((0, te.n)(W, Ne))
        }
    }, 1086: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {of: () => te});
        var r = R(2866), D = R(3009), ie = R(6454);

        function te(...j) {
            let W = j[j.length - 1];
            return (0, r.K)(W) ? (j.pop(), (0, ie.r)(j, W)) : (0, D.n)(j)
        }
    }, 1406: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {b: () => D});
        var r = R(1709);

        function D(ie, te) {
            return (0, r.zg)(ie, te, 1)
        }
    }, 2198: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {h: () => D});
        var r = R(3489);

        function D(j, W) {
            return function (Ne) {
                return Ne.lift(new ie(j, W))
            }
        }

        class ie {
            constructor(W, Q) {
                this.predicate = W, this.thisArg = Q
            }

            call(W, Q) {
                return Q.subscribe(new te(W, this.predicate, this.thisArg))
            }
        }

        class te extends r.L {
            constructor(W, Q, Ne) {
                super(W), this.predicate = Q, this.thisArg = Ne, this.count = 0
            }

            _next(W) {
                let Q;
                try {
                    Q = this.predicate.call(this.thisArg, W, this.count++)
                } catch (Ne) {
                    return void this.destination.error(Ne)
                }
                Q && this.destination.next(W)
            }
        }
    }, 4850: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {U: () => D});
        var r = R(3489);

        function D(j, W) {
            return function (Ne) {
                if ("function" != typeof j) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return Ne.lift(new ie(j, W))
            }
        }

        class ie {
            constructor(W, Q) {
                this.project = W, this.thisArg = Q
            }

            call(W, Q) {
                return Q.subscribe(new te(W, this.project, this.thisArg))
            }
        }

        class te extends r.L {
            constructor(W, Q, Ne) {
                super(W), this.project = Q, this.count = 0, this.thisArg = Ne || this
            }

            _next(W) {
                let Q;
                try {
                    Q = this.project.call(this.thisArg, W, this.count++)
                } catch (Ne) {
                    return void this.destination.error(Ne)
                }
                this.destination.next(Q)
            }
        }
    }, 9146: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {J: () => ie});
        var r = R(1709), D = R(5379);

        function ie(te = Number.POSITIVE_INFINITY) {
            return (0, r.zg)(D.y, te)
        }
    }, 1709: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {zg: () => te});
        var r = R(4850), D = R(5254), ie = R(1177);

        function te(Ne, ve, me = Number.POSITIVE_INFINITY) {
            return "function" == typeof ve ? ae => ae.pipe(te((X, M) => (0, D.D)(Ne(X, M)).pipe((0, r.U)((H, F) => ve(X, H, M, F))), me)) : ("number" == typeof ve && (me = ve), ae => ae.lift(new j(Ne, me)))
        }

        class j {
            constructor(ve, me = Number.POSITIVE_INFINITY) {
                this.project = ve, this.concurrent = me
            }

            call(ve, me) {
                return me.subscribe(new W(ve, this.project, this.concurrent))
            }
        }

        class W extends ie.Ds {
            constructor(ve, me, ae = Number.POSITIVE_INFINITY) {
                super(ve), this.project = me, this.concurrent = ae, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0
            }

            _next(ve) {
                this.active < this.concurrent ? this._tryNext(ve) : this.buffer.push(ve)
            }

            _tryNext(ve) {
                let me;
                const ae = this.index++;
                try {
                    me = this.project(ve, ae)
                } catch (X) {
                    return void this.destination.error(X)
                }
                this.active++, this._innerSub(me)
            }

            _innerSub(ve) {
                const me = new ie.IY(this), ae = this.destination;
                ae.add(me);
                const X = (0, ie.ft)(ve, me);
                X !== me && ae.add(X)
            }

            _complete() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe()
            }

            notifyNext(ve) {
                this.destination.next(ve)
            }

            notifyComplete() {
                const ve = this.buffer;
                this.active--, ve.length > 0 ? this._next(ve.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete()
            }
        }
    }, 4327: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {x: () => D});
        var r = R(3489);

        function D() {
            return function (W) {
                return W.lift(new ie(W))
            }
        }

        class ie {
            constructor(W) {
                this.connectable = W
            }

            call(W, Q) {
                const {connectable: Ne} = this;
                Ne._refCount++;
                const ve = new te(W, Ne), me = Q.subscribe(ve);
                return ve.closed || (ve.connection = Ne.connect()), me
            }
        }

        class te extends r.L {
            constructor(W, Q) {
                super(W), this.connectable = Q
            }

            _unsubscribe() {
                const {connectable: W} = this;
                if (!W) return void (this.connection = null);
                this.connectable = null;
                const Q = W._refCount;
                if (Q <= 0) return void (this.connection = null);
                if (W._refCount = Q - 1, Q > 1) return void (this.connection = null);
                const {connection: Ne} = this, ve = W._connection;
                this.connection = null, ve && (!Ne || ve === Ne) && ve.unsubscribe()
            }
        }
    }, 7545: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {w: () => te});
        var r = R(4850), D = R(5254), ie = R(1177);

        function te(Q, Ne) {
            return "function" == typeof Ne ? ve => ve.pipe(te((me, ae) => (0, D.D)(Q(me, ae)).pipe((0, r.U)((X, M) => Ne(me, X, ae, M))))) : ve => ve.lift(new j(Q))
        }

        class j {
            constructor(Ne) {
                this.project = Ne
            }

            call(Ne, ve) {
                return ve.subscribe(new W(Ne, this.project))
            }
        }

        class W extends ie.Ds {
            constructor(Ne, ve) {
                super(Ne), this.project = ve, this.index = 0
            }

            _next(Ne) {
                let ve;
                const me = this.index++;
                try {
                    ve = this.project(Ne, me)
                } catch (ae) {
                    return void this.destination.error(ae)
                }
                this._innerSub(ve)
            }

            _innerSub(Ne) {
                const ve = this.innerSubscription;
                ve && ve.unsubscribe();
                const me = new ie.IY(this), ae = this.destination;
                ae.add(me), this.innerSubscription = (0, ie.ft)(Ne, me), this.innerSubscription !== me && ae.add(this.innerSubscription)
            }

            _complete() {
                const {innerSubscription: Ne} = this;
                (!Ne || Ne.closed) && super._complete(), this.unsubscribe()
            }

            _unsubscribe() {
                this.innerSubscription = void 0
            }

            notifyComplete() {
                this.innerSubscription = void 0, this.isStopped && super._complete()
            }

            notifyNext(Ne) {
                this.destination.next(Ne)
            }
        }
    }, 6454: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {r: () => ie});
        var r = R(2916), D = R(2654);

        function ie(te, j) {
            return new r.y(W => {
                const Q = new D.w;
                let Ne = 0;
                return Q.add(j.schedule(function () {
                    Ne !== te.length ? (W.next(te[Ne++]), W.closed || Q.add(this.schedule())) : W.complete()
                })), Q
            })
        }
    }, 5430: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {hZ: () => D});
        const D = function r() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
        }()
    }, 3821: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {L: () => r});
        const r = "function" == typeof Symbol && Symbol.observable || "@@observable"
    }, 7668: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {b: () => r});
        const r = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
    }, 5279: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {N: () => D});
        const D = (() => {
            function ie() {
                return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this
            }

            return ie.prototype = Object.create(Error.prototype), ie
        })()
    }, 2782: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            setTimeout(() => {
                throw D
            }, 0)
        }

        R.d(lt, {z: () => r})
    }, 5379: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            return D
        }

        R.d(lt, {y: () => r})
    }, 6688: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {k: () => r});
        const r = Array.isArray || (D => D && "number" == typeof D.length)
    }, 8515: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {z: () => r});
        const r = D => D && "number" == typeof D.length && "function" != typeof D
    }, 7043: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            return "function" == typeof D
        }

        R.d(lt, {m: () => r})
    }, 7830: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            return null !== D && "object" == typeof D
        }

        R.d(lt, {K: () => r})
    }, 8955: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            return !!D && "function" != typeof D.subscribe && "function" == typeof D.then
        }

        R.d(lt, {t: () => r})
    }, 2866: (Jt, lt, R) => {
        "use strict";

        function r(D) {
            return D && "function" == typeof D.schedule
        }

        R.d(lt, {K: () => r})
    }, 9249: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {s: () => ae});
        var r = R(3650), D = R(2782), te = R(5430), W = R(3821), Ne = R(8515), ve = R(8955), me = R(7830);
        const ae = X => {
            if (X && "function" == typeof X[W.L]) return (X => M => {
                const H = X[W.L]();
                if ("function" != typeof H.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return H.subscribe(M)
            })(X);
            if ((0, Ne.z)(X)) return (0, r.V)(X);
            if ((0, ve.t)(X)) return (X => M => (X.then(H => {
                M.closed || (M.next(H), M.complete())
            }, H => M.error(H)).then(null, D.z), M))(X);
            if (X && "function" == typeof X[te.hZ]) return (X => M => {
                const H = X[te.hZ]();
                for (; ;) {
                    let F;
                    try {
                        F = H.next()
                    } catch (oe) {
                        return M.error(oe), M
                    }
                    if (F.done) {
                        M.complete();
                        break
                    }
                    if (M.next(F.value), M.closed) break
                }
                return "function" == typeof H.return && M.add(() => {
                    H.return && H.return()
                }), M
            })(X);
            {
                const H = `You provided ${(0, me.K)(X) ? "an invalid object" : `'${X}'`} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`;
                throw new TypeError(H)
            }
        }
    }, 3650: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {V: () => r});
        const r = D => ie => {
            for (let te = 0, j = D.length; te < j && !ie.closed; te++) ie.next(D[te]);
            ie.complete()
        }
    }, 2708: function (Jt) {
        "use strict";
        !function (lt) {
            function r(X) {
                const M = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
                let H = 1779033703, F = 3144134277, oe = 1013904242, ge = 2773480762, Ie = 1359893119, he = 2600822924,
                    xe = 528734635, Ue = 1541459225;
                const it = new Uint32Array(64);

                function yt(I) {
                    let l = 0, f = I.length;
                    for (; f >= 64;) {
                        let ze, Je, q, Le, ut, g = H, v = F, w = oe, P = ge, B = Ie, O = he, E = xe, Z = Ue;
                        for (Je = 0; Je < 16; Je++) q = l + 4 * Je, it[Je] = (255 & I[q]) << 24 | (255 & I[q + 1]) << 16 | (255 & I[q + 2]) << 8 | 255 & I[q + 3];
                        for (Je = 16; Je < 64; Je++) ze = it[Je - 2], Le = (ze >>> 17 | ze << 15) ^ (ze >>> 19 | ze << 13) ^ ze >>> 10, ze = it[Je - 15], ut = (ze >>> 7 | ze << 25) ^ (ze >>> 18 | ze << 14) ^ ze >>> 3, it[Je] = (Le + it[Je - 7] | 0) + (ut + it[Je - 16] | 0) | 0;
                        for (Je = 0; Je < 64; Je++) Le = (((B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7)) + (B & O ^ ~B & E) | 0) + (Z + (M[Je] + it[Je] | 0) | 0) | 0, ut = ((g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10)) + (g & v ^ g & w ^ v & w) | 0, Z = E, E = O, O = B, B = P + Le | 0, P = w, w = v, v = g, g = Le + ut | 0;
                        H = H + g | 0, F = F + v | 0, oe = oe + w | 0, ge = ge + P | 0, Ie = Ie + B | 0, he = he + O | 0, xe = xe + E | 0, Ue = Ue + Z | 0, l += 64, f -= 64
                    }
                }

                yt(X);
                let Ce, $e = X.length % 64, rt = X.length / 536870912 | 0, Xe = X.length << 3, Ee = $e < 56 ? 56 : 120,
                    ce = X.slice(X.length - $e, X.length);
                for (ce.push(128), Ce = $e + 1; Ce < Ee; Ce++) ce.push(0);
                return ce.push(rt >>> 24 & 255), ce.push(rt >>> 16 & 255), ce.push(rt >>> 8 & 255), ce.push(rt >>> 0 & 255), ce.push(Xe >>> 24 & 255), ce.push(Xe >>> 16 & 255), ce.push(Xe >>> 8 & 255), ce.push(Xe >>> 0 & 255), yt(ce), [H >>> 24 & 255, H >>> 16 & 255, H >>> 8 & 255, H >>> 0 & 255, F >>> 24 & 255, F >>> 16 & 255, F >>> 8 & 255, F >>> 0 & 255, oe >>> 24 & 255, oe >>> 16 & 255, oe >>> 8 & 255, oe >>> 0 & 255, ge >>> 24 & 255, ge >>> 16 & 255, ge >>> 8 & 255, ge >>> 0 & 255, Ie >>> 24 & 255, Ie >>> 16 & 255, Ie >>> 8 & 255, Ie >>> 0 & 255, he >>> 24 & 255, he >>> 16 & 255, he >>> 8 & 255, he >>> 0 & 255, xe >>> 24 & 255, xe >>> 16 & 255, xe >>> 8 & 255, xe >>> 0 & 255, Ue >>> 24 & 255, Ue >>> 16 & 255, Ue >>> 8 & 255, Ue >>> 0 & 255]
            }

            function D(X, M, H) {
                X = X.length <= 64 ? X : r(X);
                const F = 64 + M.length + 4, oe = new Array(F), ge = new Array(64);
                let Ie, he = [];
                for (Ie = 0; Ie < 64; Ie++) oe[Ie] = 54;
                for (Ie = 0; Ie < X.length; Ie++) oe[Ie] ^= X[Ie];
                for (Ie = 0; Ie < M.length; Ie++) oe[64 + Ie] = M[Ie];
                for (Ie = F - 4; Ie < F; Ie++) oe[Ie] = 0;
                for (Ie = 0; Ie < 64; Ie++) ge[Ie] = 92;
                for (Ie = 0; Ie < X.length; Ie++) ge[Ie] ^= X[Ie];

                function xe() {
                    for (let Ue = F - 1; Ue >= F - 4; Ue--) {
                        if (oe[Ue]++, oe[Ue] <= 255) return;
                        oe[Ue] = 0
                    }
                }

                for (; H >= 32;) xe(), he = he.concat(r(ge.concat(r(oe)))), H -= 32;
                return H > 0 && (xe(), he = he.concat(r(ge.concat(r(oe))).slice(0, H))), he
            }

            function ie(X, M, H, F, oe) {
                let ge;
                for (Q(X, 16 * (2 * H - 1), oe, 0, 16), ge = 0; ge < 2 * H; ge++) W(X, 16 * ge, oe, 16), j(oe, F), Q(oe, 0, X, M + 16 * ge, 16);
                for (ge = 0; ge < H; ge++) Q(X, M + 2 * ge * 16, X, 16 * ge, 16);
                for (ge = 0; ge < H; ge++) Q(X, M + 16 * (2 * ge + 1), X, 16 * (ge + H), 16)
            }

            function te(X, M) {
                return X << M | X >>> 32 - M
            }

            function j(X, M) {
                Q(X, 0, M, 0, 16);
                for (let H = 8; H > 0; H -= 2) M[4] ^= te(M[0] + M[12], 7), M[8] ^= te(M[4] + M[0], 9), M[12] ^= te(M[8] + M[4], 13), M[0] ^= te(M[12] + M[8], 18), M[9] ^= te(M[5] + M[1], 7), M[13] ^= te(M[9] + M[5], 9), M[1] ^= te(M[13] + M[9], 13), M[5] ^= te(M[1] + M[13], 18), M[14] ^= te(M[10] + M[6], 7), M[2] ^= te(M[14] + M[10], 9), M[6] ^= te(M[2] + M[14], 13), M[10] ^= te(M[6] + M[2], 18), M[3] ^= te(M[15] + M[11], 7), M[7] ^= te(M[3] + M[15], 9), M[11] ^= te(M[7] + M[3], 13), M[15] ^= te(M[11] + M[7], 18), M[1] ^= te(M[0] + M[3], 7), M[2] ^= te(M[1] + M[0], 9), M[3] ^= te(M[2] + M[1], 13), M[0] ^= te(M[3] + M[2], 18), M[6] ^= te(M[5] + M[4], 7), M[7] ^= te(M[6] + M[5], 9), M[4] ^= te(M[7] + M[6], 13), M[5] ^= te(M[4] + M[7], 18), M[11] ^= te(M[10] + M[9], 7), M[8] ^= te(M[11] + M[10], 9), M[9] ^= te(M[8] + M[11], 13), M[10] ^= te(M[9] + M[8], 18), M[12] ^= te(M[15] + M[14], 7), M[13] ^= te(M[12] + M[15], 9), M[14] ^= te(M[13] + M[12], 13), M[15] ^= te(M[14] + M[13], 18);
                for (let H = 0; H < 16; ++H) X[H] += M[H]
            }

            function W(X, M, H, F) {
                for (let oe = 0; oe < F; oe++) H[oe] ^= X[M + oe]
            }

            function Q(X, M, H, F, oe) {
                for (; oe--;) H[F++] = X[M++]
            }

            function Ne(X) {
                if (!X || "number" != typeof X.length) return !1;
                for (let M = 0; M < X.length; M++) {
                    const H = X[M];
                    if ("number" != typeof H || H % 1 || H < 0 || H >= 256) return !1
                }
                return !0
            }

            function ve(X, M) {
                if ("number" != typeof X || X % 1) throw new Error("invalid " + M);
                return X
            }

            function me(X, M, H, F, oe, ge, Ie) {
                if (H = ve(H, "N"), F = ve(F, "r"), oe = ve(oe, "p"), ge = ve(ge, "dkLen"), 0 === H || 0 != (H & H - 1)) throw new Error("N must be power of 2");
                if (H > 2147483647 / 128 / F) throw new Error("N too large");
                if (F > 2147483647 / 128 / oe) throw new Error("r too large");
                if (!Ne(X)) throw new Error("password must be an array or buffer");
                if (X = Array.prototype.slice.call(X), !Ne(M)) throw new Error("salt must be an array or buffer");
                M = Array.prototype.slice.call(M);
                let he = D(X, M, 128 * oe * F);
                const xe = new Uint32Array(32 * oe * F);
                for (let B = 0; B < xe.length; B++) {
                    const O = 4 * B;
                    xe[B] = (255 & he[O + 3]) << 24 | (255 & he[O + 2]) << 16 | (255 & he[O + 1]) << 8 | (255 & he[O + 0]) << 0
                }
                const Ue = new Uint32Array(64 * F), it = new Uint32Array(32 * F * H), yt = 32 * F,
                    Ce = new Uint32Array(16), $e = new Uint32Array(16), rt = oe * H * 2;
                let f, g, Xe = 0, Ee = null, ce = !1, I = 0, l = 0;
                const v = Ie ? parseInt(1e3 / F) : 4294967295,
                    w = "undefined" != typeof setImmediate ? setImmediate : setTimeout, P = function () {
                        if (ce) return Ie(new Error("cancelled"), Xe / rt);
                        let B;
                        switch (I) {
                            case 0:
                                g = 32 * l * F, Q(xe, g, Ue, 0, yt), I = 1, f = 0;
                            case 1:
                                B = H - f, B > v && (B = v);
                                for (let E = 0; E < B; E++) Q(Ue, 0, it, (f + E) * yt, yt), ie(Ue, yt, F, Ce, $e);
                                if (f += B, Xe += B, Ie) {
                                    const E = parseInt(1e3 * Xe / rt);
                                    if (E !== Ee) {
                                        if (ce = Ie(null, Xe / rt), ce) break;
                                        Ee = E
                                    }
                                }
                                if (f < H) break;
                                f = 0, I = 2;
                            case 2:
                                B = H - f, B > v && (B = v);
                                for (let E = 0; E < B; E++) W(it, (Ue[16 * (2 * F - 1)] & H - 1) * yt, Ue, yt), ie(Ue, yt, F, Ce, $e);
                                if (f += B, Xe += B, Ie) {
                                    const E = parseInt(1e3 * Xe / rt);
                                    if (E !== Ee) {
                                        if (ce = Ie(null, Xe / rt), ce) break;
                                        Ee = E
                                    }
                                }
                                if (f < H) break;
                                if (Q(Ue, 0, xe, g, yt), l++, l < oe) {
                                    I = 0;
                                    break
                                }
                                he = [];
                                for (let E = 0; E < xe.length; E++) he.push(xe[E] >> 0 & 255), he.push(xe[E] >> 8 & 255), he.push(xe[E] >> 16 & 255), he.push(xe[E] >> 24 & 255);
                                const O = D(X, he, ge);
                                return Ie && Ie(null, 1, O), O
                        }
                        Ie && w(P)
                    };
                if (!Ie) for (; ;) {
                    const B = P();
                    if (null != B) return B
                }
                P()
            }

            Jt.exports = {
                scrypt: function (X, M, H, F, oe, ge, Ie) {
                    return new Promise(function (he, xe) {
                        let Ue = 0;
                        Ie && Ie(0), me(X, M, H, F, oe, ge, function (it, yt, Ce) {
                            if (it) xe(it); else if (Ce) Ie && 1 !== Ue && Ie(1), he(new Uint8Array(Ce)); else if (Ie && yt !== Ue) return Ue = yt, Ie(yt)
                        })
                    })
                }, syncScrypt: function (X, M, H, F, oe, ge) {
                    return new Uint8Array(me(X, M, H, F, oe, ge))
                }
            }
        }()
    }, 863: (Jt, lt, R) => {
        var r = {
            "./ion-accordion_2.entry.js": [9654, 8592, 9654],
            "./ion-action-sheet.entry.js": [3648, 8592, 3648],
            "./ion-alert.entry.js": [1118, 8592, 1118],
            "./ion-app_8.entry.js": [53, 8592, 3236],
            "./ion-avatar_3.entry.js": [4753, 4753],
            "./ion-back-button.entry.js": [2073, 8592, 2073],
            "./ion-backdrop.entry.js": [8939, 8939],
            "./ion-breadcrumb_2.entry.js": [7544, 8592, 7544],
            "./ion-button_2.entry.js": [5652, 5652],
            "./ion-card_5.entry.js": [388, 388],
            "./ion-checkbox.entry.js": [9922, 9922],
            "./ion-chip.entry.js": [657, 657],
            "./ion-col_3.entry.js": [9824, 9824],
            "./ion-datetime-button.entry.js": [9230, 4223, 9230],
            "./ion-datetime_3.entry.js": [4959, 4223, 8592, 4959],
            "./ion-fab_3.entry.js": [5836, 8592, 5836],
            "./ion-img.entry.js": [1033, 1033],
            "./ion-infinite-scroll_2.entry.js": [8034, 8592, 5817],
            "./ion-input.entry.js": [1217, 1217],
            "./ion-item-option_3.entry.js": [2933, 8592, 4651],
            "./ion-item_8.entry.js": [4711, 8592, 4711],
            "./ion-loading.entry.js": [9434, 8592, 9434],
            "./ion-menu_3.entry.js": [8136, 8592, 8136],
            "./ion-modal.entry.js": [2349, 8592, 2349],
            "./ion-nav_2.entry.js": [5349, 8592, 5349],
            "./ion-picker-column-internal.entry.js": [7602, 8592, 7602],
            "./ion-picker-internal.entry.js": [9016, 9016],
            "./ion-popover.entry.js": [3804, 8592, 3804],
            "./ion-progress-bar.entry.js": [4174, 4174],
            "./ion-radio_2.entry.js": [4432, 4432],
            "./ion-range.entry.js": [3545, 8592, 1709],
            "./ion-refresher_2.entry.js": [3326, 8592, 2175],
            "./ion-reorder_2.entry.js": [3583, 8592, 1186],
            "./ion-ripple-effect.entry.js": [9958, 9958],
            "./ion-route_4.entry.js": [4330, 4330],
            "./ion-searchbar.entry.js": [8628, 8592, 8628],
            "./ion-segment_2.entry.js": [9325, 8592, 9325],
            "./ion-select_3.entry.js": [2773, 2773],
            "./ion-slide_2.entry.js": [1650, 1650],
            "./ion-spinner.entry.js": [4908, 8592, 4908],
            "./ion-split-pane.entry.js": [9536, 9536],
            "./ion-tab-bar_2.entry.js": [438, 438],
            "./ion-tab_2.entry.js": [1536, 8592, 1536],
            "./ion-text.entry.js": [4376, 4376],
            "./ion-textarea.entry.js": [6560, 6560],
            "./ion-toast.entry.js": [6120, 8592, 6120],
            "./ion-toggle.entry.js": [5168, 8592, 5168],
            "./ion-virtual-scroll.entry.js": [2289, 2289]
        };

        function D(ie) {
            if (!R.o(r, ie)) return Promise.resolve().then(() => {
                var W = new Error("Cannot find module '" + ie + "'");
                throw W.code = "MODULE_NOT_FOUND", W
            });
            var te = r[ie], j = te[0];
            return Promise.all(te.slice(1).map(R.e)).then(() => R(j))
        }

        D.keys = () => Object.keys(r), D.id = 863, Jt.exports = D
    }, 655: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {ZT: () => D, gn: () => j, mG: () => Ne});
        var r = function (Ee, ce) {
            return (r = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (I, l) {
                I.__proto__ = l
            } || function (I, l) {
                for (var f in l) Object.prototype.hasOwnProperty.call(l, f) && (I[f] = l[f])
            })(Ee, ce)
        };

        function D(Ee, ce) {
            if ("function" != typeof ce && null !== ce) throw new TypeError("Class extends value " + String(ce) + " is not a constructor or null");

            function I() {
                this.constructor = Ee
            }

            r(Ee, ce), Ee.prototype = null === ce ? Object.create(ce) : (I.prototype = ce.prototype, new I)
        }

        function j(Ee, ce, I, l) {
            var v, f = arguments.length, g = f < 3 ? ce : null === l ? l = Object.getOwnPropertyDescriptor(ce, I) : l;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) g = Reflect.decorate(Ee, ce, I, l); else for (var w = Ee.length - 1; w >= 0; w--) (v = Ee[w]) && (g = (f < 3 ? v(g) : f > 3 ? v(ce, I, g) : v(ce, I)) || g);
            return f > 3 && g && Object.defineProperty(ce, I, g), g
        }

        function Ne(Ee, ce, I, l) {
            return new (I || (I = Promise))(function (g, v) {
                function w(O) {
                    try {
                        B(l.next(O))
                    } catch (E) {
                        v(E)
                    }
                }

                function P(O) {
                    try {
                        B(l.throw(O))
                    } catch (E) {
                        v(E)
                    }
                }

                function B(O) {
                    O.done ? g(O.value) : function f(g) {
                        return g instanceof I ? g : new I(function (v) {
                            v(g)
                        })
                    }(O.value).then(w, P)
                }

                B((l = l.apply(Ee, ce || [])).next())
            })
        }
    }, 6601: () => {
    }, 9808: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            mr: () => he,
            Ov: () => Ci,
            ez: () => ti,
            K0: () => Q,
            Do: () => Ue,
            V_: () => me,
            Ye: () => it,
            S$: () => ge,
            mk: () => rr,
            sg: () => $n,
            O5: () => Pe,
            PC: () => hn,
            RF: () => Ke,
            n9: () => at,
            ED: () => Ct,
            tP: () => Bn,
            b0: () => xe,
            lw: () => Ne,
            EM: () => zr,
            JF: () => _i,
            NF: () => ni,
            w_: () => W,
            bD: () => Hr,
            q: () => ie,
            Mx: () => Ir,
            HT: () => j
        });
        var r = R(6435);
        let D = null;

        function ie() {
            return D
        }

        function j(J) {
            D || (D = J)
        }

        class W {
        }

        const Q = new r.OlP("DocumentToken");
        let Ne = (() => {
            class J {
                historyGo(Y) {
                    throw new Error("Not implemented")
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)
            }, J.\u0275prov = r.Yz7({
                token: J, factory: function () {
                    return function ve() {
                        return (0, r.LFG)(ae)
                    }()
                }, providedIn: "platform"
            }), J
        })();
        const me = new r.OlP("Location Initialized");
        let ae = (() => {
            class J extends Ne {
                constructor(Y) {
                    super(), this._doc = Y, this._init()
                }

                _init() {
                    this.location = window.location, this._history = window.history
                }

                getBaseHrefFromDOM() {
                    return ie().getBaseHref(this._doc)
                }

                onPopState(Y) {
                    const Ve = ie().getGlobalEventTarget(this._doc, "window");
                    return Ve.addEventListener("popstate", Y, !1), () => Ve.removeEventListener("popstate", Y)
                }

                onHashChange(Y) {
                    const Ve = ie().getGlobalEventTarget(this._doc, "window");
                    return Ve.addEventListener("hashchange", Y, !1), () => Ve.removeEventListener("hashchange", Y)
                }

                get href() {
                    return this.location.href
                }

                get protocol() {
                    return this.location.protocol
                }

                get hostname() {
                    return this.location.hostname
                }

                get port() {
                    return this.location.port
                }

                get pathname() {
                    return this.location.pathname
                }

                get search() {
                    return this.location.search
                }

                get hash() {
                    return this.location.hash
                }

                set pathname(Y) {
                    this.location.pathname = Y
                }

                pushState(Y, Ve, mt) {
                    X() ? this._history.pushState(Y, Ve, mt) : this.location.hash = mt
                }

                replaceState(Y, Ve, mt) {
                    X() ? this._history.replaceState(Y, Ve, mt) : this.location.hash = mt
                }

                forward() {
                    this._history.forward()
                }

                back() {
                    this._history.back()
                }

                historyGo(Y = 0) {
                    this._history.go(Y)
                }

                getState() {
                    return this._history.state
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.LFG(Q))
            }, J.\u0275prov = r.Yz7({
                token: J, factory: function () {
                    return function M() {
                        return new ae((0, r.LFG)(Q))
                    }()
                }, providedIn: "platform"
            }), J
        })();

        function X() {
            return !!window.history.pushState
        }

        function H(J, be) {
            if (0 == J.length) return be;
            if (0 == be.length) return J;
            let Y = 0;
            return J.endsWith("/") && Y++, be.startsWith("/") && Y++, 2 == Y ? J + be.substring(1) : 1 == Y ? J + be : J + "/" + be
        }

        function F(J) {
            const be = J.match(/#|\?|$/), Y = be && be.index || J.length;
            return J.slice(0, Y - ("/" === J[Y - 1] ? 1 : 0)) + J.slice(Y)
        }

        function oe(J) {
            return J && "?" !== J[0] ? "?" + J : J
        }

        let ge = (() => {
            class J {
                historyGo(Y) {
                    throw new Error("Not implemented")
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)
            }, J.\u0275prov = r.Yz7({
                token: J, factory: function () {
                    return function Ie(J) {
                        const be = (0, r.LFG)(Q).location;
                        return new xe((0, r.LFG)(Ne), be && be.origin || "")
                    }()
                }, providedIn: "root"
            }), J
        })();
        const he = new r.OlP("appBaseHref");
        let xe = (() => {
            class J extends ge {
                constructor(Y, Ve) {
                    if (super(), this._platformLocation = Y, this._removeListenerFns = [], null == Ve && (Ve = this._platformLocation.getBaseHrefFromDOM()), null == Ve) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                    this._baseHref = Ve
                }

                ngOnDestroy() {
                    for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
                }

                onPopState(Y) {
                    this._removeListenerFns.push(this._platformLocation.onPopState(Y), this._platformLocation.onHashChange(Y))
                }

                getBaseHref() {
                    return this._baseHref
                }

                prepareExternalUrl(Y) {
                    return H(this._baseHref, Y)
                }

                path(Y = !1) {
                    const Ve = this._platformLocation.pathname + oe(this._platformLocation.search),
                        mt = this._platformLocation.hash;
                    return mt && Y ? `${Ve}${mt}` : Ve
                }

                pushState(Y, Ve, mt, Yt) {
                    const ln = this.prepareExternalUrl(mt + oe(Yt));
                    this._platformLocation.pushState(Y, Ve, ln)
                }

                replaceState(Y, Ve, mt, Yt) {
                    const ln = this.prepareExternalUrl(mt + oe(Yt));
                    this._platformLocation.replaceState(Y, Ve, ln)
                }

                forward() {
                    this._platformLocation.forward()
                }

                back() {
                    this._platformLocation.back()
                }

                historyGo(Y = 0) {
                    var Ve, mt;
                    null === (mt = (Ve = this._platformLocation).historyGo) || void 0 === mt || mt.call(Ve, Y)
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.LFG(Ne), r.LFG(he, 8))
            }, J.\u0275prov = r.Yz7({token: J, factory: J.\u0275fac}), J
        })(), Ue = (() => {
            class J extends ge {
                constructor(Y, Ve) {
                    super(), this._platformLocation = Y, this._baseHref = "", this._removeListenerFns = [], null != Ve && (this._baseHref = Ve)
                }

                ngOnDestroy() {
                    for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
                }

                onPopState(Y) {
                    this._removeListenerFns.push(this._platformLocation.onPopState(Y), this._platformLocation.onHashChange(Y))
                }

                getBaseHref() {
                    return this._baseHref
                }

                path(Y = !1) {
                    let Ve = this._platformLocation.hash;
                    return null == Ve && (Ve = "#"), Ve.length > 0 ? Ve.substring(1) : Ve
                }

                prepareExternalUrl(Y) {
                    const Ve = H(this._baseHref, Y);
                    return Ve.length > 0 ? "#" + Ve : Ve
                }

                pushState(Y, Ve, mt, Yt) {
                    let ln = this.prepareExternalUrl(mt + oe(Yt));
                    0 == ln.length && (ln = this._platformLocation.pathname), this._platformLocation.pushState(Y, Ve, ln)
                }

                replaceState(Y, Ve, mt, Yt) {
                    let ln = this.prepareExternalUrl(mt + oe(Yt));
                    0 == ln.length && (ln = this._platformLocation.pathname), this._platformLocation.replaceState(Y, Ve, ln)
                }

                forward() {
                    this._platformLocation.forward()
                }

                back() {
                    this._platformLocation.back()
                }

                historyGo(Y = 0) {
                    var Ve, mt;
                    null === (mt = (Ve = this._platformLocation).historyGo) || void 0 === mt || mt.call(Ve, Y)
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.LFG(Ne), r.LFG(he, 8))
            }, J.\u0275prov = r.Yz7({token: J, factory: J.\u0275fac}), J
        })(), it = (() => {
            class J {
                constructor(Y, Ve) {
                    this._subject = new r.vpe, this._urlChangeListeners = [], this._platformStrategy = Y;
                    const mt = this._platformStrategy.getBaseHref();
                    this._platformLocation = Ve, this._baseHref = F($e(mt)), this._platformStrategy.onPopState(Yt => {
                        this._subject.emit({url: this.path(!0), pop: !0, state: Yt.state, type: Yt.type})
                    })
                }

                path(Y = !1) {
                    return this.normalize(this._platformStrategy.path(Y))
                }

                getState() {
                    return this._platformLocation.getState()
                }

                isCurrentPathEqualTo(Y, Ve = "") {
                    return this.path() == this.normalize(Y + oe(Ve))
                }

                normalize(Y) {
                    return J.stripTrailingSlash(function Ce(J, be) {
                        return J && be.startsWith(J) ? be.substring(J.length) : be
                    }(this._baseHref, $e(Y)))
                }

                prepareExternalUrl(Y) {
                    return Y && "/" !== Y[0] && (Y = "/" + Y), this._platformStrategy.prepareExternalUrl(Y)
                }

                go(Y, Ve = "", mt = null) {
                    this._platformStrategy.pushState(mt, "", Y, Ve), this._notifyUrlChangeListeners(this.prepareExternalUrl(Y + oe(Ve)), mt)
                }

                replaceState(Y, Ve = "", mt = null) {
                    this._platformStrategy.replaceState(mt, "", Y, Ve), this._notifyUrlChangeListeners(this.prepareExternalUrl(Y + oe(Ve)), mt)
                }

                forward() {
                    this._platformStrategy.forward()
                }

                back() {
                    this._platformStrategy.back()
                }

                historyGo(Y = 0) {
                    var Ve, mt;
                    null === (mt = (Ve = this._platformStrategy).historyGo) || void 0 === mt || mt.call(Ve, Y)
                }

                onUrlChange(Y) {
                    this._urlChangeListeners.push(Y), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(Ve => {
                        this._notifyUrlChangeListeners(Ve.url, Ve.state)
                    }))
                }

                _notifyUrlChangeListeners(Y = "", Ve) {
                    this._urlChangeListeners.forEach(mt => mt(Y, Ve))
                }

                subscribe(Y, Ve, mt) {
                    return this._subject.subscribe({next: Y, error: Ve, complete: mt})
                }
            }

            return J.normalizeQueryParams = oe, J.joinWithSlash = H, J.stripTrailingSlash = F, J.\u0275fac = function (Y) {
                return new (Y || J)(r.LFG(ge), r.LFG(Ne))
            }, J.\u0275prov = r.Yz7({
                token: J, factory: function () {
                    return function yt() {
                        return new it((0, r.LFG)(ge), (0, r.LFG)(Ne))
                    }()
                }, providedIn: "root"
            }), J
        })();

        function $e(J) {
            return J.replace(/\/index.html$/, "")
        }

        function Ir(J, be) {
            be = encodeURIComponent(be);
            for (const Y of J.split(";")) {
                const Ve = Y.indexOf("="), [mt, Yt] = -1 == Ve ? [Y, ""] : [Y.slice(0, Ve), Y.slice(Ve + 1)];
                if (mt.trim() === be) return decodeURIComponent(Yt)
            }
            return null
        }

        let rr = (() => {
            class J {
                constructor(Y, Ve, mt, Yt) {
                    this._iterableDiffers = Y, this._keyValueDiffers = Ve, this._ngEl = mt, this._renderer = Yt, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null
                }

                set klass(Y) {
                    this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof Y ? Y.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass)
                }

                set ngClass(Y) {
                    this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof Y ? Y.split(/\s+/) : Y, this._rawClass && ((0, r.sIi)(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create())
                }

                ngDoCheck() {
                    if (this._iterableDiffer) {
                        const Y = this._iterableDiffer.diff(this._rawClass);
                        Y && this._applyIterableChanges(Y)
                    } else if (this._keyValueDiffer) {
                        const Y = this._keyValueDiffer.diff(this._rawClass);
                        Y && this._applyKeyValueChanges(Y)
                    }
                }

                _applyKeyValueChanges(Y) {
                    Y.forEachAddedItem(Ve => this._toggleClass(Ve.key, Ve.currentValue)), Y.forEachChangedItem(Ve => this._toggleClass(Ve.key, Ve.currentValue)), Y.forEachRemovedItem(Ve => {
                        Ve.previousValue && this._toggleClass(Ve.key, !1)
                    })
                }

                _applyIterableChanges(Y) {
                    Y.forEachAddedItem(Ve => {
                        if ("string" != typeof Ve.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${(0, r.AaK)(Ve.item)}`);
                        this._toggleClass(Ve.item, !0)
                    }), Y.forEachRemovedItem(Ve => this._toggleClass(Ve.item, !1))
                }

                _applyClasses(Y) {
                    Y && (Array.isArray(Y) || Y instanceof Set ? Y.forEach(Ve => this._toggleClass(Ve, !0)) : Object.keys(Y).forEach(Ve => this._toggleClass(Ve, !!Y[Ve])))
                }

                _removeClasses(Y) {
                    Y && (Array.isArray(Y) || Y instanceof Set ? Y.forEach(Ve => this._toggleClass(Ve, !1)) : Object.keys(Y).forEach(Ve => this._toggleClass(Ve, !1)))
                }

                _toggleClass(Y, Ve) {
                    (Y = Y.trim()) && Y.split(/\s+/g).forEach(mt => {
                        Ve ? this._renderer.addClass(this._ngEl.nativeElement, mt) : this._renderer.removeClass(this._ngEl.nativeElement, mt)
                    })
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.ZZ4), r.Y36(r.aQg), r.Y36(r.SBq), r.Y36(r.Qsj))
            }, J.\u0275dir = r.lG2({
                type: J,
                selectors: [["", "ngClass", ""]],
                inputs: {klass: ["class", "klass"], ngClass: "ngClass"}
            }), J
        })();

        class Vn {
            constructor(be, Y, Ve, mt) {
                this.$implicit = be, this.ngForOf = Y, this.index = Ve, this.count = mt
            }

            get first() {
                return 0 === this.index
            }

            get last() {
                return this.index === this.count - 1
            }

            get even() {
                return this.index % 2 == 0
            }

            get odd() {
                return !this.even
            }
        }

        let $n = (() => {
            class J {
                constructor(Y, Ve, mt) {
                    this._viewContainer = Y, this._template = Ve, this._differs = mt, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
                }

                set ngForOf(Y) {
                    this._ngForOf = Y, this._ngForOfDirty = !0
                }

                set ngForTrackBy(Y) {
                    this._trackByFn = Y
                }

                get ngForTrackBy() {
                    return this._trackByFn
                }

                set ngForTemplate(Y) {
                    Y && (this._template = Y)
                }

                ngDoCheck() {
                    if (this._ngForOfDirty) {
                        this._ngForOfDirty = !1;
                        const Y = this._ngForOf;
                        !this._differ && Y && (this._differ = this._differs.find(Y).create(this.ngForTrackBy))
                    }
                    if (this._differ) {
                        const Y = this._differ.diff(this._ngForOf);
                        Y && this._applyChanges(Y)
                    }
                }

                _applyChanges(Y) {
                    const Ve = this._viewContainer;
                    Y.forEachOperation((mt, Yt, ln) => {
                        if (null == mt.previousIndex) Ve.createEmbeddedView(this._template, new Vn(mt.item, this._ngForOf, -1, -1), null === ln ? void 0 : ln); else if (null == ln) Ve.remove(null === Yt ? void 0 : Yt); else if (null !== Yt) {
                            const vn = Ve.get(Yt);
                            Ve.move(vn, ln), Br(vn, mt)
                        }
                    });
                    for (let mt = 0, Yt = Ve.length; mt < Yt; mt++) {
                        const vn = Ve.get(mt).context;
                        vn.index = mt, vn.count = Yt, vn.ngForOf = this._ngForOf
                    }
                    Y.forEachIdentityChange(mt => {
                        Br(Ve.get(mt.currentIndex), mt)
                    })
                }

                static ngTemplateContextGuard(Y, Ve) {
                    return !0
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.s_b), r.Y36(r.Rgc), r.Y36(r.ZZ4))
            }, J.\u0275dir = r.lG2({
                type: J,
                selectors: [["", "ngFor", "", "ngForOf", ""]],
                inputs: {ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate"}
            }), J
        })();

        function Br(J, be) {
            J.context.$implicit = be.item
        }

        let Pe = (() => {
            class J {
                constructor(Y, Ve) {
                    this._viewContainer = Y, this._context = new We, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = Ve
                }

                set ngIf(Y) {
                    this._context.$implicit = this._context.ngIf = Y, this._updateView()
                }

                set ngIfThen(Y) {
                    Et("ngIfThen", Y), this._thenTemplateRef = Y, this._thenViewRef = null, this._updateView()
                }

                set ngIfElse(Y) {
                    Et("ngIfElse", Y), this._elseTemplateRef = Y, this._elseViewRef = null, this._updateView()
                }

                _updateView() {
                    this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
                }

                static ngTemplateContextGuard(Y, Ve) {
                    return !0
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.s_b), r.Y36(r.Rgc))
            }, J.\u0275dir = r.lG2({
                type: J,
                selectors: [["", "ngIf", ""]],
                inputs: {ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse"}
            }), J
        })();

        class We {
            constructor() {
                this.$implicit = null, this.ngIf = null
            }
        }

        function Et(J, be) {
            if (be && !be.createEmbeddedView) throw new Error(`${J} must be a TemplateRef, but received '${(0, r.AaK)(be)}'.`)
        }

        class Ot {
            constructor(be, Y) {
                this._viewContainerRef = be, this._templateRef = Y, this._created = !1
            }

            create() {
                this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef)
            }

            destroy() {
                this._created = !1, this._viewContainerRef.clear()
            }

            enforceState(be) {
                be && !this._created ? this.create() : !be && this._created && this.destroy()
            }
        }

        let Ke = (() => {
            class J {
                constructor() {
                    this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1
                }

                set ngSwitch(Y) {
                    this._ngSwitch = Y, 0 === this._caseCount && this._updateDefaultCases(!0)
                }

                _addCase() {
                    return this._caseCount++
                }

                _addDefault(Y) {
                    this._defaultViews || (this._defaultViews = []), this._defaultViews.push(Y)
                }

                _matchCase(Y) {
                    const Ve = Y == this._ngSwitch;
                    return this._lastCasesMatched = this._lastCasesMatched || Ve, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), Ve
                }

                _updateDefaultCases(Y) {
                    if (this._defaultViews && Y !== this._defaultUsed) {
                        this._defaultUsed = Y;
                        for (let Ve = 0; Ve < this._defaultViews.length; Ve++) this._defaultViews[Ve].enforceState(Y)
                    }
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)
            }, J.\u0275dir = r.lG2({type: J, selectors: [["", "ngSwitch", ""]], inputs: {ngSwitch: "ngSwitch"}}), J
        })(), at = (() => {
            class J {
                constructor(Y, Ve, mt) {
                    this.ngSwitch = mt, mt._addCase(), this._view = new Ot(Y, Ve)
                }

                ngDoCheck() {
                    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.s_b), r.Y36(r.Rgc), r.Y36(Ke, 9))
            }, J.\u0275dir = r.lG2({
                type: J,
                selectors: [["", "ngSwitchCase", ""]],
                inputs: {ngSwitchCase: "ngSwitchCase"}
            }), J
        })(), Ct = (() => {
            class J {
                constructor(Y, Ve, mt) {
                    mt._addDefault(new Ot(Y, Ve))
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.s_b), r.Y36(r.Rgc), r.Y36(Ke, 9))
            }, J.\u0275dir = r.lG2({type: J, selectors: [["", "ngSwitchDefault", ""]]}), J
        })(), hn = (() => {
            class J {
                constructor(Y, Ve, mt) {
                    this._ngEl = Y, this._differs = Ve, this._renderer = mt, this._ngStyle = null, this._differ = null
                }

                set ngStyle(Y) {
                    this._ngStyle = Y, !this._differ && Y && (this._differ = this._differs.find(Y).create())
                }

                ngDoCheck() {
                    if (this._differ) {
                        const Y = this._differ.diff(this._ngStyle);
                        Y && this._applyChanges(Y)
                    }
                }

                _setStyle(Y, Ve) {
                    const [mt, Yt] = Y.split(".");
                    null != (Ve = null != Ve && Yt ? `${Ve}${Yt}` : Ve) ? this._renderer.setStyle(this._ngEl.nativeElement, mt, Ve) : this._renderer.removeStyle(this._ngEl.nativeElement, mt)
                }

                _applyChanges(Y) {
                    Y.forEachRemovedItem(Ve => this._setStyle(Ve.key, null)), Y.forEachAddedItem(Ve => this._setStyle(Ve.key, Ve.currentValue)), Y.forEachChangedItem(Ve => this._setStyle(Ve.key, Ve.currentValue))
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.SBq), r.Y36(r.aQg), r.Y36(r.Qsj))
            }, J.\u0275dir = r.lG2({type: J, selectors: [["", "ngStyle", ""]], inputs: {ngStyle: "ngStyle"}}), J
        })(), Bn = (() => {
            class J {
                constructor(Y) {
                    this._viewContainerRef = Y, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null
                }

                ngOnChanges(Y) {
                    if (Y.ngTemplateOutlet) {
                        const Ve = this._viewContainerRef;
                        this._viewRef && Ve.remove(Ve.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? Ve.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null
                    } else this._viewRef && Y.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext)
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.s_b))
            }, J.\u0275dir = r.lG2({
                type: J,
                selectors: [["", "ngTemplateOutlet", ""]],
                inputs: {ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet"},
                features: [r.TTD]
            }), J
        })();

        class xr {
            createSubscription(be, Y) {
                return be.subscribe({
                    next: Y, error: Ve => {
                        throw Ve
                    }
                })
            }

            dispose(be) {
                be.unsubscribe()
            }

            onDestroy(be) {
                be.unsubscribe()
            }
        }

        class $r {
            createSubscription(be, Y) {
                return be.then(Y, Ve => {
                    throw Ve
                })
            }

            dispose(be) {
            }

            onDestroy(be) {
            }
        }

        const Nr = new $r, li = new xr;
        let Ci = (() => {
            class J {
                constructor(Y) {
                    this._ref = Y, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null
                }

                ngOnDestroy() {
                    this._subscription && this._dispose()
                }

                transform(Y) {
                    return this._obj ? Y !== this._obj ? (this._dispose(), this.transform(Y)) : this._latestValue : (Y && this._subscribe(Y), this._latestValue)
                }

                _subscribe(Y) {
                    this._obj = Y, this._strategy = this._selectStrategy(Y), this._subscription = this._strategy.createSubscription(Y, Ve => this._updateLatestValue(Y, Ve))
                }

                _selectStrategy(Y) {
                    if ((0, r.QGY)(Y)) return Nr;
                    if ((0, r.F4k)(Y)) return li;
                    throw function lr(J, be) {
                        return new r.vHH(2100, "")
                    }()
                }

                _dispose() {
                    this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null
                }

                _updateLatestValue(Y, Ve) {
                    Y === this._obj && (this._latestValue = Ve, this._ref.markForCheck())
                }
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)(r.Y36(r.sBO, 16))
            }, J.\u0275pipe = r.Yjl({name: "async", type: J, pure: !1}), J
        })(), ti = (() => {
            class J {
            }

            return J.\u0275fac = function (Y) {
                return new (Y || J)
            }, J.\u0275mod = r.oAB({type: J}), J.\u0275inj = r.cJS({}), J
        })();
        const Hr = "browser";

        function ni(J) {
            return J === Hr
        }

        let zr = (() => {
            class J {
            }

            return J.\u0275prov = (0, r.Yz7)({
                token: J,
                providedIn: "root",
                factory: () => new Wr((0, r.LFG)(Q), window)
            }), J
        })();

        class Wr {
            constructor(be, Y) {
                this.document = be, this.window = Y, this.offset = () => [0, 0]
            }

            setOffset(be) {
                this.offset = Array.isArray(be) ? () => be : be
            }

            getScrollPosition() {
                return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
            }

            scrollToPosition(be) {
                this.supportsScrolling() && this.window.scrollTo(be[0], be[1])
            }

            scrollToAnchor(be) {
                if (!this.supportsScrolling()) return;
                const Y = function Ti(J, be) {
                    const Y = J.getElementById(be) || J.getElementsByName(be)[0];
                    if (Y) return Y;
                    if ("function" == typeof J.createTreeWalker && J.body && (J.body.createShadowRoot || J.body.attachShadow)) {
                        const Ve = J.createTreeWalker(J.body, NodeFilter.SHOW_ELEMENT);
                        let mt = Ve.currentNode;
                        for (; mt;) {
                            const Yt = mt.shadowRoot;
                            if (Yt) {
                                const ln = Yt.getElementById(be) || Yt.querySelector(`[name="${be}"]`);
                                if (ln) return ln
                            }
                            mt = Ve.nextNode()
                        }
                    }
                    return null
                }(this.document, be);
                Y && (this.scrollToElement(Y), Y.focus())
            }

            setHistoryScrollRestoration(be) {
                if (this.supportScrollRestoration()) {
                    const Y = this.window.history;
                    Y && Y.scrollRestoration && (Y.scrollRestoration = be)
                }
            }

            scrollToElement(be) {
                const Y = be.getBoundingClientRect(), Ve = Y.left + this.window.pageXOffset,
                    mt = Y.top + this.window.pageYOffset, Yt = this.offset();
                this.window.scrollTo(Ve - Yt[0], mt - Yt[1])
            }

            supportScrollRestoration() {
                try {
                    if (!this.supportsScrolling()) return !1;
                    const be = kn(this.window.history) || kn(Object.getPrototypeOf(this.window.history));
                    return !(!be || !be.writable && !be.set)
                } catch (be) {
                    return !1
                }
            }

            supportsScrolling() {
                try {
                    return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
                } catch (be) {
                    return !1
                }
            }
        }

        function kn(J) {
            return Object.getOwnPropertyDescriptor(J, "scrollRestoration")
        }

        class _i {
        }
    }, 520: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {eN: () => f, JF: () => Nn, WM: () => me});
        var r = R(9808), D = R(6435), ie = R(1086), te = R(2916), j = R(1406), W = R(2198), Q = R(4850);

        class Ne {
        }

        class ve {
        }

        class me {
            constructor(U) {
                this.normalizedNames = new Map, this.lazyUpdate = null, U ? this.lazyInit = "string" == typeof U ? () => {
                    this.headers = new Map, U.split("\n").forEach(de => {
                        const Ze = de.indexOf(":");
                        if (Ze > 0) {
                            const Ge = de.slice(0, Ze), ye = Ge.toLowerCase(), Te = de.slice(Ze + 1).trim();
                            this.maybeSetNormalizedName(Ge, ye), this.headers.has(ye) ? this.headers.get(ye).push(Te) : this.headers.set(ye, [Te])
                        }
                    })
                } : () => {
                    this.headers = new Map, Object.keys(U).forEach(de => {
                        let Ze = U[de];
                        const Ge = de.toLowerCase();
                        "string" == typeof Ze && (Ze = [Ze]), Ze.length > 0 && (this.headers.set(Ge, Ze), this.maybeSetNormalizedName(de, Ge))
                    })
                } : this.headers = new Map
            }

            has(U) {
                return this.init(), this.headers.has(U.toLowerCase())
            }

            get(U) {
                this.init();
                const de = this.headers.get(U.toLowerCase());
                return de && de.length > 0 ? de[0] : null
            }

            keys() {
                return this.init(), Array.from(this.normalizedNames.values())
            }

            getAll(U) {
                return this.init(), this.headers.get(U.toLowerCase()) || null
            }

            append(U, de) {
                return this.clone({name: U, value: de, op: "a"})
            }

            set(U, de) {
                return this.clone({name: U, value: de, op: "s"})
            }

            delete(U, de) {
                return this.clone({name: U, value: de, op: "d"})
            }

            maybeSetNormalizedName(U, de) {
                this.normalizedNames.has(de) || this.normalizedNames.set(de, U)
            }

            init() {
                this.lazyInit && (this.lazyInit instanceof me ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(U => this.applyUpdate(U)), this.lazyUpdate = null))
            }

            copyFrom(U) {
                U.init(), Array.from(U.headers.keys()).forEach(de => {
                    this.headers.set(de, U.headers.get(de)), this.normalizedNames.set(de, U.normalizedNames.get(de))
                })
            }

            clone(U) {
                const de = new me;
                return de.lazyInit = this.lazyInit && this.lazyInit instanceof me ? this.lazyInit : this, de.lazyUpdate = (this.lazyUpdate || []).concat([U]), de
            }

            applyUpdate(U) {
                const de = U.name.toLowerCase();
                switch (U.op) {
                    case"a":
                    case"s":
                        let Ze = U.value;
                        if ("string" == typeof Ze && (Ze = [Ze]), 0 === Ze.length) return;
                        this.maybeSetNormalizedName(U.name, de);
                        const Ge = ("a" === U.op ? this.headers.get(de) : void 0) || [];
                        Ge.push(...Ze), this.headers.set(de, Ge);
                        break;
                    case"d":
                        const ye = U.value;
                        if (ye) {
                            let Te = this.headers.get(de);
                            if (!Te) return;
                            Te = Te.filter(Be => -1 === ye.indexOf(Be)), 0 === Te.length ? (this.headers.delete(de), this.normalizedNames.delete(de)) : this.headers.set(de, Te)
                        } else this.headers.delete(de), this.normalizedNames.delete(de)
                }
            }

            forEach(U) {
                this.init(), Array.from(this.normalizedNames.keys()).forEach(de => U(this.normalizedNames.get(de), this.headers.get(de)))
            }
        }

        class ae {
            encodeKey(U) {
                return F(U)
            }

            encodeValue(U) {
                return F(U)
            }

            decodeKey(U) {
                return decodeURIComponent(U)
            }

            decodeValue(U) {
                return decodeURIComponent(U)
            }
        }

        const M = /%(\d[a-f0-9])/gi,
            H = {40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "2B": "+", "3D": "=", "3F": "?", "2F": "/"};

        function F(ne) {
            return encodeURIComponent(ne).replace(M, (U, de) => {
                var Ze;
                return null !== (Ze = H[de]) && void 0 !== Ze ? Ze : U
            })
        }

        function oe(ne) {
            return `${ne}`
        }

        class ge {
            constructor(U = {}) {
                if (this.updates = null, this.cloneFrom = null, this.encoder = U.encoder || new ae, U.fromString) {
                    if (U.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                    this.map = function X(ne, U) {
                        const de = new Map;
                        return ne.length > 0 && ne.replace(/^\?/, "").split("&").forEach(Ge => {
                            const ye = Ge.indexOf("="), [Te, Be] = -1 == ye ? [U.decodeKey(Ge), ""] : [U.decodeKey(Ge.slice(0, ye)), U.decodeValue(Ge.slice(ye + 1))],
                                tt = de.get(Te) || [];
                            tt.push(Be), de.set(Te, tt)
                        }), de
                    }(U.fromString, this.encoder)
                } else U.fromObject ? (this.map = new Map, Object.keys(U.fromObject).forEach(de => {
                    const Ze = U.fromObject[de];
                    this.map.set(de, Array.isArray(Ze) ? Ze : [Ze])
                })) : this.map = null
            }

            has(U) {
                return this.init(), this.map.has(U)
            }

            get(U) {
                this.init();
                const de = this.map.get(U);
                return de ? de[0] : null
            }

            getAll(U) {
                return this.init(), this.map.get(U) || null
            }

            keys() {
                return this.init(), Array.from(this.map.keys())
            }

            append(U, de) {
                return this.clone({param: U, value: de, op: "a"})
            }

            appendAll(U) {
                const de = [];
                return Object.keys(U).forEach(Ze => {
                    const Ge = U[Ze];
                    Array.isArray(Ge) ? Ge.forEach(ye => {
                        de.push({param: Ze, value: ye, op: "a"})
                    }) : de.push({param: Ze, value: Ge, op: "a"})
                }), this.clone(de)
            }

            set(U, de) {
                return this.clone({param: U, value: de, op: "s"})
            }

            delete(U, de) {
                return this.clone({param: U, value: de, op: "d"})
            }

            toString() {
                return this.init(), this.keys().map(U => {
                    const de = this.encoder.encodeKey(U);
                    return this.map.get(U).map(Ze => de + "=" + this.encoder.encodeValue(Ze)).join("&")
                }).filter(U => "" !== U).join("&")
            }

            clone(U) {
                const de = new ge({encoder: this.encoder});
                return de.cloneFrom = this.cloneFrom || this, de.updates = (this.updates || []).concat(U), de
            }

            init() {
                null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(U => this.map.set(U, this.cloneFrom.map.get(U))), this.updates.forEach(U => {
                    switch (U.op) {
                        case"a":
                        case"s":
                            const de = ("a" === U.op ? this.map.get(U.param) : void 0) || [];
                            de.push(oe(U.value)), this.map.set(U.param, de);
                            break;
                        case"d":
                            if (void 0 === U.value) {
                                this.map.delete(U.param);
                                break
                            }
                        {
                            let Ze = this.map.get(U.param) || [];
                            const Ge = Ze.indexOf(oe(U.value));
                            -1 !== Ge && Ze.splice(Ge, 1), Ze.length > 0 ? this.map.set(U.param, Ze) : this.map.delete(U.param)
                        }
                    }
                }), this.cloneFrom = this.updates = null)
            }
        }

        class he {
            constructor() {
                this.map = new Map
            }

            set(U, de) {
                return this.map.set(U, de), this
            }

            get(U) {
                return this.map.has(U) || this.map.set(U, U.defaultValue()), this.map.get(U)
            }

            delete(U) {
                return this.map.delete(U), this
            }

            has(U) {
                return this.map.has(U)
            }

            keys() {
                return this.map.keys()
            }
        }

        function Ue(ne) {
            return "undefined" != typeof ArrayBuffer && ne instanceof ArrayBuffer
        }

        function it(ne) {
            return "undefined" != typeof Blob && ne instanceof Blob
        }

        function yt(ne) {
            return "undefined" != typeof FormData && ne instanceof FormData
        }

        class $e {
            constructor(U, de, Ze, Ge) {
                let ye;
                if (this.url = de, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = U.toUpperCase(), function xe(ne) {
                    switch (ne) {
                        case"DELETE":
                        case"GET":
                        case"HEAD":
                        case"OPTIONS":
                        case"JSONP":
                            return !1;
                        default:
                            return !0
                    }
                }(this.method) || Ge ? (this.body = void 0 !== Ze ? Ze : null, ye = Ge) : ye = Ze, ye && (this.reportProgress = !!ye.reportProgress, this.withCredentials = !!ye.withCredentials, ye.responseType && (this.responseType = ye.responseType), ye.headers && (this.headers = ye.headers), ye.context && (this.context = ye.context), ye.params && (this.params = ye.params)), this.headers || (this.headers = new me), this.context || (this.context = new he), this.params) {
                    const Te = this.params.toString();
                    if (0 === Te.length) this.urlWithParams = de; else {
                        const Be = de.indexOf("?");
                        this.urlWithParams = de + (-1 === Be ? "?" : Be < de.length - 1 ? "&" : "") + Te
                    }
                } else this.params = new ge, this.urlWithParams = de
            }

            serializeBody() {
                return null === this.body ? null : Ue(this.body) || it(this.body) || yt(this.body) || function Ce(ne) {
                    return "undefined" != typeof URLSearchParams && ne instanceof URLSearchParams
                }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof ge ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
            }

            detectContentTypeHeader() {
                return null === this.body || yt(this.body) ? null : it(this.body) ? this.body.type || null : Ue(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof ge ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null
            }

            clone(U = {}) {
                var de;
                const Ze = U.method || this.method, Ge = U.url || this.url, ye = U.responseType || this.responseType,
                    Te = void 0 !== U.body ? U.body : this.body,
                    Be = void 0 !== U.withCredentials ? U.withCredentials : this.withCredentials,
                    tt = void 0 !== U.reportProgress ? U.reportProgress : this.reportProgress;
                let Dt = U.headers || this.headers, Ft = U.params || this.params;
                const zt = null !== (de = U.context) && void 0 !== de ? de : this.context;
                return void 0 !== U.setHeaders && (Dt = Object.keys(U.setHeaders).reduce((dn, Bt) => dn.set(Bt, U.setHeaders[Bt]), Dt)), U.setParams && (Ft = Object.keys(U.setParams).reduce((dn, Bt) => dn.set(Bt, U.setParams[Bt]), Ft)), new $e(Ze, Ge, Te, {
                    params: Ft,
                    headers: Dt,
                    context: zt,
                    reportProgress: tt,
                    responseType: ye,
                    withCredentials: Be
                })
            }
        }

        var rt = (() => ((rt = rt || {})[rt.Sent = 0] = "Sent", rt[rt.UploadProgress = 1] = "UploadProgress", rt[rt.ResponseHeader = 2] = "ResponseHeader", rt[rt.DownloadProgress = 3] = "DownloadProgress", rt[rt.Response = 4] = "Response", rt[rt.User = 5] = "User", rt))();

        class Xe {
            constructor(U, de = 200, Ze = "OK") {
                this.headers = U.headers || new me, this.status = void 0 !== U.status ? U.status : de, this.statusText = U.statusText || Ze, this.url = U.url || null, this.ok = this.status >= 200 && this.status < 300
            }
        }

        class Ee extends Xe {
            constructor(U = {}) {
                super(U), this.type = rt.ResponseHeader
            }

            clone(U = {}) {
                return new Ee({
                    headers: U.headers || this.headers,
                    status: void 0 !== U.status ? U.status : this.status,
                    statusText: U.statusText || this.statusText,
                    url: U.url || this.url || void 0
                })
            }
        }

        class ce extends Xe {
            constructor(U = {}) {
                super(U), this.type = rt.Response, this.body = void 0 !== U.body ? U.body : null
            }

            clone(U = {}) {
                return new ce({
                    body: void 0 !== U.body ? U.body : this.body,
                    headers: U.headers || this.headers,
                    status: void 0 !== U.status ? U.status : this.status,
                    statusText: U.statusText || this.statusText,
                    url: U.url || this.url || void 0
                })
            }
        }

        class I extends Xe {
            constructor(U) {
                super(U, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${U.url || "(unknown url)"}` : `Http failure response for ${U.url || "(unknown url)"}: ${U.status} ${U.statusText}`, this.error = U.error || null
            }
        }

        function l(ne, U) {
            return {
                body: U,
                headers: ne.headers,
                context: ne.context,
                observe: ne.observe,
                params: ne.params,
                reportProgress: ne.reportProgress,
                responseType: ne.responseType,
                withCredentials: ne.withCredentials
            }
        }

        let f = (() => {
            class ne {
                constructor(de) {
                    this.handler = de
                }

                request(de, Ze, Ge = {}) {
                    let ye;
                    if (de instanceof $e) ye = de; else {
                        let tt, Dt;
                        tt = Ge.headers instanceof me ? Ge.headers : new me(Ge.headers), Ge.params && (Dt = Ge.params instanceof ge ? Ge.params : new ge({fromObject: Ge.params})), ye = new $e(de, Ze, void 0 !== Ge.body ? Ge.body : null, {
                            headers: tt,
                            context: Ge.context,
                            params: Dt,
                            reportProgress: Ge.reportProgress,
                            responseType: Ge.responseType || "json",
                            withCredentials: Ge.withCredentials
                        })
                    }
                    const Te = (0, ie.of)(ye).pipe((0, j.b)(tt => this.handler.handle(tt)));
                    if (de instanceof $e || "events" === Ge.observe) return Te;
                    const Be = Te.pipe((0, W.h)(tt => tt instanceof ce));
                    switch (Ge.observe || "body") {
                        case"body":
                            switch (ye.responseType) {
                                case"arraybuffer":
                                    return Be.pipe((0, Q.U)(tt => {
                                        if (null !== tt.body && !(tt.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                        return tt.body
                                    }));
                                case"blob":
                                    return Be.pipe((0, Q.U)(tt => {
                                        if (null !== tt.body && !(tt.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                        return tt.body
                                    }));
                                case"text":
                                    return Be.pipe((0, Q.U)(tt => {
                                        if (null !== tt.body && "string" != typeof tt.body) throw new Error("Response is not a string.");
                                        return tt.body
                                    }));
                                default:
                                    return Be.pipe((0, Q.U)(tt => tt.body))
                            }
                        case"response":
                            return Be;
                        default:
                            throw new Error(`Unreachable: unhandled observe type ${Ge.observe}}`)
                    }
                }

                delete(de, Ze = {}) {
                    return this.request("DELETE", de, Ze)
                }

                get(de, Ze = {}) {
                    return this.request("GET", de, Ze)
                }

                head(de, Ze = {}) {
                    return this.request("HEAD", de, Ze)
                }

                jsonp(de, Ze) {
                    return this.request("JSONP", de, {
                        params: (new ge).append(Ze, "JSONP_CALLBACK"),
                        observe: "body",
                        responseType: "json"
                    })
                }

                options(de, Ze = {}) {
                    return this.request("OPTIONS", de, Ze)
                }

                patch(de, Ze, Ge = {}) {
                    return this.request("PATCH", de, l(Ge, Ze))
                }

                post(de, Ze, Ge = {}) {
                    return this.request("POST", de, l(Ge, Ze))
                }

                put(de, Ze, Ge = {}) {
                    return this.request("PUT", de, l(Ge, Ze))
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)(D.LFG(Ne))
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })();

        class g {
            constructor(U, de) {
                this.next = U, this.interceptor = de
            }

            handle(U) {
                return this.interceptor.intercept(U, this.next)
            }
        }

        const v = new D.OlP("HTTP_INTERCEPTORS");
        let w = (() => {
            class ne {
                intercept(de, Ze) {
                    return Ze.handle(de)
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })();
        const Le = /^\)\]\}',?\n/;
        let Ye = (() => {
            class ne {
                constructor(de) {
                    this.xhrFactory = de
                }

                handle(de) {
                    if ("JSONP" === de.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");
                    return new te.y(Ze => {
                        const Ge = this.xhrFactory.build();
                        if (Ge.open(de.method, de.urlWithParams), de.withCredentials && (Ge.withCredentials = !0), de.headers.forEach((Bt, Ht) => Ge.setRequestHeader(Bt, Ht.join(","))), de.headers.has("Accept") || Ge.setRequestHeader("Accept", "application/json, text/plain, */*"), !de.headers.has("Content-Type")) {
                            const Bt = de.detectContentTypeHeader();
                            null !== Bt && Ge.setRequestHeader("Content-Type", Bt)
                        }
                        if (de.responseType) {
                            const Bt = de.responseType.toLowerCase();
                            Ge.responseType = "json" !== Bt ? Bt : "text"
                        }
                        const ye = de.serializeBody();
                        let Te = null;
                        const Be = () => {
                            if (null !== Te) return Te;
                            const Bt = Ge.statusText || "OK", Ht = new me(Ge.getAllResponseHeaders()),
                                bn = function ut(ne) {
                                    return "responseURL" in ne && ne.responseURL ? ne.responseURL : /^X-Request-URL:/m.test(ne.getAllResponseHeaders()) ? ne.getResponseHeader("X-Request-URL") : null
                                }(Ge) || de.url;
                            return Te = new Ee({headers: Ht, status: Ge.status, statusText: Bt, url: bn}), Te
                        }, tt = () => {
                            let {headers: Bt, status: Ht, statusText: bn, url: fn} = Be(), rn = null;
                            204 !== Ht && (rn = void 0 === Ge.response ? Ge.responseText : Ge.response), 0 === Ht && (Ht = rn ? 200 : 0);
                            let gn = Ht >= 200 && Ht < 300;
                            if ("json" === de.responseType && "string" == typeof rn) {
                                const Hn = rn;
                                rn = rn.replace(Le, "");
                                try {
                                    rn = "" !== rn ? JSON.parse(rn) : null
                                } catch (jn) {
                                    rn = Hn, gn && (gn = !1, rn = {error: jn, text: rn})
                                }
                            }
                            gn ? (Ze.next(new ce({
                                body: rn,
                                headers: Bt,
                                status: Ht,
                                statusText: bn,
                                url: fn || void 0
                            })), Ze.complete()) : Ze.error(new I({
                                error: rn,
                                headers: Bt,
                                status: Ht,
                                statusText: bn,
                                url: fn || void 0
                            }))
                        }, Dt = Bt => {
                            const {url: Ht} = Be(), bn = new I({
                                error: Bt,
                                status: Ge.status || 0,
                                statusText: Ge.statusText || "Unknown Error",
                                url: Ht || void 0
                            });
                            Ze.error(bn)
                        };
                        let Ft = !1;
                        const zt = Bt => {
                            Ft || (Ze.next(Be()), Ft = !0);
                            let Ht = {type: rt.DownloadProgress, loaded: Bt.loaded};
                            Bt.lengthComputable && (Ht.total = Bt.total), "text" === de.responseType && !!Ge.responseText && (Ht.partialText = Ge.responseText), Ze.next(Ht)
                        }, dn = Bt => {
                            let Ht = {type: rt.UploadProgress, loaded: Bt.loaded};
                            Bt.lengthComputable && (Ht.total = Bt.total), Ze.next(Ht)
                        };
                        return Ge.addEventListener("load", tt), Ge.addEventListener("error", Dt), Ge.addEventListener("timeout", Dt), Ge.addEventListener("abort", Dt), de.reportProgress && (Ge.addEventListener("progress", zt), null !== ye && Ge.upload && Ge.upload.addEventListener("progress", dn)), Ge.send(ye), Ze.next({type: rt.Sent}), () => {
                            Ge.removeEventListener("error", Dt), Ge.removeEventListener("abort", Dt), Ge.removeEventListener("load", tt), Ge.removeEventListener("timeout", Dt), de.reportProgress && (Ge.removeEventListener("progress", zt), null !== ye && Ge.upload && Ge.upload.removeEventListener("progress", dn)), Ge.readyState !== Ge.DONE && Ge.abort()
                        }
                    })
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)(D.LFG(r.JF))
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })();
        const Mt = new D.OlP("XSRF_COOKIE_NAME"), _t = new D.OlP("XSRF_HEADER_NAME");

        class Pt {
        }

        let Gt = (() => {
            class ne {
                constructor(de, Ze, Ge) {
                    this.doc = de, this.platform = Ze, this.cookieName = Ge, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0
                }

                getToken() {
                    if ("server" === this.platform) return null;
                    const de = this.doc.cookie || "";
                    return de !== this.lastCookieString && (this.parseCount++, this.lastToken = (0, r.Mx)(de, this.cookieName), this.lastCookieString = de), this.lastToken
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)(D.LFG(r.K0), D.LFG(D.Lbi), D.LFG(Mt))
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })(), yn = (() => {
            class ne {
                constructor(de, Ze) {
                    this.tokenService = de, this.headerName = Ze
                }

                intercept(de, Ze) {
                    const Ge = de.url.toLowerCase();
                    if ("GET" === de.method || "HEAD" === de.method || Ge.startsWith("http://") || Ge.startsWith("https://")) return Ze.handle(de);
                    const ye = this.tokenService.getToken();
                    return null !== ye && !de.headers.has(this.headerName) && (de = de.clone({headers: de.headers.set(this.headerName, ye)})), Ze.handle(de)
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)(D.LFG(Pt), D.LFG(_t))
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })(), Xt = (() => {
            class ne {
                constructor(de, Ze) {
                    this.backend = de, this.injector = Ze, this.chain = null
                }

                handle(de) {
                    if (null === this.chain) {
                        const Ze = this.injector.get(v, []);
                        this.chain = Ze.reduceRight((Ge, ye) => new g(Ge, ye), this.backend)
                    }
                    return this.chain.handle(de)
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)(D.LFG(ve), D.LFG(D.zs3))
            }, ne.\u0275prov = D.Yz7({token: ne, factory: ne.\u0275fac}), ne
        })(), wn = (() => {
            class ne {
                static disable() {
                    return {ngModule: ne, providers: [{provide: yn, useClass: w}]}
                }

                static withOptions(de = {}) {
                    return {
                        ngModule: ne,
                        providers: [de.cookieName ? {
                            provide: Mt,
                            useValue: de.cookieName
                        } : [], de.headerName ? {provide: _t, useValue: de.headerName} : []]
                    }
                }
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)
            }, ne.\u0275mod = D.oAB({type: ne}), ne.\u0275inj = D.cJS({
                providers: [yn, {
                    provide: v,
                    useExisting: yn,
                    multi: !0
                }, {provide: Pt, useClass: Gt}, {provide: Mt, useValue: "XSRF-TOKEN"}, {
                    provide: _t,
                    useValue: "X-XSRF-TOKEN"
                }]
            }), ne
        })(), Nn = (() => {
            class ne {
            }

            return ne.\u0275fac = function (de) {
                return new (de || ne)
            }, ne.\u0275mod = D.oAB({type: ne}), ne.\u0275inj = D.cJS({
                providers: [f, {
                    provide: Ne,
                    useClass: Xt
                }, Ye, {provide: ve, useExisting: Ye}],
                imports: [[wn.withOptions({cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN"})]]
            }), ne
        })()
    }, 6435: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            deG: () => ue,
            tb: () => E0,
            AFp: () => y0,
            ip1: () => v0,
            CZH: () => eu,
            hGG: () => q1,
            z2F: () => au,
            sBO: () => R1,
            Sil: () => p1,
            _Vd: () => Ja,
            EJc: () => f1,
            SBq: () => ra,
            qLn: () => Ta,
            vpe: () => ys,
            tBr: () => Ea,
            XFs: () => Me,
            OlP: () => L,
            zs3: () => es,
            ZZ4: () => hu,
            aQg: () => pu,
            soG: () => nu,
            YKP: () => Tp,
            h0i: () => _o,
            PXZ: () => D1,
            R0b: () => ss,
            FiY: () => Lo,
            Lbi: () => w0,
            g9A: () => x0,
            Qsj: () => ux,
            FYo: () => _p,
            JOm: () => ps,
            q3G: () => ii,
            tp0: () => Bo,
            Rgc: () => aa,
            dDg: () => D0,
            GfV: () => Cp,
            s_b: () => tl,
            ifc: () => Dt,
            eFA: () => M0,
            G48: () => O1,
            Gpc: () => oe,
            _c5: () => K1,
            VLi: () => _1,
            c2e: () => _0,
            zSh: () => ac,
            wAp: () => or,
            vHH: () => xe,
            EiD: () => Ku,
            mCW: () => Vo,
            qzn: () => Qs,
            JVY: () => Eg,
            pB0: () => Dg,
            eBb: () => Cg,
            L6k: () => _g,
            LAX: () => Sg,
            cg1: () => Pc,
            kL8: () => Wh,
            yhl: () => Vu,
            dqk: () => Ht,
            sIi: () => qo,
            CqO: () => Xf,
            QGY: () => Cc,
            F4k: () => qf,
            RDi: () => be,
            AaK: () => M,
            z3N: () => ws,
            qOj: () => fc,
            TTD: () => Hr,
            _Bn: () => xp,
            xp6: () => Ad,
            uIk: () => gc,
            Tol: () => bh,
            Gre: () => kh,
            ekj: () => Ac,
            Suo: () => Kp,
            Xpm: () => Xn,
            lG2: () => dt,
            Yz7: () => Ye,
            cJS: () => _t,
            oAB: () => ht,
            Yjl: () => wt,
            Y36: () => Zo,
            _UZ: () => Ec,
            GkF: () => _c,
            BQk: () => za,
            ynx: () => Ha,
            qZA: () => Ua,
            TgZ: () => Va,
            EpF: () => Kf,
            n5z: () => pa,
            LFG: () => bi,
            $8M: () => Vs,
            $Z: () => Wf,
            NdJ: () => Sc,
            CRH: () => qp,
            oxw: () => eh,
            ALo: () => $p,
            lcZ: () => Vp,
            Hsn: () => nh,
            F$t: () => th,
            Q6J: () => xc,
            s9C: () => Tc,
            MGl: () => Ga,
            DdM: () => Pp,
            VKq: () => Op,
            kEZ: () => Rp,
            iGM: () => Yp,
            MAs: () => Ff,
            CHM: () => mr,
            oJD: () => qu,
            LSH: () => El,
            Akn: () => ns,
            YNc: () => kf,
            W1O: () => Qp,
            _uU: () => Dh,
            Oqu: () => Ic,
            hij: () => Ya,
            Gf: () => Wp
        });
        var r = R(5529), D = R(2654), ie = R(2916), te = R(6787), j = R(1762);

        class Q {
            constructor(t, n) {
                this.subjectFactory = t, this.selector = n
            }

            call(t, n) {
                const {selector: i} = this, a = this.subjectFactory(), c = i(a).subscribe(t);
                return c.add(n.subscribe(a)), c
            }
        }

        var Ne = R(4327);

        function ve() {
            return new r.xQ
        }

        function ae(e) {
            for (let t in e) if (e[t] === ae) return t;
            throw Error("Could not find renamed property on target object.")
        }

        function X(e, t) {
            for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n])
        }

        function M(e) {
            if ("string" == typeof e) return e;
            if (Array.isArray(e)) return "[" + e.map(M).join(", ") + "]";
            if (null == e) return "" + e;
            if (e.overriddenName) return `${e.overriddenName}`;
            if (e.name) return `${e.name}`;
            const t = e.toString();
            if (null == t) return "" + t;
            const n = t.indexOf("\n");
            return -1 === n ? t : t.substring(0, n)
        }

        function H(e, t) {
            return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t
        }

        const F = ae({__forward_ref__: ae});

        function oe(e) {
            return e.__forward_ref__ = oe, e.toString = function () {
                return M(this())
            }, e
        }

        function ge(e) {
            return Ie(e) ? e() : e
        }

        function Ie(e) {
            return "function" == typeof e && e.hasOwnProperty(F) && e.__forward_ref__ === oe
        }

        class xe extends Error {
            constructor(t, n) {
                super(function Ue(e, t) {
                    return `NG0${Math.abs(e)}${t ? ": " + t : ""}`
                }(t, n)), this.code = t
            }
        }

        function it(e) {
            return "string" == typeof e ? e : null == e ? "" : String(e)
        }

        function yt(e) {
            return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : it(e)
        }

        function Xe(e, t) {
            const n = t ? ` in ${t}` : "";
            throw new xe(-201, `No provider for ${yt(e)} found${n}`)
        }

        function ze(e, t) {
            null == e && function Je(e, t, n, i) {
                throw new Error(`ASSERTION ERROR: ${e}` + (null == i ? "" : ` [Expected=> ${n} ${i} ${t} <=Actual]`))
            }(t, e, null, "!=")
        }

        function Ye(e) {
            return {token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0}
        }

        function _t(e) {
            return {providers: e.providers || [], imports: e.imports || []}
        }

        function Pt(e) {
            return Gt(e, Fn) || Gt(e, Nn)
        }

        function Gt(e, t) {
            return e.hasOwnProperty(t) ? e[t] : null
        }

        function xn(e) {
            return e && (e.hasOwnProperty(wn) || e.hasOwnProperty(On)) ? e[wn] : null
        }

        const Fn = ae({\u0275prov: ae}), wn = ae({\u0275inj: ae}), Nn = ae({ngInjectableDef: ae}),
            On = ae({ngInjectorDef: ae});
        var Me = (() => ((Me = Me || {})[Me.Default = 0] = "Default", Me[Me.Host = 1] = "Host", Me[Me.Self = 2] = "Self", Me[Me.SkipSelf = 4] = "SkipSelf", Me[Me.Optional = 8] = "Optional", Me))();
        let ne;

        function de(e) {
            const t = ne;
            return ne = e, t
        }

        function Ze(e, t, n) {
            const i = Pt(e);
            return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : n & Me.Optional ? null : void 0 !== t ? t : void Xe(M(e), "Injector")
        }

        function ye(e) {
            return {toString: e}.toString()
        }

        var Te = (() => ((Te = Te || {})[Te.OnPush = 0] = "OnPush", Te[Te.Default = 1] = "Default", Te))(),
            Dt = (() => {
                return (e = Dt || (Dt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Dt;
                var e
            })();
        const Ft = "undefined" != typeof globalThis && globalThis, zt = "undefined" != typeof window && window,
            dn = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
            Ht = Ft || "undefined" != typeof global && global || zt || dn, rn = {}, gn = [], Hn = ae({\u0275cmp: ae}),
            jn = ae({\u0275dir: ae}), fr = ae({\u0275pipe: ae}), qn = ae({\u0275mod: ae}), Yn = ae({\u0275fac: ae}),
            Qn = ae({__NG_ELEMENT_ID__: ae});
        let Wn = 0;

        function Xn(e) {
            return ye(() => {
                const n = {}, i = {
                    type: e.type,
                    providersResolver: null,
                    decls: e.decls,
                    vars: e.vars,
                    factory: null,
                    template: e.template || null,
                    consts: e.consts || null,
                    ngContentSelectors: e.ngContentSelectors,
                    hostBindings: e.hostBindings || null,
                    hostVars: e.hostVars || 0,
                    hostAttrs: e.hostAttrs || null,
                    contentQueries: e.contentQueries || null,
                    declaredInputs: n,
                    inputs: null,
                    outputs: null,
                    exportAs: e.exportAs || null,
                    onPush: e.changeDetection === Te.OnPush,
                    directiveDefs: null,
                    pipeDefs: null,
                    selectors: e.selectors || gn,
                    viewQuery: e.viewQuery || null,
                    features: e.features || null,
                    data: e.data || {},
                    encapsulation: e.encapsulation || Dt.Emulated,
                    id: "c",
                    styles: e.styles || gn,
                    _: null,
                    setInput: null,
                    schemas: e.schemas || null,
                    tView: null
                }, a = e.directives, c = e.features, b = e.pipes;
                return i.id += Wn++, i.inputs = gt(e.inputs, n), i.outputs = gt(e.outputs), c && c.forEach(S => S(i)), i.directiveDefs = a ? () => ("function" == typeof a ? a() : a).map(It) : null, i.pipeDefs = b ? () => ("function" == typeof b ? b() : b).map(vt) : null, i
            })
        }

        function It(e) {
            return Ut(e) || function Qt(e) {
                return e[jn] || null
            }(e)
        }

        function vt(e) {
            return function sn(e) {
                return e[fr] || null
            }(e)
        }

        const Qe = {};

        function ht(e) {
            return ye(() => {
                const t = {
                    type: e.type,
                    bootstrap: e.bootstrap || gn,
                    declarations: e.declarations || gn,
                    imports: e.imports || gn,
                    exports: e.exports || gn,
                    transitiveCompileScopes: null,
                    schemas: e.schemas || null,
                    id: e.id || null
                };
                return null != e.id && (Qe[e.id] = e.type), t
            })
        }

        function gt(e, t) {
            if (null == e) return rn;
            const n = {};
            for (const i in e) if (e.hasOwnProperty(i)) {
                let a = e[i], c = a;
                Array.isArray(a) && (c = a[1], a = a[0]), n[a] = i, t && (t[a] = c)
            }
            return n
        }

        const dt = Xn;

        function wt(e) {
            return {
                type: e.type,
                name: e.name,
                factory: null,
                pure: !1 !== e.pure,
                onDestroy: e.type.prototype.ngOnDestroy || null
            }
        }

        function Ut(e) {
            return e[Hn] || null
        }

        function un(e, t) {
            const n = e[qn] || null;
            if (!n && !0 === t) throw new Error(`Type ${M(e)} does not have '\u0275mod' property.`);
            return n
        }

        function Zt(e) {
            return Array.isArray(e) && "object" == typeof e[1]
        }

        function hn(e) {
            return Array.isArray(e) && !0 === e[1]
        }

        function Bn(e) {
            return 0 != (8 & e.flags)
        }

        function Zn(e) {
            return 2 == (2 & e.flags)
        }

        function lr(e) {
            return 1 == (1 & e.flags)
        }

        function xr(e) {
            return null !== e.template
        }

        function $r(e) {
            return 0 != (512 & e[2])
        }

        function Xr(e, t) {
            return e.hasOwnProperty(Yn) ? e[Yn] : null
        }

        class ti {
            constructor(t, n, i) {
                this.previousValue = t, this.currentValue = n, this.firstChange = i
            }

            isFirstChange() {
                return this.firstChange
            }
        }

        function Hr() {
            return si
        }

        function si(e) {
            return e.type.prototype.ngOnChanges && (e.setInput = Di), vi
        }

        function vi() {
            const e = oi(this), t = null == e ? void 0 : e.current;
            if (t) {
                const n = e.previous;
                if (n === rn) e.previous = t; else for (let i in t) n[i] = t[i];
                e.current = null, this.ngOnChanges(t)
            }
        }

        function Di(e, t, n, i) {
            const a = oi(e) || function Ei(e, t) {
                    return e[ni] = t
                }(e, {previous: rn, current: null}), c = a.current || (a.current = {}), b = a.previous,
                S = this.declaredInputs[n], k = b[S];
            c[S] = new ti(k && k.currentValue, t, b === rn), e[i] = t
        }

        Hr.ngInherit = !0;
        const ni = "__ngSimpleChanges__";

        function oi(e) {
            return e[ni] || null
        }

        let J;

        function be(e) {
            J = e
        }

        function Y() {
            return void 0 !== J ? J : "undefined" != typeof document ? document : void 0
        }

        function mt(e) {
            return !!e.listen
        }

        const Yt = {createRenderer: (e, t) => Y()};

        function vn(e) {
            for (; Array.isArray(e);) e = e[0];
            return e
        }

        function hr(e, t) {
            return vn(t[e])
        }

        function ir(e, t) {
            return vn(t[e.index])
        }

        function yr(e, t) {
            return e.data[t]
        }

        function Ar(e, t) {
            return e[t]
        }

        function Or(e, t) {
            const n = t[e];
            return Zt(n) ? n : n[0]
        }

        function Pr(e) {
            return 4 == (4 & e[2])
        }

        function Gr(e) {
            return 128 == (128 & e[2])
        }

        function re(e, t) {
            return null == t ? null : e[t]
        }

        function z(e) {
            e[18] = 0
        }

        function V(e, t) {
            e[5] += t;
            let n = e, i = e[3];
            for (; null !== i && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);) i[5] += t, n = i, i = i[3]
        }

        const _e = {lFrame: bt(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1};

        function Re() {
            return _e.bindingsEnabled
        }

        function Lt() {
            return _e.lFrame.lView
        }

        function In() {
            return _e.lFrame.tView
        }

        function mr(e) {
            return _e.lFrame.contextLView = e, e[8]
        }

        function dr() {
            let e = Mr();
            for (; null !== e && 64 === e.type;) e = e.parent;
            return e
        }

        function Mr() {
            return _e.lFrame.currentTNode
        }

        function Kr(e, t) {
            const n = _e.lFrame;
            n.currentTNode = e, n.isParent = t
        }

        function Zr() {
            return _e.lFrame.isParent
        }

        function Ai() {
            _e.lFrame.isParent = !1
        }

        function p() {
            return _e.isInCheckNoChangesMode
        }

        function s(e) {
            _e.isInCheckNoChangesMode = e
        }

        function _() {
            const e = _e.lFrame;
            let t = e.bindingRootIndex;
            return -1 === t && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t
        }

        function le() {
            return _e.lFrame.bindingIndex++
        }

        function De(e) {
            const t = _e.lFrame, n = t.bindingIndex;
            return t.bindingIndex = t.bindingIndex + e, n
        }

        function je(e, t) {
            const n = _e.lFrame;
            n.bindingIndex = n.bindingRootIndex = e, Ae(t)
        }

        function Ae(e) {
            _e.lFrame.currentDirectiveIndex = e
        }

        function nt() {
            return _e.lFrame.currentQueryIndex
        }

        function pt(e) {
            _e.lFrame.currentQueryIndex = e
        }

        function Tt(e) {
            const t = e[1];
            return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null
        }

        function qe(e, t, n) {
            if (n & Me.SkipSelf) {
                let a = t, c = e;
                for (; !(a = a.parent, null !== a || n & Me.Host || (a = Tt(c), null === a || (c = c[15], 10 & a.type)));) ;
                if (null === a) return !1;
                t = a, e = c
            }
            const i = _e.lFrame = Nt();
            return i.currentTNode = t, i.lView = e, !0
        }

        function ot(e) {
            const t = Nt(), n = e[1];
            _e.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1
        }

        function Nt() {
            const e = _e.lFrame, t = null === e ? null : e.child;
            return null === t ? bt(e) : t
        }

        function bt(e) {
            const t = {
                currentTNode: null,
                isParent: !0,
                lView: null,
                tView: null,
                selectedIndex: -1,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentDirectiveIndex: -1,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent: e,
                child: null,
                inI18n: !1
            };
            return null !== e && (e.child = t), t
        }

        function Rt() {
            const e = _e.lFrame;
            return _e.lFrame = e.parent, e.currentTNode = null, e.lView = null, e
        }

        const An = Rt;

        function on() {
            const e = Rt();
            e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0
        }

        function o() {
            return _e.lFrame.selectedIndex
        }

        function u(e) {
            _e.lFrame.selectedIndex = e
        }

        function d() {
            const e = _e.lFrame;
            return yr(e.tView, e.selectedIndex)
        }

        function Vt(e, t) {
            for (let n = t.directiveStart, i = t.directiveEnd; n < i; n++) {
                const c = e.data[n].type.prototype, {
                    ngAfterContentInit: b,
                    ngAfterContentChecked: S,
                    ngAfterViewInit: k,
                    ngAfterViewChecked: pe,
                    ngOnDestroy: Se
                } = c;
                b && (e.contentHooks || (e.contentHooks = [])).push(-n, b), S && ((e.contentHooks || (e.contentHooks = [])).push(n, S), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, S)), k && (e.viewHooks || (e.viewHooks = [])).push(-n, k), pe && ((e.viewHooks || (e.viewHooks = [])).push(n, pe), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, pe)), null != Se && (e.destroyHooks || (e.destroyHooks = [])).push(n, Se)
            }
        }

        function Wt(e, t, n) {
            er(e, t, 3, n)
        }

        function pn(e, t, n, i) {
            (3 & e[2]) === n && er(e, t, n, i)
        }

        function Ln(e, t) {
            let n = e[2];
            (3 & n) === t && (n &= 2047, n += 1, e[2] = n)
        }

        function er(e, t, n, i) {
            const c = null != i ? i : -1, b = t.length - 1;
            let S = 0;
            for (let k = void 0 !== i ? 65535 & e[18] : 0; k < b; k++) if ("number" == typeof t[k + 1]) {
                if (S = t[k], null != i && S >= i) break
            } else t[k] < 0 && (e[18] += 65536), (S < c || -1 == c) && (kr(e, n, t, k), e[18] = (4294901760 & e[18]) + k + 2), k++
        }

        function kr(e, t, n, i) {
            const a = n[i] < 0, c = n[i + 1], S = e[a ? -n[i] : n[i]];
            if (a) {
                if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) {
                    e[2] += 2048;
                    try {
                        c.call(S)
                    } finally {
                    }
                }
            } else try {
                c.call(S)
            } finally {
            }
        }

        class sr {
            constructor(t, n, i) {
                this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = i
            }
        }

        function as(e, t, n) {
            const i = mt(e);
            let a = 0;
            for (; a < n.length;) {
                const c = n[a];
                if ("number" == typeof c) {
                    if (0 !== c) break;
                    a++;
                    const b = n[a++], S = n[a++], k = n[a++];
                    i ? e.setAttribute(t, S, k, b) : t.setAttributeNS(b, S, k)
                } else {
                    const b = c, S = n[++a];
                    cs(b) ? i && e.setProperty(t, b, S) : i ? e.setAttribute(t, b, S) : t.setAttribute(b, S), a++
                }
            }
            return a
        }

        function ls(e) {
            return 3 === e || 4 === e || 6 === e
        }

        function cs(e) {
            return 64 === e.charCodeAt(0)
        }

        function us(e, t) {
            if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else {
                let n = -1;
                for (let i = 0; i < t.length; i++) {
                    const a = t[i];
                    "number" == typeof a ? n = a : 0 === n || ca(e, n, a, null, -1 === n || 2 === n ? t[++i] : null)
                }
            }
            return e
        }

        function ca(e, t, n, i, a) {
            let c = 0, b = e.length;
            if (-1 === t) b = -1; else for (; c < e.length;) {
                const S = e[c++];
                if ("number" == typeof S) {
                    if (S === t) {
                        b = -1;
                        break
                    }
                    if (S > t) {
                        b = c - 1;
                        break
                    }
                }
            }
            for (; c < e.length;) {
                const S = e[c];
                if ("number" == typeof S) break;
                if (S === n) {
                    if (null === i) return void (null !== a && (e[c + 1] = a));
                    if (i === e[c + 1]) return void (e[c + 2] = a)
                }
                c++, null !== i && c++, null !== a && c++
            }
            -1 !== b && (e.splice(b, 0, t), c = b + 1), e.splice(c++, 0, n), null !== i && e.splice(c++, 0, i), null !== a && e.splice(c++, 0, a)
        }

        function ua(e) {
            return -1 !== e
        }

        function Ds(e) {
            return 32767 & e
        }

        function Ts(e, t) {
            let n = function da(e) {
                return e >> 16
            }(e), i = t;
            for (; n > 0;) i = i[15], n--;
            return i
        }

        let Do = !0;

        function di(e) {
            const t = Do;
            return Do = e, t
        }

        let Ao = 0;

        function Fs(e, t) {
            const n = Ws(e, t);
            if (-1 !== n) return n;
            const i = t[1];
            i.firstCreatePass && (e.injectorIndex = t.length, Mo(i.data, e), Mo(t, null), Mo(i.blueprint, null));
            const a = Ls(e, t), c = e.injectorIndex;
            if (ua(a)) {
                const b = Ds(a), S = Ts(a, t), k = S[1].data;
                for (let pe = 0; pe < 8; pe++) t[c + pe] = S[b + pe] | k[b + pe]
            }
            return t[c + 8] = a, c
        }

        function Mo(e, t) {
            e.push(0, 0, 0, 0, 0, 0, 0, 0, t)
        }

        function Ws(e, t) {
            return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex
        }

        function Ls(e, t) {
            if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex;
            let n = 0, i = null, a = t;
            for (; null !== a;) {
                const c = a[1], b = c.type;
                if (i = 2 === b ? c.declTNode : 1 === b ? a[6] : null, null === i) return -1;
                if (n++, a = a[15], -1 !== i.injectorIndex) return i.injectorIndex | n << 16
            }
            return -1
        }

        function Bs(e, t, n) {
            !function As(e, t, n) {
                let i;
                "string" == typeof n ? i = n.charCodeAt(0) || 0 : n.hasOwnProperty(Qn) && (i = n[Qn]), null == i && (i = n[Qn] = Ao++);
                const a = 255 & i;
                t.data[e + (a >> 5)] |= 1 << a
            }(e, t, n)
        }

        function Ks(e, t, n) {
            if (n & Me.Optional) return e;
            Xe(t, "NodeInjector")
        }

        function al(e, t, n, i) {
            if (n & Me.Optional && void 0 === i && (i = null), 0 == (n & (Me.Self | Me.Host))) {
                const a = e[9], c = de(void 0);
                try {
                    return a ? a.get(t, i, n & Me.Optional) : Ze(t, i, n & Me.Optional)
                } finally {
                    de(c)
                }
            }
            return Ks(i, t, n)
        }

        function ds(e, t, n, i = Me.Default, a) {
            if (null !== e) {
                const c = function ul(e) {
                    if ("string" == typeof e) return e.charCodeAt(0) || 0;
                    const t = e.hasOwnProperty(Qn) ? e[Qn] : void 0;
                    return "number" == typeof t ? t >= 0 ? 255 & t : ll : t
                }(n);
                if ("function" == typeof c) {
                    if (!qe(t, e, i)) return i & Me.Host ? Ks(a, n, i) : al(t, n, i, a);
                    try {
                        const b = c(i);
                        if (null != b || i & Me.Optional) return b;
                        Xe(n)
                    } finally {
                        An()
                    }
                } else if ("number" == typeof c) {
                    let b = null, S = Ws(e, t), k = -1, pe = i & Me.Host ? t[16][6] : null;
                    for ((-1 === S || i & Me.SkipSelf) && (k = -1 === S ? Ls(e, t) : t[S + 8], -1 !== k && Po(i, !1) ? (b = t[1], S = Ds(k), t = Ts(k, t)) : S = -1); -1 !== S;) {
                        const Se = t[1];
                        if (ha(c, S, Se.data)) {
                            const et = cl(S, t, n, b, i, pe);
                            if (et !== Io) return et
                        }
                        k = t[S + 8], -1 !== k && Po(i, t[1].data[S + 8] === pe) && ha(c, S, t) ? (b = Se, S = Ds(k), t = Ts(k, t)) : S = -1
                    }
                }
            }
            return al(t, n, i, a)
        }

        const Io = {};

        function ll() {
            return new Ms(dr(), Lt())
        }

        function cl(e, t, n, i, a, c) {
            const b = t[1], S = b.data[e + 8],
                Se = qs(S, b, n, null == i ? Zn(S) && Do : i != b && 0 != (3 & S.type), a & Me.Host && c === S);
            return null !== Se ? $s(t, b, Se, S) : Io
        }

        function qs(e, t, n, i, a) {
            const c = e.providerIndexes, b = t.data, S = 1048575 & c, k = e.directiveStart, Se = c >> 20,
                St = a ? S + Se : e.directiveEnd;
            for (let $t = i ? S : S + Se; $t < St; $t++) {
                const tn = b[$t];
                if ($t < k && n === tn || $t >= k && tn.type === n) return $t
            }
            if (a) {
                const $t = b[k];
                if ($t && xr($t) && $t.type === n) return k
            }
            return null
        }

        function $s(e, t, n, i) {
            let a = e[n];
            const c = t.data;
            if (function ur(e) {
                return e instanceof sr
            }(a)) {
                const b = a;
                b.resolving && function Ce(e, t) {
                    const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : "";
                    throw new xe(-200, `Circular dependency in DI detected for ${e}${n}`)
                }(yt(c[n]));
                const S = di(b.canSeeViewProviders);
                b.resolving = !0;
                const k = b.injectImpl ? de(b.injectImpl) : null;
                qe(e, i, Me.Default);
                try {
                    a = e[n] = b.factory(void 0, c, e, i), t.firstCreatePass && n >= i.directiveStart && function st(e, t, n) {
                        const {ngOnChanges: i, ngOnInit: a, ngDoCheck: c} = t.type.prototype;
                        if (i) {
                            const b = si(t);
                            (n.preOrderHooks || (n.preOrderHooks = [])).push(e, b), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, b)
                        }
                        a && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, a), c && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, c), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, c))
                    }(n, c[n], t)
                } finally {
                    null !== k && de(k), di(S), b.resolving = !1, An()
                }
            }
            return a
        }

        function ha(e, t, n) {
            return !!(n[t + (e >> 5)] & 1 << e)
        }

        function Po(e, t) {
            return !(e & Me.Self || e & Me.Host && t)
        }

        class Ms {
            constructor(t, n) {
                this._tNode = t, this._lView = n
            }

            get(t, n, i) {
                return ds(this._tNode, this._lView, t, i, n)
            }
        }

        function pa(e) {
            return ye(() => {
                const t = e.prototype.constructor, n = t[Yn] || Oo(t), i = Object.prototype;
                let a = Object.getPrototypeOf(e.prototype).constructor;
                for (; a && a !== i;) {
                    const c = a[Yn] || Oo(a);
                    if (c && c !== n) return c;
                    a = Object.getPrototypeOf(a)
                }
                return c => new c
            })
        }

        function Oo(e) {
            return Ie(e) ? () => {
                const t = Oo(ge(e));
                return t && t()
            } : Xr(e)
        }

        function Vs(e) {
            return function fa(e, t) {
                if ("class" === t) return e.classes;
                if ("style" === t) return e.styles;
                const n = e.attrs;
                if (n) {
                    const i = n.length;
                    let a = 0;
                    for (; a < i;) {
                        const c = n[a];
                        if (ls(c)) break;
                        if (0 === c) a += 2; else if ("number" == typeof c) for (a++; a < i && "string" == typeof n[a];) a++; else {
                            if (c === t) return n[a + 1];
                            a += 2
                        }
                    }
                }
                return null
            }(dr(), e)
        }

        const Ps = "__parameters__";

        function A(e, t, n) {
            return ye(() => {
                const i = function ma(e) {
                    return function (...n) {
                        if (e) {
                            const i = e(...n);
                            for (const a in i) this[a] = i[a]
                        }
                    }
                }(t);

                function a(...c) {
                    if (this instanceof a) return i.apply(this, c), this;
                    const b = new a(...c);
                    return S.annotation = b, S;

                    function S(k, pe, Se) {
                        const et = k.hasOwnProperty(Ps) ? k[Ps] : Object.defineProperty(k, Ps, {value: []})[Ps];
                        for (; et.length <= Se;) et.push(null);
                        return (et[Se] = et[Se] || []).push(b), k
                    }
                }

                return n && (a.prototype = Object.create(n.prototype)), a.prototype.ngMetadataName = e, a.annotationCls = a, a
            })
        }

        class L {
            constructor(t, n) {
                this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = Ye({
                    token: this,
                    providedIn: n.providedIn || "root",
                    factory: n.factory
                }))
            }

            toString() {
                return `InjectionToken ${this._desc}`
            }
        }

        const ue = new L("AnalyzeForEntryComponents");

        function yi(e, t) {
            void 0 === t && (t = e);
            for (let n = 0; n < e.length; n++) {
                let i = e[n];
                Array.isArray(i) ? (t === e && (t = e.slice(0, n)), yi(i, t)) : t !== e && t.push(i)
            }
            return t
        }

        function qi(e, t) {
            e.forEach(n => Array.isArray(n) ? qi(n, t) : t(n))
        }

        function Su(e, t, n) {
            t >= e.length ? e.push(n) : e.splice(t, 0, n)
        }

        function ba(e, t) {
            return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0]
        }

        function Ro(e, t) {
            const n = [];
            for (let i = 0; i < e; i++) n.push(t);
            return n
        }

        function Gi(e, t, n) {
            let i = Xs(e, t);
            return i >= 0 ? e[1 | i] = n : (i = ~i, function Y0(e, t, n, i) {
                let a = e.length;
                if (a == t) e.push(n, i); else if (1 === a) e.push(i, e[0]), e[0] = n; else {
                    for (a--, e.push(e[a - 1], e[a]); a > t;) e[a] = e[a - 2], a--;
                    e[t] = n, e[t + 1] = i
                }
            }(e, i, t, n)), i
        }

        function dl(e, t) {
            const n = Xs(e, t);
            if (n >= 0) return e[1 | n]
        }

        function Xs(e, t) {
            return function Au(e, t, n) {
                let i = 0, a = e.length >> n;
                for (; a !== i;) {
                    const c = i + (a - i >> 1), b = e[c << n];
                    if (t === b) return c << n;
                    b > t ? a = c : i = c + 1
                }
                return ~(a << n)
            }(e, t, 1)
        }

        const No = {}, hl = "__NG_DI_FLAG__", wa = "ngTempTokenPath", Q0 = /\n/gm, Iu = "__source",
            tg = ae({provide: String, useValue: ae});
        let ko;

        function Pu(e) {
            const t = ko;
            return ko = e, t
        }

        function ng(e, t = Me.Default) {
            if (void 0 === ko) throw new xe(203, "");
            return null === ko ? Ze(e, void 0, t) : ko.get(e, t & Me.Optional ? null : void 0, t)
        }

        function bi(e, t = Me.Default) {
            return (function U() {
                return ne
            }() || ng)(ge(e), t)
        }

        const rg = bi;

        function pl(e) {
            const t = [];
            for (let n = 0; n < e.length; n++) {
                const i = ge(e[n]);
                if (Array.isArray(i)) {
                    if (0 === i.length) throw new xe(900, "");
                    let a, c = Me.Default;
                    for (let b = 0; b < i.length; b++) {
                        const S = i[b], k = ig(S);
                        "number" == typeof k ? -1 === k ? a = S.token : c |= k : a = S
                    }
                    t.push(bi(a, c))
                } else t.push(bi(i))
            }
            return t
        }

        function Fo(e, t) {
            return e[hl] = t, e.prototype[hl] = t, e
        }

        function ig(e) {
            return e[hl]
        }

        const Ea = Fo(A("Inject", e => ({token: e})), -1), Lo = Fo(A("Optional"), 8), Bo = Fo(A("SkipSelf"), 4);
        let Ca, Sa;

        function Js(e) {
            var t;
            return (null === (t = function ml() {
                if (void 0 === Ca && (Ca = null, Ht.trustedTypes)) try {
                    Ca = Ht.trustedTypes.createPolicy("angular", {
                        createHTML: e => e,
                        createScript: e => e,
                        createScriptURL: e => e
                    })
                } catch (e) {
                }
                return Ca
            }()) || void 0 === t ? void 0 : t.createHTML(e)) || e
        }

        function Lu(e) {
            var t;
            return (null === (t = function vl() {
                if (void 0 === Sa && (Sa = null, Ht.trustedTypes)) try {
                    Sa = Ht.trustedTypes.createPolicy("angular#unsafe-bypass", {
                        createHTML: e => e,
                        createScript: e => e,
                        createScriptURL: e => e
                    })
                } catch (e) {
                }
                return Sa
            }()) || void 0 === t ? void 0 : t.createHTML(e)) || e
        }

        class Us {
            constructor(t) {
                this.changingThisBreaksApplicationSecurity = t
            }

            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`
            }
        }

        class vg extends Us {
            getTypeName() {
                return "HTML"
            }
        }

        class yg extends Us {
            getTypeName() {
                return "Style"
            }
        }

        class bg extends Us {
            getTypeName() {
                return "Script"
            }
        }

        class xg extends Us {
            getTypeName() {
                return "URL"
            }
        }

        class wg extends Us {
            getTypeName() {
                return "ResourceURL"
            }
        }

        function ws(e) {
            return e instanceof Us ? e.changingThisBreaksApplicationSecurity : e
        }

        function Qs(e, t) {
            const n = Vu(e);
            if (null != n && n !== t) {
                if ("ResourceURL" === n && "URL" === t) return !0;
                throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`)
            }
            return n === t
        }

        function Vu(e) {
            return e instanceof Us && e.getTypeName() || null
        }

        function Eg(e) {
            return new vg(e)
        }

        function _g(e) {
            return new yg(e)
        }

        function Cg(e) {
            return new bg(e)
        }

        function Sg(e) {
            return new xg(e)
        }

        function Dg(e) {
            return new wg(e)
        }

        class Tg {
            constructor(t) {
                this.inertDocumentHelper = t
            }

            getInertBodyElement(t) {
                t = "<body><remove></remove>" + t;
                try {
                    const n = (new window.DOMParser).parseFromString(Js(t), "text/html").body;
                    return null === n ? this.inertDocumentHelper.getInertBodyElement(t) : (n.removeChild(n.firstChild), n)
                } catch (n) {
                    return null
                }
            }
        }

        class Ag {
            constructor(t) {
                if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) {
                    const n = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(n);
                    const i = this.inertDocument.createElement("body");
                    n.appendChild(i)
                }
            }

            getInertBodyElement(t) {
                const n = this.inertDocument.createElement("template");
                if ("content" in n) return n.innerHTML = Js(t), n;
                const i = this.inertDocument.createElement("body");
                return i.innerHTML = Js(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i
            }

            stripCustomNsAttrs(t) {
                const n = t.attributes;
                for (let a = n.length - 1; 0 < a; a--) {
                    const b = n.item(a).name;
                    ("xmlns:ns1" === b || 0 === b.indexOf("ns1:")) && t.removeAttribute(b)
                }
                let i = t.firstChild;
                for (; i;) i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling
            }
        }

        const Ig = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
            Pg = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;

        function Vo(e) {
            return (e = String(e)).match(Ig) || e.match(Pg) ? e : "unsafe:" + e
        }

        function fs(e) {
            const t = {};
            for (const n of e.split(",")) t[n] = !0;
            return t
        }

        function Uo(...e) {
            const t = {};
            for (const n of e) for (const i in n) n.hasOwnProperty(i) && (t[i] = !0);
            return t
        }

        const zu = fs("area,br,col,hr,img,wbr"), Gu = fs("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
            ju = fs("rp,rt"),
            yl = Uo(zu, Uo(Gu, fs("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Uo(ju, fs("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Uo(ju, Gu)),
            bl = fs("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), xl = fs("srcset"),
            Yu = Uo(bl, xl, fs("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), fs("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),
            Og = fs("script,style,template");

        class Rg {
            constructor() {
                this.sanitizedSomething = !1, this.buf = []
            }

            sanitizeChildren(t) {
                let n = t.firstChild, i = !0;
                for (; n;) if (n.nodeType === Node.ELEMENT_NODE ? i = this.startElement(n) : n.nodeType === Node.TEXT_NODE ? this.chars(n.nodeValue) : this.sanitizedSomething = !0, i && n.firstChild) n = n.firstChild; else for (; n;) {
                    n.nodeType === Node.ELEMENT_NODE && this.endElement(n);
                    let a = this.checkClobberedElement(n, n.nextSibling);
                    if (a) {
                        n = a;
                        break
                    }
                    n = this.checkClobberedElement(n, n.parentNode)
                }
                return this.buf.join("")
            }

            startElement(t) {
                const n = t.nodeName.toLowerCase();
                if (!yl.hasOwnProperty(n)) return this.sanitizedSomething = !0, !Og.hasOwnProperty(n);
                this.buf.push("<"), this.buf.push(n);
                const i = t.attributes;
                for (let a = 0; a < i.length; a++) {
                    const c = i.item(a), b = c.name, S = b.toLowerCase();
                    if (!Yu.hasOwnProperty(S)) {
                        this.sanitizedSomething = !0;
                        continue
                    }
                    let k = c.value;
                    bl[S] && (k = Vo(k)), xl[S] && (e = k, k = (e = String(e)).split(",").map(t => Vo(t.trim())).join(", ")), this.buf.push(" ", b, '="', Wu(k), '"')
                }
                var e;
                return this.buf.push(">"), !0
            }

            endElement(t) {
                const n = t.nodeName.toLowerCase();
                yl.hasOwnProperty(n) && !zu.hasOwnProperty(n) && (this.buf.push("</"), this.buf.push(n), this.buf.push(">"))
            }

            chars(t) {
                this.buf.push(Wu(t))
            }

            checkClobberedElement(t, n) {
                if (n && (t.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);
                return n
            }
        }

        const Ng = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, kg = /([^\#-~ |!])/g;

        function Wu(e) {
            return e.replace(/&/g, "&amp;").replace(Ng, function (t) {
                return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";"
            }).replace(kg, function (t) {
                return "&#" + t.charCodeAt(0) + ";"
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }

        let Da;

        function Ku(e, t) {
            let n = null;
            try {
                Da = Da || function Uu(e) {
                    const t = new Ag(e);
                    return function Mg() {
                        try {
                            return !!(new window.DOMParser).parseFromString(Js(""), "text/html")
                        } catch (e) {
                            return !1
                        }
                    }() ? new Tg(t) : t
                }(e);
                let i = t ? String(t) : "";
                n = Da.getInertBodyElement(i);
                let a = 5, c = i;
                do {
                    if (0 === a) throw new Error("Failed to sanitize html because the input is unstable");
                    a--, i = c, c = n.innerHTML, n = Da.getInertBodyElement(i)
                } while (i !== c);
                return Js((new Rg).sanitizeChildren(wl(n) || n))
            } finally {
                if (n) {
                    const i = wl(n) || n;
                    for (; i.firstChild;) i.removeChild(i.firstChild)
                }
            }
        }

        function wl(e) {
            return "content" in e && function Fg(e) {
                return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName
            }(e) ? e.content : null
        }

        var ii = (() => ((ii = ii || {})[ii.NONE = 0] = "NONE", ii[ii.HTML = 1] = "HTML", ii[ii.STYLE = 2] = "STYLE", ii[ii.SCRIPT = 3] = "SCRIPT", ii[ii.URL = 4] = "URL", ii[ii.RESOURCE_URL = 5] = "RESOURCE_URL", ii))();

        function qu(e) {
            const t = Ho();
            return t ? Lu(t.sanitize(ii.HTML, e) || "") : Qs(e, "HTML") ? Lu(ws(e)) : Ku(Y(), it(e))
        }

        function El(e) {
            const t = Ho();
            return t ? t.sanitize(ii.URL, e) || "" : Qs(e, "URL") ? ws(e) : Vo(it(e))
        }

        function Ho() {
            const e = Lt();
            return e && e[12]
        }

        const Ju = "__ngContext__";

        function Mi(e, t) {
            e[Ju] = t
        }

        function Cl(e) {
            const t = function zo(e) {
                return e[Ju] || null
            }(e);
            return t ? Array.isArray(t) ? t : t.lView : null
        }

        function Dl(e) {
            return e.ngOriginalError
        }

        function Jg(e, ...t) {
            e.error(...t)
        }

        class Ta {
            constructor() {
                this._console = console
            }

            handleError(t) {
                const n = this._findOriginalError(t), i = function Zg(e) {
                    return e && e.ngErrorLogger || Jg
                }(t);
                i(this._console, "ERROR", t), n && i(this._console, "ORIGINAL ERROR", n)
            }

            _findOriginalError(t) {
                let n = t && Dl(t);
                for (; n && Dl(n);) n = Dl(n);
                return n || null
            }
        }

        const lm = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Ht))();

        function hs(e) {
            return e instanceof Function ? e() : e
        }

        var ps = (() => ((ps = ps || {})[ps.Important = 1] = "Important", ps[ps.DashCase = 2] = "DashCase", ps))();

        function Al(e, t) {
            return undefined(e, t)
        }

        function Go(e) {
            const t = e[3];
            return hn(t) ? t[3] : t
        }

        function Ml(e) {
            return ad(e[13])
        }

        function Il(e) {
            return ad(e[4])
        }

        function ad(e) {
            for (; null !== e && !hn(e);) e = e[4];
            return e
        }

        function to(e, t, n, i, a) {
            if (null != i) {
                let c, b = !1;
                hn(i) ? c = i : Zt(i) && (b = !0, i = i[0]);
                const S = vn(i);
                0 === e && null !== n ? null == a ? hd(t, n, S) : Hs(t, n, S, a || null, !0) : 1 === e && null !== n ? Hs(t, n, S, a || null, !0) : 2 === e ? function xd(e, t, n) {
                    const i = Aa(e, t);
                    i && function Em(e, t, n, i) {
                        mt(e) ? e.removeChild(t, n, i) : t.removeChild(n)
                    }(e, i, t, n)
                }(t, S, b) : 3 === e && t.destroyNode(S), null != c && function Sm(e, t, n, i, a) {
                    const c = n[7];
                    c !== vn(n) && to(t, e, i, c, a);
                    for (let S = 10; S < n.length; S++) {
                        const k = n[S];
                        jo(k[1], k, e, t, i, c)
                    }
                }(t, e, c, n, a)
            }
        }

        function Ol(e, t, n) {
            if (mt(e)) return e.createElement(t, n);
            {
                const i = null !== n ? function _i(e) {
                    const t = e.toLowerCase();
                    return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null
                }(n) : null;
                return null === i ? e.createElement(t) : e.createElementNS(i, t)
            }
        }

        function cd(e, t) {
            const n = e[9], i = n.indexOf(t), a = t[3];
            1024 & t[2] && (t[2] &= -1025, V(a, -1)), n.splice(i, 1)
        }

        function Rl(e, t) {
            if (e.length <= 10) return;
            const n = 10 + t, i = e[n];
            if (i) {
                const a = i[17];
                null !== a && a !== e && cd(a, i), t > 0 && (e[n - 1][4] = i[4]);
                const c = ba(e, 10 + t);
                !function pm(e, t) {
                    jo(e, t, t[11], 2, null, null), t[0] = null, t[6] = null
                }(i[1], i);
                const b = c[19];
                null !== b && b.detachView(c[1]), i[3] = null, i[4] = null, i[2] &= -129
            }
            return i
        }

        function ud(e, t) {
            if (!(256 & t[2])) {
                const n = t[11];
                mt(n) && n.destroyNode && jo(e, t, n, 3, null, null), function vm(e) {
                    let t = e[13];
                    if (!t) return Nl(e[1], e);
                    for (; t;) {
                        let n = null;
                        if (Zt(t)) n = t[13]; else {
                            const i = t[10];
                            i && (n = i)
                        }
                        if (!n) {
                            for (; t && !t[4] && t !== e;) Zt(t) && Nl(t[1], t), t = t[3];
                            null === t && (t = e), Zt(t) && Nl(t[1], t), n = t && t[4]
                        }
                        t = n
                    }
                }(t)
            }
        }

        function Nl(e, t) {
            if (!(256 & t[2])) {
                t[2] &= -129, t[2] |= 256, function wm(e, t) {
                    let n;
                    if (null != e && null != (n = e.destroyHooks)) for (let i = 0; i < n.length; i += 2) {
                        const a = t[n[i]];
                        if (!(a instanceof sr)) {
                            const c = n[i + 1];
                            if (Array.isArray(c)) for (let b = 0; b < c.length; b += 2) {
                                const S = a[c[b]], k = c[b + 1];
                                try {
                                    k.call(S)
                                } finally {
                                }
                            } else try {
                                c.call(a)
                            } finally {
                            }
                        }
                    }
                }(e, t), function xm(e, t) {
                    const n = e.cleanup, i = t[7];
                    let a = -1;
                    if (null !== n) for (let c = 0; c < n.length - 1; c += 2) if ("string" == typeof n[c]) {
                        const b = n[c + 1], S = "function" == typeof b ? b(t) : vn(t[b]), k = i[a = n[c + 2]],
                            pe = n[c + 3];
                        "boolean" == typeof pe ? S.removeEventListener(n[c], k, pe) : pe >= 0 ? i[a = pe]() : i[a = -pe].unsubscribe(), c += 2
                    } else {
                        const b = i[a = n[c + 1]];
                        n[c].call(b)
                    }
                    if (null !== i) {
                        for (let c = a + 1; c < i.length; c++) i[c]();
                        t[7] = null
                    }
                }(e, t), 1 === t[1].type && mt(t[11]) && t[11].destroy();
                const n = t[17];
                if (null !== n && hn(t[3])) {
                    n !== t[3] && cd(n, t);
                    const i = t[19];
                    null !== i && i.detachView(e)
                }
            }
        }

        function dd(e, t, n) {
            return function fd(e, t, n) {
                let i = t;
                for (; null !== i && 40 & i.type;) i = (t = i).parent;
                if (null === i) return n[0];
                if (2 & i.flags) {
                    const a = e.data[i.directiveStart].encapsulation;
                    if (a === Dt.None || a === Dt.Emulated) return null
                }
                return ir(i, n)
            }(e, t.parent, n)
        }

        function Hs(e, t, n, i, a) {
            mt(e) ? e.insertBefore(t, n, i, a) : t.insertBefore(n, i, a)
        }

        function hd(e, t, n) {
            mt(e) ? e.appendChild(t, n) : t.appendChild(n)
        }

        function pd(e, t, n, i, a) {
            null !== i ? Hs(e, t, n, i, a) : hd(e, t, n)
        }

        function Aa(e, t) {
            return mt(e) ? e.parentNode(t) : t.parentNode
        }

        function gd(e, t, n) {
            return vd(e, t, n)
        }

        let vd = function md(e, t, n) {
            return 40 & e.type ? ir(e, n) : null
        };

        function Ma(e, t, n, i) {
            const a = dd(e, i, t), c = t[11], S = gd(i.parent || t[6], i, t);
            if (null != a) if (Array.isArray(n)) for (let k = 0; k < n.length; k++) pd(c, a, n[k], S, !1); else pd(c, a, n, S, !1)
        }

        function Ia(e, t) {
            if (null !== t) {
                const n = t.type;
                if (3 & n) return ir(t, e);
                if (4 & n) return Fl(-1, e[t.index]);
                if (8 & n) {
                    const i = t.child;
                    if (null !== i) return Ia(e, i);
                    {
                        const a = e[t.index];
                        return hn(a) ? Fl(-1, a) : vn(a)
                    }
                }
                if (32 & n) return Al(t, e)() || vn(e[t.index]);
                {
                    const i = bd(e, t);
                    return null !== i ? Array.isArray(i) ? i[0] : Ia(Go(e[16]), i) : Ia(e, t.next)
                }
            }
            return null
        }

        function bd(e, t) {
            return null !== t ? e[16][6].projection[t.projection] : null
        }

        function Fl(e, t) {
            const n = 10 + e + 1;
            if (n < t.length) {
                const i = t[n], a = i[1].firstChild;
                if (null !== a) return Ia(i, a)
            }
            return t[7]
        }

        function Ll(e, t, n, i, a, c, b) {
            for (; null != n;) {
                const S = i[n.index], k = n.type;
                if (b && 0 === t && (S && Mi(vn(S), i), n.flags |= 4), 64 != (64 & n.flags)) if (8 & k) Ll(e, t, n.child, i, a, c, !1), to(t, e, a, S, c); else if (32 & k) {
                    const pe = Al(n, i);
                    let Se;
                    for (; Se = pe();) to(t, e, a, Se, c);
                    to(t, e, a, S, c)
                } else 16 & k ? wd(e, t, i, n, a, c) : to(t, e, a, S, c);
                n = b ? n.projectionNext : n.next
            }
        }

        function jo(e, t, n, i, a, c) {
            Ll(n, i, e.firstChild, t, a, c, !1)
        }

        function wd(e, t, n, i, a, c) {
            const b = n[16], k = b[6].projection[i.projection];
            if (Array.isArray(k)) for (let pe = 0; pe < k.length; pe++) to(t, e, a, k[pe], c); else Ll(e, t, k, b[3], a, c, !0)
        }

        function Ed(e, t, n) {
            mt(e) ? e.setAttribute(t, "style", n) : t.style.cssText = n
        }

        function Bl(e, t, n) {
            mt(e) ? "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) : t.className = n
        }

        function _d(e, t, n) {
            let i = e.length;
            for (; ;) {
                const a = e.indexOf(t, n);
                if (-1 === a) return a;
                if (0 === a || e.charCodeAt(a - 1) <= 32) {
                    const c = t.length;
                    if (a + c === i || e.charCodeAt(a + c) <= 32) return a
                }
                n = a + 1
            }
        }

        const Cd = "ng-template";

        function Tm(e, t, n) {
            let i = 0;
            for (; i < e.length;) {
                let a = e[i++];
                if (n && "class" === a) {
                    if (a = e[i], -1 !== _d(a.toLowerCase(), t, 0)) return !0
                } else if (1 === a) {
                    for (; i < e.length && "string" == typeof (a = e[i++]);) if (a.toLowerCase() === t) return !0;
                    return !1
                }
            }
            return !1
        }

        function Sd(e) {
            return 4 === e.type && e.value !== Cd
        }

        function Am(e, t, n) {
            return t === (4 !== e.type || n ? e.value : Cd)
        }

        function Mm(e, t, n) {
            let i = 4;
            const a = e.attrs || [], c = function Om(e) {
                for (let t = 0; t < e.length; t++) if (ls(e[t])) return t;
                return e.length
            }(a);
            let b = !1;
            for (let S = 0; S < t.length; S++) {
                const k = t[S];
                if ("number" != typeof k) {
                    if (!b) if (4 & i) {
                        if (i = 2 | 1 & i, "" !== k && !Am(e, k, n) || "" === k && 1 === t.length) {
                            if (Ji(i)) return !1;
                            b = !0
                        }
                    } else {
                        const pe = 8 & i ? k : t[++S];
                        if (8 & i && null !== e.attrs) {
                            if (!Tm(e.attrs, pe, n)) {
                                if (Ji(i)) return !1;
                                b = !0
                            }
                            continue
                        }
                        const et = Im(8 & i ? "class" : k, a, Sd(e), n);
                        if (-1 === et) {
                            if (Ji(i)) return !1;
                            b = !0;
                            continue
                        }
                        if ("" !== pe) {
                            let St;
                            St = et > c ? "" : a[et + 1].toLowerCase();
                            const $t = 8 & i ? St : null;
                            if ($t && -1 !== _d($t, pe, 0) || 2 & i && pe !== St) {
                                if (Ji(i)) return !1;
                                b = !0
                            }
                        }
                    }
                } else {
                    if (!b && !Ji(i) && !Ji(k)) return !1;
                    if (b && Ji(k)) continue;
                    b = !1, i = k | 1 & i
                }
            }
            return Ji(i) || b
        }

        function Ji(e) {
            return 0 == (1 & e)
        }

        function Im(e, t, n, i) {
            if (null === t) return -1;
            let a = 0;
            if (i || !n) {
                let c = !1;
                for (; a < t.length;) {
                    const b = t[a];
                    if (b === e) return a;
                    if (3 === b || 6 === b) c = !0; else {
                        if (1 === b || 2 === b) {
                            let S = t[++a];
                            for (; "string" == typeof S;) S = t[++a];
                            continue
                        }
                        if (4 === b) break;
                        if (0 === b) {
                            a += 4;
                            continue
                        }
                    }
                    a += c ? 1 : 2
                }
                return -1
            }
            return function Rm(e, t) {
                let n = e.indexOf(4);
                if (n > -1) for (n++; n < e.length;) {
                    const i = e[n];
                    if ("number" == typeof i) return -1;
                    if (i === t) return n;
                    n++
                }
                return -1
            }(t, e)
        }

        function Dd(e, t, n = !1) {
            for (let i = 0; i < t.length; i++) if (Mm(e, t[i], n)) return !0;
            return !1
        }

        function Nm(e, t) {
            e:for (let n = 0; n < t.length; n++) {
                const i = t[n];
                if (e.length === i.length) {
                    for (let a = 0; a < e.length; a++) if (e[a] !== i[a]) continue e;
                    return !0
                }
            }
            return !1
        }

        function Td(e, t) {
            return e ? ":not(" + t.trim() + ")" : t
        }

        function km(e) {
            let t = e[0], n = 1, i = 2, a = "", c = !1;
            for (; n < e.length;) {
                let b = e[n];
                if ("string" == typeof b) if (2 & i) {
                    const S = e[++n];
                    a += "[" + b + (S.length > 0 ? '="' + S + '"' : "") + "]"
                } else 8 & i ? a += "." + b : 4 & i && (a += " " + b); else "" !== a && !Ji(b) && (t += Td(c, a), a = ""), i = b, c = c || !Ji(i);
                n++
            }
            return "" !== a && (t += Td(c, a)), t
        }

        const pr = {};

        function Ad(e) {
            Md(In(), Lt(), o() + e, p())
        }

        function Md(e, t, n, i) {
            if (!i) if (3 == (3 & t[2])) {
                const c = e.preOrderCheckHooks;
                null !== c && Wt(t, c, n)
            } else {
                const c = e.preOrderHooks;
                null !== c && pn(t, c, 0, n)
            }
            u(n)
        }

        function Pa(e, t) {
            return e << 17 | t << 2
        }

        function Qi(e) {
            return e >> 17 & 32767
        }

        function $l(e) {
            return 2 | e
        }

        function Es(e) {
            return (131068 & e) >> 2
        }

        function Vl(e, t) {
            return -131069 & e | t << 2
        }

        function Ul(e) {
            return 1 | e
        }

        function Vd(e, t) {
            const n = e.contentQueries;
            if (null !== n) for (let i = 0; i < n.length; i += 2) {
                const a = n[i], c = n[i + 1];
                if (-1 !== c) {
                    const b = e.data[c];
                    pt(a), b.contentQueries(2, t[c], c)
                }
            }
        }

        function Yo(e, t, n, i, a, c, b, S, k, pe) {
            const Se = t.blueprint.slice();
            return Se[0] = a, Se[2] = 140 | i, z(Se), Se[3] = Se[15] = e, Se[8] = n, Se[10] = b || e && e[10], Se[11] = S || e && e[11], Se[12] = k || e && e[12] || null, Se[9] = pe || e && e[9] || null, Se[6] = c, Se[16] = 2 == t.type ? e[16] : Se, Se
        }

        function no(e, t, n, i, a) {
            let c = e.data[t];
            if (null === c) c = function Xl(e, t, n, i, a) {
                const c = Mr(), b = Zr(), k = e.data[t] = function Qm(e, t, n, i, a, c) {
                    return {
                        type: n,
                        index: i,
                        insertBeforeIndex: null,
                        injectorIndex: t ? t.injectorIndex : -1,
                        directiveStart: -1,
                        directiveEnd: -1,
                        directiveStylingLast: -1,
                        propertyBindings: null,
                        flags: 0,
                        providerIndexes: 0,
                        value: a,
                        attrs: c,
                        mergedAttrs: null,
                        localNames: null,
                        initialInputs: void 0,
                        inputs: null,
                        outputs: null,
                        tViews: null,
                        next: null,
                        projectionNext: null,
                        child: null,
                        parent: t,
                        projection: null,
                        styles: null,
                        stylesWithoutHost: null,
                        residualStyles: void 0,
                        classes: null,
                        classesWithoutHost: null,
                        residualClasses: void 0,
                        classBindings: 0,
                        styleBindings: 0
                    }
                }(0, b ? c : c && c.parent, n, t, i, a);
                return null === e.firstChild && (e.firstChild = k), null !== c && (b ? null == c.child && null !== k.parent && (c.child = k) : null === c.next && (c.next = k)), k
            }(e, t, n, i, a), function He() {
                return _e.lFrame.inI18n
            }() && (c.flags |= 64); else if (64 & c.type) {
                c.type = n, c.value = i, c.attrs = a;
                const b = function Vr() {
                    const e = _e.lFrame, t = e.currentTNode;
                    return e.isParent ? t : t.parent
                }();
                c.injectorIndex = null === b ? -1 : b.injectorIndex
            }
            return Kr(c, !0), c
        }

        function ro(e, t, n, i) {
            if (0 === n) return -1;
            const a = t.length;
            for (let c = 0; c < n; c++) t.push(i), e.blueprint.push(i), e.data.push(null);
            return a
        }

        function Wo(e, t, n) {
            ot(t);
            try {
                const i = e.viewQuery;
                null !== i && sc(1, i, n);
                const a = e.template;
                null !== a && Ud(e, t, a, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Vd(e, t), e.staticViewQueries && sc(2, e.viewQuery, n);
                const c = e.components;
                null !== c && function Xm(e, t) {
                    for (let n = 0; n < t.length; n++) vv(e, t[n])
                }(t, c)
            } catch (i) {
                throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), i
            } finally {
                t[2] &= -5, on()
            }
        }

        function io(e, t, n, i) {
            const a = t[2];
            if (256 == (256 & a)) return;
            ot(t);
            const c = p();
            try {
                z(t), function fe(e) {
                    return _e.lFrame.bindingIndex = e
                }(e.bindingStartIndex), null !== n && Ud(e, t, n, 2, i);
                const b = 3 == (3 & a);
                if (!c) if (b) {
                    const pe = e.preOrderCheckHooks;
                    null !== pe && Wt(t, pe, null)
                } else {
                    const pe = e.preOrderHooks;
                    null !== pe && pn(t, pe, 0, null), Ln(t, 0)
                }
                if (function gv(e) {
                    for (let t = Ml(e); null !== t; t = Il(t)) {
                        if (!t[2]) continue;
                        const n = t[9];
                        for (let i = 0; i < n.length; i++) {
                            const a = n[i], c = a[3];
                            0 == (1024 & a[2]) && V(c, 1), a[2] |= 1024
                        }
                    }
                }(t), function pv(e) {
                    for (let t = Ml(e); null !== t; t = Il(t)) for (let n = 10; n < t.length; n++) {
                        const i = t[n], a = i[1];
                        Gr(i) && io(a, i, a.template, i[8])
                    }
                }(t), null !== e.contentQueries && Vd(e, t), !c) if (b) {
                    const pe = e.contentCheckHooks;
                    null !== pe && Wt(t, pe)
                } else {
                    const pe = e.contentHooks;
                    null !== pe && pn(t, pe, 1), Ln(t, 1)
                }
                !function Km(e, t) {
                    const n = e.hostBindingOpCodes;
                    if (null !== n) try {
                        for (let i = 0; i < n.length; i++) {
                            const a = n[i];
                            if (a < 0) u(~a); else {
                                const c = a, b = n[++i], S = n[++i];
                                je(b, c), S(2, t[c])
                            }
                        }
                    } finally {
                        u(-1)
                    }
                }(e, t);
                const S = e.components;
                null !== S && function qm(e, t) {
                    for (let n = 0; n < t.length; n++) mv(e, t[n])
                }(t, S);
                const k = e.viewQuery;
                if (null !== k && sc(2, k, i), !c) if (b) {
                    const pe = e.viewCheckHooks;
                    null !== pe && Wt(t, pe)
                } else {
                    const pe = e.viewHooks;
                    null !== pe && pn(t, pe, 2), Ln(t, 2)
                }
                !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), c || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, V(t[3], -1))
            } finally {
                on()
            }
        }

        function Zm(e, t, n, i) {
            const a = t[10], c = !p(), b = Pr(t);
            try {
                c && !b && a.begin && a.begin(), b && Wo(e, t, i), io(e, t, n, i)
            } finally {
                c && !b && a.end && a.end()
            }
        }

        function Ud(e, t, n, i, a) {
            const c = o(), b = 2 & i;
            try {
                u(-1), b && t.length > 20 && Md(e, t, 20, p()), n(i, a)
            } finally {
                u(c)
            }
        }

        function Hd(e, t, n) {
            if (Bn(t)) {
                const a = t.directiveEnd;
                for (let c = t.directiveStart; c < a; c++) {
                    const b = e.data[c];
                    b.contentQueries && b.contentQueries(1, n[c], c)
                }
            }
        }

        function Zl(e, t, n) {
            !Re() || (function ov(e, t, n, i) {
                const a = n.directiveStart, c = n.directiveEnd;
                e.firstCreatePass || Fs(n, t), Mi(i, t);
                const b = n.initialInputs;
                for (let S = a; S < c; S++) {
                    const k = e.data[S], pe = xr(k);
                    pe && dv(t, n, k);
                    const Se = $s(t, e, S, n);
                    Mi(Se, t), null !== b && fv(0, S - a, Se, k, 0, b), pe && (Or(n.index, t)[8] = Se)
                }
            }(e, t, n, ir(n, t)), 128 == (128 & n.flags) && function av(e, t, n) {
                const i = n.directiveStart, a = n.directiveEnd, b = n.index, S = function ke() {
                    return _e.lFrame.currentDirectiveIndex
                }();
                try {
                    u(b);
                    for (let k = i; k < a; k++) {
                        const pe = e.data[k], Se = t[k];
                        Ae(k), (null !== pe.hostBindings || 0 !== pe.hostVars || null !== pe.hostAttrs) && Xd(pe, Se)
                    }
                } finally {
                    u(-1), Ae(S)
                }
            }(e, t, n))
        }

        function Jl(e, t, n = ir) {
            const i = t.localNames;
            if (null !== i) {
                let a = t.index + 1;
                for (let c = 0; c < i.length; c += 2) {
                    const b = i[c + 1], S = -1 === b ? n(t, e) : e[b];
                    e[a++] = S
                }
            }
        }

        function zd(e) {
            const t = e.tView;
            return null === t || t.incompleteFirstPass ? e.tView = Na(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t
        }

        function Na(e, t, n, i, a, c, b, S, k, pe) {
            const Se = 20 + i, et = Se + a, St = function Jm(e, t) {
                const n = [];
                for (let i = 0; i < t; i++) n.push(i < e ? null : pr);
                return n
            }(Se, et), $t = "function" == typeof pe ? pe() : pe;
            return St[1] = {
                type: e,
                blueprint: St,
                template: n,
                queries: null,
                viewQuery: S,
                declTNode: t,
                data: St.slice().fill(null, Se),
                bindingStartIndex: Se,
                expandoStartIndex: et,
                hostBindingOpCodes: null,
                firstCreatePass: !0,
                firstUpdatePass: !0,
                staticViewQueries: !1,
                staticContentQueries: !1,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: "function" == typeof c ? c() : c,
                pipeRegistry: "function" == typeof b ? b() : b,
                firstChild: null,
                schemas: k,
                consts: $t,
                incompleteFirstPass: !1
            }
        }

        function Yd(e, t, n, i) {
            const a = nf(t);
            null === n ? a.push(i) : (a.push(n), e.firstCreatePass && rf(e).push(i, a.length - 1))
        }

        function Wd(e, t, n) {
            for (let i in e) if (e.hasOwnProperty(i)) {
                const a = e[i];
                (n = null === n ? {} : n).hasOwnProperty(i) ? n[i].push(t, a) : n[i] = [t, a]
            }
            return n
        }

        function ji(e, t, n, i, a, c, b, S) {
            const k = ir(t, n);
            let Se, pe = t.inputs;
            !S && null != pe && (Se = pe[i]) ? (af(e, n, Se, i, a), Zn(t) && function nv(e, t) {
                const n = Or(t, e);
                16 & n[2] || (n[2] |= 64)
            }(n, t.index)) : 3 & t.type && (i = function tv(e) {
                return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e
            }(i), a = null != b ? b(a, t.value || "", i) : a, mt(c) ? c.setProperty(k, i, a) : cs(i) || (k.setProperty ? k.setProperty(i, a) : k[i] = a))
        }

        function Ql(e, t, n, i) {
            let a = !1;
            if (Re()) {
                const c = function lv(e, t, n) {
                    const i = e.directiveRegistry;
                    let a = null;
                    if (i) for (let c = 0; c < i.length; c++) {
                        const b = i[c];
                        Dd(n, b.selectors, !1) && (a || (a = []), Bs(Fs(n, t), e, b.type), xr(b) ? (Zd(e, n), a.unshift(b)) : a.push(b))
                    }
                    return a
                }(e, t, n), b = null === i ? null : {"": -1};
                if (null !== c) {
                    a = !0, Jd(n, e.data.length, c.length);
                    for (let Se = 0; Se < c.length; Se++) {
                        const et = c[Se];
                        et.providersResolver && et.providersResolver(et)
                    }
                    let S = !1, k = !1, pe = ro(e, t, c.length, null);
                    for (let Se = 0; Se < c.length; Se++) {
                        const et = c[Se];
                        n.mergedAttrs = us(n.mergedAttrs, et.hostAttrs), Qd(e, n, t, pe, et), uv(pe, et, b), null !== et.contentQueries && (n.flags |= 8), (null !== et.hostBindings || null !== et.hostAttrs || 0 !== et.hostVars) && (n.flags |= 128);
                        const St = et.type.prototype;
                        !S && (St.ngOnChanges || St.ngOnInit || St.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), S = !0), !k && (St.ngOnChanges || St.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), k = !0), pe++
                    }
                    !function ev(e, t) {
                        const i = t.directiveEnd, a = e.data, c = t.attrs, b = [];
                        let S = null, k = null;
                        for (let pe = t.directiveStart; pe < i; pe++) {
                            const Se = a[pe], et = Se.inputs, St = null === c || Sd(t) ? null : hv(et, c);
                            b.push(St), S = Wd(et, pe, S), k = Wd(Se.outputs, pe, k)
                        }
                        null !== S && (S.hasOwnProperty("class") && (t.flags |= 16), S.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = b, t.inputs = S, t.outputs = k
                    }(e, n)
                }
                b && function cv(e, t, n) {
                    if (t) {
                        const i = e.localNames = [];
                        for (let a = 0; a < t.length; a += 2) {
                            const c = n[t[a + 1]];
                            if (null == c) throw new xe(-301, !1);
                            i.push(t[a], c)
                        }
                    }
                }(n, i, b)
            }
            return n.mergedAttrs = us(n.mergedAttrs, n.attrs), a
        }

        function qd(e, t, n, i, a, c) {
            const b = c.hostBindings;
            if (b) {
                let S = e.hostBindingOpCodes;
                null === S && (S = e.hostBindingOpCodes = []);
                const k = ~t.index;
                (function sv(e) {
                    let t = e.length;
                    for (; t > 0;) {
                        const n = e[--t];
                        if ("number" == typeof n && n < 0) return n
                    }
                    return 0
                })(S) != k && S.push(k), S.push(i, a, b)
            }
        }

        function Xd(e, t) {
            null !== e.hostBindings && e.hostBindings(1, t)
        }

        function Zd(e, t) {
            t.flags |= 2, (e.components || (e.components = [])).push(t.index)
        }

        function uv(e, t, n) {
            if (n) {
                if (t.exportAs) for (let i = 0; i < t.exportAs.length; i++) n[t.exportAs[i]] = e;
                xr(t) && (n[""] = e)
            }
        }

        function Jd(e, t, n) {
            e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t
        }

        function Qd(e, t, n, i, a) {
            e.data[i] = a;
            const c = a.factory || (a.factory = Xr(a.type)), b = new sr(c, xr(a), null);
            e.blueprint[i] = b, n[i] = b, qd(e, t, 0, i, ro(e, n, a.hostVars, pr), a)
        }

        function dv(e, t, n) {
            const i = ir(t, e), a = zd(n), c = e[10],
                b = ka(e, Yo(e, a, null, n.onPush ? 64 : 16, i, t, c, c.createRenderer(i, n), null, null));
            e[t.index] = b
        }

        function gs(e, t, n, i, a, c) {
            const b = ir(e, t);
            !function ec(e, t, n, i, a, c, b) {
                if (null == c) mt(e) ? e.removeAttribute(t, a, n) : t.removeAttribute(a); else {
                    const S = null == b ? it(c) : b(c, i || "", a);
                    mt(e) ? e.setAttribute(t, a, S, n) : n ? t.setAttributeNS(n, a, S) : t.setAttribute(a, S)
                }
            }(t[11], b, c, e.value, n, i, a)
        }

        function fv(e, t, n, i, a, c) {
            const b = c[t];
            if (null !== b) {
                const S = i.setInput;
                for (let k = 0; k < b.length;) {
                    const pe = b[k++], Se = b[k++], et = b[k++];
                    null !== S ? i.setInput(n, et, pe, Se) : n[Se] = et
                }
            }
        }

        function hv(e, t) {
            let n = null, i = 0;
            for (; i < t.length;) {
                const a = t[i];
                if (0 !== a) if (5 !== a) {
                    if ("number" == typeof a) break;
                    e.hasOwnProperty(a) && (null === n && (n = []), n.push(a, e[a], t[i + 1])), i += 2
                } else i += 2; else i += 4
            }
            return n
        }

        function ef(e, t, n, i) {
            return new Array(e, !0, !1, t, null, 0, i, n, null, null)
        }

        function mv(e, t) {
            const n = Or(t, e);
            if (Gr(n)) {
                const i = n[1];
                80 & n[2] ? io(i, n, i.template, n[8]) : n[5] > 0 && tc(n)
            }
        }

        function tc(e) {
            for (let i = Ml(e); null !== i; i = Il(i)) for (let a = 10; a < i.length; a++) {
                const c = i[a];
                if (1024 & c[2]) {
                    const b = c[1];
                    io(b, c, b.template, c[8])
                } else c[5] > 0 && tc(c)
            }
            const n = e[1].components;
            if (null !== n) for (let i = 0; i < n.length; i++) {
                const a = Or(n[i], e);
                Gr(a) && a[5] > 0 && tc(a)
            }
        }

        function vv(e, t) {
            const n = Or(t, e), i = n[1];
            (function yv(e, t) {
                for (let n = t.length; n < e.blueprint.length; n++) t.push(e.blueprint[n])
            })(i, n), Wo(i, n, n[8])
        }

        function ka(e, t) {
            return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t
        }

        function nc(e) {
            for (; e;) {
                e[2] |= 64;
                const t = Go(e);
                if ($r(e) && !t) return e;
                e = t
            }
            return null
        }

        function ic(e, t, n) {
            const i = t[10];
            i.begin && i.begin();
            try {
                io(e, t, e.template, n)
            } catch (a) {
                throw of(t, a), a
            } finally {
                i.end && i.end()
            }
        }

        function tf(e) {
            !function rc(e) {
                for (let t = 0; t < e.components.length; t++) {
                    const n = e.components[t], i = Cl(n), a = i[1];
                    Zm(a, i, a.template, n)
                }
            }(e[8])
        }

        function sc(e, t, n) {
            pt(0), t(e, n)
        }

        const Ev = (() => Promise.resolve(null))();

        function nf(e) {
            return e[7] || (e[7] = [])
        }

        function rf(e) {
            return e.cleanup || (e.cleanup = [])
        }

        function of(e, t) {
            const n = e[9], i = n ? n.get(Ta, null) : null;
            i && i.handleError(t)
        }

        function af(e, t, n, i, a) {
            for (let c = 0; c < n.length;) {
                const b = n[c++], S = n[c++], k = t[b], pe = e.data[b];
                null !== pe.setInput ? pe.setInput(k, a, i, S) : k[S] = a
            }
        }

        function _s(e, t, n) {
            const i = hr(t, e);
            !function ld(e, t, n) {
                mt(e) ? e.setValue(t, n) : t.textContent = n
            }(e[11], i, n)
        }

        function Fa(e, t, n) {
            let i = n ? e.styles : null, a = n ? e.classes : null, c = 0;
            if (null !== t) for (let b = 0; b < t.length; b++) {
                const S = t[b];
                "number" == typeof S ? c = S : 1 == c ? a = H(a, S) : 2 == c && (i = H(i, S + ": " + t[++b] + ";"))
            }
            n ? e.styles = i : e.stylesWithoutHost = i, n ? e.classes = a : e.classesWithoutHost = a
        }

        const oc = new L("INJECTOR", -1);

        class lf {
            get(t, n = No) {
                if (n === No) {
                    const i = new Error(`NullInjectorError: No provider for ${M(t)}!`);
                    throw i.name = "NullInjectorError", i
                }
                return n
            }
        }

        const ac = new L("Set Injector scope."), Ko = {}, Sv = {};
        let lc;

        function cf() {
            return void 0 === lc && (lc = new lf), lc
        }

        function uf(e, t = null, n = null, i) {
            const a = df(e, t, n, i);
            return a._resolveInjectorDefTypes(), a
        }

        function df(e, t = null, n = null, i) {
            return new Dv(e, n, t || cf(), i)
        }

        class Dv {
            constructor(t, n, i, a = null) {
                this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1;
                const c = [];
                n && qi(n, S => this.processProvider(S, t, n)), qi([t], S => this.processInjectorType(S, [], c)), this.records.set(oc, so(void 0, this));
                const b = this.records.get(ac);
                this.scope = null != b ? b.value : null, this.source = a || ("object" == typeof t ? null : M(t))
            }

            get destroyed() {
                return this._destroyed
            }

            destroy() {
                this.assertNotDestroyed(), this._destroyed = !0;
                try {
                    this.onDestroy.forEach(t => t.ngOnDestroy())
                } finally {
                    this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear()
                }
            }

            get(t, n = No, i = Me.Default) {
                this.assertNotDestroyed();
                const a = Pu(this), c = de(void 0);
                try {
                    if (!(i & Me.SkipSelf)) {
                        let S = this.records.get(t);
                        if (void 0 === S) {
                            const k = function Nv(e) {
                                return "function" == typeof e || "object" == typeof e && e instanceof L
                            }(t) && Pt(t);
                            S = k && this.injectableDefInScope(k) ? so(cc(t), Ko) : null, this.records.set(t, S)
                        }
                        if (null != S) return this.hydrate(t, S)
                    }
                    return (i & Me.Self ? cf() : this.parent).get(t, n = i & Me.Optional && n === No ? null : n)
                } catch (b) {
                    if ("NullInjectorError" === b.name) {
                        if ((b[wa] = b[wa] || []).unshift(M(t)), a) throw b;
                        return function sg(e, t, n, i) {
                            const a = e[wa];
                            throw t[Iu] && a.unshift(t[Iu]), e.message = function og(e, t, n, i = null) {
                                e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e;
                                let a = M(t);
                                if (Array.isArray(t)) a = t.map(M).join(" -> "); else if ("object" == typeof t) {
                                    let c = [];
                                    for (let b in t) if (t.hasOwnProperty(b)) {
                                        let S = t[b];
                                        c.push(b + ":" + ("string" == typeof S ? JSON.stringify(S) : M(S)))
                                    }
                                    a = `{${c.join(", ")}}`
                                }
                                return `${n}${i ? "(" + i + ")" : ""}[${a}]: ${e.replace(Q0, "\n  ")}`
                            }("\n" + e.message, a, n, i), e.ngTokenPath = a, e[wa] = null, e
                        }(b, t, "R3InjectorError", this.source)
                    }
                    throw b
                } finally {
                    de(c), Pu(a)
                }
            }

            _resolveInjectorDefTypes() {
                this.injectorDefTypes.forEach(t => this.get(t))
            }

            toString() {
                const t = [];
                return this.records.forEach((i, a) => t.push(M(a))), `R3Injector[${t.join(", ")}]`
            }

            assertNotDestroyed() {
                if (this._destroyed) throw new xe(205, !1)
            }

            processInjectorType(t, n, i) {
                if (!(t = ge(t))) return !1;
                let a = xn(t);
                const c = null == a && t.ngModule || void 0, b = void 0 === c ? t : c, S = -1 !== i.indexOf(b);
                if (void 0 !== c && (a = xn(c)), null == a) return !1;
                if (null != a.imports && !S) {
                    let Se;
                    i.push(b);
                    try {
                        qi(a.imports, et => {
                            this.processInjectorType(et, n, i) && (void 0 === Se && (Se = []), Se.push(et))
                        })
                    } finally {
                    }
                    if (void 0 !== Se) for (let et = 0; et < Se.length; et++) {
                        const {ngModule: St, providers: $t} = Se[et];
                        qi($t, tn => this.processProvider(tn, St, $t || gn))
                    }
                }
                this.injectorDefTypes.add(b);
                const k = Xr(b) || (() => new b);
                this.records.set(b, so(k, Ko));
                const pe = a.providers;
                if (null != pe && !S) {
                    const Se = t;
                    qi(pe, et => this.processProvider(et, Se, pe))
                }
                return void 0 !== c && void 0 !== t.providers
            }

            processProvider(t, n, i) {
                let a = oo(t = ge(t)) ? t : ge(t && t.provide);
                const c = function Av(e, t, n) {
                    return hf(e) ? so(void 0, e.useValue) : so(ff(e), Ko)
                }(t);
                if (oo(t) || !0 !== t.multi) this.records.get(a); else {
                    let b = this.records.get(a);
                    b || (b = so(void 0, Ko, !0), b.factory = () => pl(b.multi), this.records.set(a, b)), a = t, b.multi.push(t)
                }
                this.records.set(a, c)
            }

            hydrate(t, n) {
                return n.value === Ko && (n.value = Sv, n.value = n.factory()), "object" == typeof n.value && n.value && function Rv(e) {
                    return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy
                }(n.value) && this.onDestroy.add(n.value), n.value
            }

            injectableDefInScope(t) {
                if (!t.providedIn) return !1;
                const n = ge(t.providedIn);
                return "string" == typeof n ? "any" === n || n === this.scope : this.injectorDefTypes.has(n)
            }
        }

        function cc(e) {
            const t = Pt(e), n = null !== t ? t.factory : Xr(e);
            if (null !== n) return n;
            if (e instanceof L) throw new xe(204, !1);
            if (e instanceof Function) return function Tv(e) {
                const t = e.length;
                if (t > 0) throw Ro(t, "?"), new xe(204, !1);
                const n = function yn(e) {
                    const t = e && (e[Fn] || e[Nn]);
                    if (t) {
                        const n = function Xt(e) {
                            if (e.hasOwnProperty("name")) return e.name;
                            const t = ("" + e).match(/^function\s*([^\s(]+)/);
                            return null === t ? "" : t[1]
                        }(e);
                        return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t
                    }
                    return null
                }(e);
                return null !== n ? () => n.factory(e) : () => new e
            }(e);
            throw new xe(204, !1)
        }

        function ff(e, t, n) {
            let i;
            if (oo(e)) {
                const a = ge(e);
                return Xr(a) || cc(a)
            }
            if (hf(e)) i = () => ge(e.useValue); else if (function Iv(e) {
                return !(!e || !e.useFactory)
            }(e)) i = () => e.useFactory(...pl(e.deps || [])); else if (function Mv(e) {
                return !(!e || !e.useExisting)
            }(e)) i = () => bi(ge(e.useExisting)); else {
                const a = ge(e && (e.useClass || e.provide));
                if (!function Ov(e) {
                    return !!e.deps
                }(e)) return Xr(a) || cc(a);
                i = () => new a(...pl(e.deps))
            }
            return i
        }

        function so(e, t, n = !1) {
            return {factory: e, value: t, multi: n ? [] : void 0}
        }

        function hf(e) {
            return null !== e && "object" == typeof e && tg in e
        }

        function oo(e) {
            return "function" == typeof e
        }

        let es = (() => {
            class e {
                static create(n, i) {
                    var a;
                    if (Array.isArray(n)) return uf({name: ""}, i, n, "");
                    {
                        const c = null !== (a = n.name) && void 0 !== a ? a : "";
                        return uf({name: c}, n.parent, n.providers, c)
                    }
                }
            }

            return e.THROW_IF_NOT_FOUND = No, e.NULL = new lf, e.\u0275prov = Ye({
                token: e,
                providedIn: "any",
                factory: () => bi(oc)
            }), e.__NG_ELEMENT_ID__ = -1, e
        })();

        function Hv(e, t) {
            Vt(Cl(e)[1], dr())
        }

        function fc(e) {
            let t = function Sf(e) {
                return Object.getPrototypeOf(e.prototype).constructor
            }(e.type), n = !0;
            const i = [e];
            for (; t;) {
                let a;
                if (xr(e)) a = t.\u0275cmp || t.\u0275dir; else {
                    if (t.\u0275cmp) throw new xe(903, "");
                    a = t.\u0275dir
                }
                if (a) {
                    if (n) {
                        i.push(a);
                        const b = e;
                        b.inputs = hc(e.inputs), b.declaredInputs = hc(e.declaredInputs), b.outputs = hc(e.outputs);
                        const S = a.hostBindings;
                        S && Yv(e, S);
                        const k = a.viewQuery, pe = a.contentQueries;
                        if (k && Gv(e, k), pe && jv(e, pe), X(e.inputs, a.inputs), X(e.declaredInputs, a.declaredInputs), X(e.outputs, a.outputs), xr(a) && a.data.animation) {
                            const Se = e.data;
                            Se.animation = (Se.animation || []).concat(a.data.animation)
                        }
                    }
                    const c = a.features;
                    if (c) for (let b = 0; b < c.length; b++) {
                        const S = c[b];
                        S && S.ngInherit && S(e), S === fc && (n = !1)
                    }
                }
                t = Object.getPrototypeOf(t)
            }
            !function zv(e) {
                let t = 0, n = null;
                for (let i = e.length - 1; i >= 0; i--) {
                    const a = e[i];
                    a.hostVars = t += a.hostVars, a.hostAttrs = us(a.hostAttrs, n = us(n, a.hostAttrs))
                }
            }(i)
        }

        function hc(e) {
            return e === rn ? {} : e === gn ? [] : e
        }

        function Gv(e, t) {
            const n = e.viewQuery;
            e.viewQuery = n ? (i, a) => {
                t(i, a), n(i, a)
            } : t
        }

        function jv(e, t) {
            const n = e.contentQueries;
            e.contentQueries = n ? (i, a, c) => {
                t(i, a, c), n(i, a, c)
            } : t
        }

        function Yv(e, t) {
            const n = e.hostBindings;
            e.hostBindings = n ? (i, a) => {
                t(i, a), n(i, a)
            } : t
        }

        let La = null;

        function ao() {
            if (!La) {
                const e = Ht.Symbol;
                if (e && e.iterator) La = e.iterator; else {
                    const t = Object.getOwnPropertyNames(Map.prototype);
                    for (let n = 0; n < t.length; ++n) {
                        const i = t[n];
                        "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (La = i)
                    }
                }
            }
            return La
        }

        function qo(e) {
            return !!pc(e) && (Array.isArray(e) || !(e instanceof Map) && ao() in e)
        }

        function pc(e) {
            return null !== e && ("function" == typeof e || "object" == typeof e)
        }

        function ms(e, t, n) {
            return e[t] = n
        }

        function Ii(e, t, n) {
            return !Object.is(e[t], n) && (e[t] = n, !0)
        }

        function Ba(e, t, n, i, a) {
            const c = function zs(e, t, n, i) {
                const a = Ii(e, t, n);
                return Ii(e, t + 1, i) || a
            }(e, t, n, i);
            return Ii(e, t + 2, a) || c
        }

        function gc(e, t, n, i) {
            const a = Lt();
            return Ii(a, le(), t) && (In(), gs(d(), a, e, t, n, i)), gc
        }

        function co(e, t, n, i) {
            return Ii(e, le(), n) ? t + it(n) + i : pr
        }

        function kf(e, t, n, i, a, c, b, S) {
            const k = Lt(), pe = In(), Se = e + 20, et = pe.firstCreatePass ? function Qv(e, t, n, i, a, c, b, S, k) {
                const pe = t.consts, Se = no(t, e, 4, b || null, re(pe, S));
                Ql(t, n, Se, re(pe, k)), Vt(t, Se);
                const et = Se.tViews = Na(2, Se, i, a, c, t.directiveRegistry, t.pipeRegistry, null, t.schemas, pe);
                return null !== t.queries && (t.queries.template(t, Se), et.queries = t.queries.embeddedTView(Se)), Se
            }(Se, pe, k, t, n, i, a, c, b) : pe.data[Se];
            Kr(et, !1);
            const St = k[11].createComment("");
            Ma(pe, k, St, et), Mi(St, k), ka(k, k[Se] = ef(St, k, St, et)), lr(et) && Zl(pe, k, et), null != b && Jl(k, et, S)
        }

        function Ff(e) {
            return Ar(function bs() {
                return _e.lFrame.contextLView
            }(), 20 + e)
        }

        function Zo(e, t = Me.Default) {
            const n = Lt();
            return null === n ? bi(e, t) : ds(dr(), n, ge(e), t)
        }

        function Wf() {
            throw new Error("invalid")
        }

        function xc(e, t, n) {
            const i = Lt();
            return Ii(i, le(), t) && ji(In(), d(), i, e, t, i[11], n, !1), xc
        }

        function wc(e, t, n, i, a) {
            const b = a ? "class" : "style";
            af(e, n, t.inputs[b], b, i)
        }

        function Va(e, t, n, i) {
            const a = Lt(), c = In(), b = 20 + e, S = a[11], k = a[b] = Ol(S, t, function xt() {
                return _e.lFrame.currentNamespace
            }()), pe = c.firstCreatePass ? function xy(e, t, n, i, a, c, b) {
                const S = t.consts, pe = no(t, e, 2, a, re(S, c));
                return Ql(t, n, pe, re(S, b)), null !== pe.attrs && Fa(pe, pe.attrs, !1), null !== pe.mergedAttrs && Fa(pe, pe.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, pe), pe
            }(b, c, a, 0, t, n, i) : c.data[b];
            Kr(pe, !0);
            const Se = pe.mergedAttrs;
            null !== Se && as(S, k, Se);
            const et = pe.classes;
            null !== et && Bl(S, k, et);
            const St = pe.styles;
            return null !== St && Ed(S, k, St), 64 != (64 & pe.flags) && Ma(c, a, k, pe), 0 === function G() {
                return _e.lFrame.elementDepthCount
            }() && Mi(k, a), function m() {
                _e.lFrame.elementDepthCount++
            }(), lr(pe) && (Zl(c, a, pe), Hd(c, pe, a)), null !== i && Jl(a, pe), Va
        }

        function Ua() {
            let e = dr();
            Zr() ? Ai() : (e = e.parent, Kr(e, !1));
            const t = e;
            !function K() {
                _e.lFrame.elementDepthCount--
            }();
            const n = In();
            return n.firstCreatePass && (Vt(n, e), Bn(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function Ki(e) {
                return 0 != (16 & e.flags)
            }(t) && wc(n, t, Lt(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function Cs(e) {
                return 0 != (32 & e.flags)
            }(t) && wc(n, t, Lt(), t.stylesWithoutHost, !1), Ua
        }

        function Ec(e, t, n, i) {
            return Va(e, t, n, i), Ua(), Ec
        }

        function Ha(e, t, n) {
            const i = Lt(), a = In(), c = e + 20, b = a.firstCreatePass ? function wy(e, t, n, i, a) {
                const c = t.consts, b = re(c, i), S = no(t, e, 8, "ng-container", b);
                return null !== b && Fa(S, b, !0), Ql(t, n, S, re(c, a)), null !== t.queries && t.queries.elementStart(t, S), S
            }(c, a, i, t, n) : a.data[c];
            Kr(b, !0);
            const S = i[c] = i[11].createComment("");
            return Ma(a, i, S, b), Mi(S, i), lr(b) && (Zl(a, i, b), Hd(a, b, i)), null != n && Jl(i, b), Ha
        }

        function za() {
            let e = dr();
            const t = In();
            return Zr() ? Ai() : (e = e.parent, Kr(e, !1)), t.firstCreatePass && (Vt(t, e), Bn(e) && t.queries.elementEnd(e)), za
        }

        function _c(e, t, n) {
            return Ha(e, t, n), za(), _c
        }

        function Kf() {
            return Lt()
        }

        function Cc(e) {
            return !!e && "function" == typeof e.then
        }

        function qf(e) {
            return !!e && "function" == typeof e.subscribe
        }

        const Xf = qf;

        function Sc(e, t, n, i) {
            const a = Lt(), c = In(), b = dr();
            return function Jf(e, t, n, i, a, c, b, S) {
                const k = lr(i), Se = e.firstCreatePass && rf(e), et = t[8], St = nf(t);
                let $t = !0;
                if (3 & i.type || S) {
                    const Rn = ir(i, t), Gn = S ? S(Rn) : Rn, cn = St.length,
                        Jn = S ? Sr => S(vn(Sr[i.index])) : i.index;
                    if (mt(n)) {
                        let Sr = null;
                        if (!S && k && (Sr = function Ey(e, t, n, i) {
                            const a = e.cleanup;
                            if (null != a) for (let c = 0; c < a.length - 1; c += 2) {
                                const b = a[c];
                                if (b === n && a[c + 1] === i) {
                                    const S = t[7], k = a[c + 2];
                                    return S.length > k ? S[k] : null
                                }
                                "string" == typeof b && (c += 2)
                            }
                            return null
                        }(e, t, a, i.index)), null !== Sr) (Sr.__ngLastListenerFn__ || Sr).__ngNextListenerFn__ = c, Sr.__ngLastListenerFn__ = c, $t = !1; else {
                            c = Dc(i, t, et, c, !1);
                            const Lr = n.listen(Gn, a, c);
                            St.push(c, Lr), Se && Se.push(a, Jn, cn, cn + 1)
                        }
                    } else c = Dc(i, t, et, c, !0), Gn.addEventListener(a, c, b), St.push(c), Se && Se.push(a, Jn, cn, b)
                } else c = Dc(i, t, et, c, !1);
                const tn = i.outputs;
                let Tn;
                if ($t && null !== tn && (Tn = tn[a])) {
                    const Rn = Tn.length;
                    if (Rn) for (let Gn = 0; Gn < Rn; Gn += 2) {
                        const Yi = t[Tn[Gn]][Tn[Gn + 1]].subscribe(c), Ys = St.length;
                        St.push(c, Yi), Se && Se.push(a, i.index, Ys, -(Ys + 1))
                    }
                }
            }(c, a, a[11], b, e, t, !!n, i), Sc
        }

        function Qf(e, t, n, i) {
            try {
                return !1 !== n(i)
            } catch (a) {
                return of(e, a), !1
            }
        }

        function Dc(e, t, n, i, a) {
            return function c(b) {
                if (b === Function) return i;
                const S = 2 & e.flags ? Or(e.index, t) : t;
                0 == (32 & t[2]) && nc(S);
                let k = Qf(t, 0, i, b), pe = c.__ngNextListenerFn__;
                for (; pe;) k = Qf(t, 0, pe, b) && k, pe = pe.__ngNextListenerFn__;
                return a && !1 === k && (b.preventDefault(), b.returnValue = !1), k
            }
        }

        function eh(e = 1) {
            return function Cn(e) {
                return (_e.lFrame.contextLView = function N(e, t) {
                    for (; e > 0;) t = t[15], e--;
                    return t
                }(e, _e.lFrame.contextLView))[8]
            }(e)
        }

        function _y(e, t) {
            let n = null;
            const i = function Pm(e) {
                const t = e.attrs;
                if (null != t) {
                    const n = t.indexOf(5);
                    if (0 == (1 & n)) return t[n + 1]
                }
                return null
            }(e);
            for (let a = 0; a < t.length; a++) {
                const c = t[a];
                if ("*" !== c) {
                    if (null === i ? Dd(e, c, !0) : Nm(i, c)) return a
                } else n = a
            }
            return n
        }

        function th(e) {
            const t = Lt()[16][6];
            if (!t.projection) {
                const i = t.projection = Ro(e ? e.length : 1, null), a = i.slice();
                let c = t.child;
                for (; null !== c;) {
                    const b = e ? _y(c, e) : 0;
                    null !== b && (a[b] ? a[b].projectionNext = c : i[b] = c, a[b] = c), c = c.next
                }
            }
        }

        function nh(e, t = 0, n) {
            const i = Lt(), a = In(), c = no(a, 20 + e, 16, null, n || null);
            null === c.projection && (c.projection = t), Ai(), 64 != (64 & c.flags) && function Cm(e, t, n) {
                wd(t[11], 0, t, n, dd(e, n, t), gd(n.parent || t[6], n, t))
            }(a, i, c)
        }

        function Tc(e, t, n) {
            return Ga(e, "", t, "", n), Tc
        }

        function Ga(e, t, n, i, a) {
            const c = Lt(), b = co(c, t, n, i);
            return b !== pr && ji(In(), d(), c, e, b, c[11], a, !1), Ga
        }

        function dh(e, t, n, i, a) {
            const c = e[n + 1], b = null === t;
            let S = i ? Qi(c) : Es(c), k = !1;
            for (; 0 !== S && (!1 === k || b);) {
                const Se = e[S + 1];
                Dy(e[S], t) && (k = !0, e[S + 1] = i ? Ul(Se) : $l(Se)), S = i ? Qi(Se) : Es(Se)
            }
            k && (e[n + 1] = i ? $l(c) : Ul(c))
        }

        function Dy(e, t) {
            return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && Xs(e, t) >= 0
        }

        const fi = {textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0};

        function fh(e) {
            return e.substring(fi.key, fi.keyEnd)
        }

        function Ty(e) {
            return e.substring(fi.value, fi.valueEnd)
        }

        function hh(e, t) {
            const n = fi.textEnd;
            return n === t ? -1 : (t = fi.keyEnd = function Iy(e, t, n) {
                for (; t < n && e.charCodeAt(t) > 32;) t++;
                return t
            }(e, fi.key = t, n), bo(e, t, n))
        }

        function ph(e, t) {
            const n = fi.textEnd;
            let i = fi.key = bo(e, t, n);
            return n === i ? -1 : (i = fi.keyEnd = function Py(e, t, n) {
                let i;
                for (; t < n && (45 === (i = e.charCodeAt(t)) || 95 === i || (-33 & i) >= 65 && (-33 & i) <= 90 || i >= 48 && i <= 57);) t++;
                return t
            }(e, i, n), i = mh(e, i, n), i = fi.value = bo(e, i, n), i = fi.valueEnd = function Oy(e, t, n) {
                let i = -1, a = -1, c = -1, b = t, S = b;
                for (; b < n;) {
                    const k = e.charCodeAt(b++);
                    if (59 === k) return S;
                    34 === k || 39 === k ? S = b = vh(e, k, b, n) : t === b - 4 && 85 === c && 82 === a && 76 === i && 40 === k ? S = b = vh(e, 41, b, n) : k > 32 && (S = b), c = a, a = i, i = -33 & k
                }
                return S
            }(e, i, n), mh(e, i, n))
        }

        function gh(e) {
            fi.key = 0, fi.keyEnd = 0, fi.value = 0, fi.valueEnd = 0, fi.textEnd = e.length
        }

        function bo(e, t, n) {
            for (; t < n && e.charCodeAt(t) <= 32;) t++;
            return t
        }

        function mh(e, t, n, i) {
            return (t = bo(e, t, n)) < n && t++, t
        }

        function vh(e, t, n, i) {
            let a = -1, c = n;
            for (; c < i;) {
                const b = e.charCodeAt(c++);
                if (b == t && 92 !== a) return c;
                a = 92 == b && 92 === a ? 0 : b
            }
            throw new Error
        }

        function Ac(e, t) {
            return function rs(e, t, n, i) {
                const a = Lt(), c = In(), b = De(2);
                c.firstUpdatePass && wh(c, e, b, i), t !== pr && Ii(a, b, t) && _h(c, c.data[o()], a, a[11], e, a[b + 1] = function Vy(e, t) {
                    return null == e || ("string" == typeof t ? e += t : "object" == typeof e && (e = M(ws(e)))), e
                }(t, n), i, b)
            }(e, t, null, !0), Ac
        }

        function ns(e) {
            is(Eh, Ry, e, !1)
        }

        function Ry(e, t) {
            for (let n = function My(e) {
                return gh(e), ph(e, bo(e, 0, fi.textEnd))
            }(t); n >= 0; n = ph(t, n)) Eh(e, fh(t), Ty(t))
        }

        function bh(e) {
            is(Gi, vs, e, !0)
        }

        function vs(e, t) {
            for (let n = function Ay(e) {
                return gh(e), hh(e, bo(e, 0, fi.textEnd))
            }(t); n >= 0; n = hh(t, n)) Gi(e, fh(t), !0)
        }

        function is(e, t, n, i) {
            const a = In(), c = De(2);
            a.firstUpdatePass && wh(a, null, c, i);
            const b = Lt();
            if (n !== pr && Ii(b, c, n)) {
                const S = a.data[o()];
                if (Sh(S, i) && !xh(a, c)) {
                    let k = i ? S.classesWithoutHost : S.stylesWithoutHost;
                    null !== k && (n = H(k, n || "")), wc(a, S, b, n, i)
                } else !function $y(e, t, n, i, a, c, b, S) {
                    a === pr && (a = gn);
                    let k = 0, pe = 0, Se = 0 < a.length ? a[0] : null, et = 0 < c.length ? c[0] : null;
                    for (; null !== Se || null !== et;) {
                        const St = k < a.length ? a[k + 1] : void 0, $t = pe < c.length ? c[pe + 1] : void 0;
                        let Tn, tn = null;
                        Se === et ? (k += 2, pe += 2, St !== $t && (tn = et, Tn = $t)) : null === et || null !== Se && Se < et ? (k += 2, tn = Se) : (pe += 2, tn = et, Tn = $t), null !== tn && _h(e, t, n, i, tn, Tn, b, S), Se = k < a.length ? a[k] : null, et = pe < c.length ? c[pe] : null
                    }
                }(a, S, b, b[11], b[c + 1], b[c + 1] = function By(e, t, n) {
                    if (null == n || "" === n) return gn;
                    const i = [], a = ws(n);
                    if (Array.isArray(a)) for (let c = 0; c < a.length; c++) e(i, a[c], !0); else if ("object" == typeof a) for (const c in a) a.hasOwnProperty(c) && e(i, c, a[c]); else "string" == typeof a && t(i, a);
                    return i
                }(e, t, n), i, c)
            }
        }

        function xh(e, t) {
            return t >= e.expandoStartIndex
        }

        function wh(e, t, n, i) {
            const a = e.data;
            if (null === a[n + 1]) {
                const c = a[o()], b = xh(e, n);
                Sh(c, i) && null === t && !b && (t = !1), t = function Ny(e, t, n, i) {
                    const a = function we(e) {
                        const t = _e.lFrame.currentDirectiveIndex;
                        return -1 === t ? null : e[t]
                    }(e);
                    let c = i ? t.residualClasses : t.residualStyles;
                    if (null === a) 0 === (i ? t.classBindings : t.styleBindings) && (n = Jo(n = Mc(null, e, t, n, i), t.attrs, i), c = null); else {
                        const b = t.directiveStylingLast;
                        if (-1 === b || e[b] !== a) if (n = Mc(a, e, t, n, i), null === c) {
                            let k = function ky(e, t, n) {
                                const i = n ? t.classBindings : t.styleBindings;
                                if (0 !== Es(i)) return e[Qi(i)]
                            }(e, t, i);
                            void 0 !== k && Array.isArray(k) && (k = Mc(null, e, t, k[1], i), k = Jo(k, t.attrs, i), function Fy(e, t, n, i) {
                                e[Qi(n ? t.classBindings : t.styleBindings)] = i
                            }(e, t, i, k))
                        } else c = function Ly(e, t, n) {
                            let i;
                            const a = t.directiveEnd;
                            for (let c = 1 + t.directiveStylingLast; c < a; c++) i = Jo(i, e[c].hostAttrs, n);
                            return Jo(i, t.attrs, n)
                        }(e, t, i)
                    }
                    return void 0 !== c && (i ? t.residualClasses = c : t.residualStyles = c), n
                }(a, c, t, i), function Cy(e, t, n, i, a, c) {
                    let b = c ? t.classBindings : t.styleBindings, S = Qi(b), k = Es(b);
                    e[i] = n;
                    let Se, pe = !1;
                    if (Array.isArray(n)) {
                        const et = n;
                        Se = et[1], (null === Se || Xs(et, Se) > 0) && (pe = !0)
                    } else Se = n;
                    if (a) if (0 !== k) {
                        const St = Qi(e[S + 1]);
                        e[i + 1] = Pa(St, S), 0 !== St && (e[St + 1] = Vl(e[St + 1], i)), e[S + 1] = function Bm(e, t) {
                            return 131071 & e | t << 17
                        }(e[S + 1], i)
                    } else e[i + 1] = Pa(S, 0), 0 !== S && (e[S + 1] = Vl(e[S + 1], i)), S = i; else e[i + 1] = Pa(k, 0), 0 === S ? S = i : e[k + 1] = Vl(e[k + 1], i), k = i;
                    pe && (e[i + 1] = $l(e[i + 1])), dh(e, Se, i, !0), dh(e, Se, i, !1), function Sy(e, t, n, i, a) {
                        const c = a ? e.residualClasses : e.residualStyles;
                        null != c && "string" == typeof t && Xs(c, t) >= 0 && (n[i + 1] = Ul(n[i + 1]))
                    }(t, Se, e, i, c), b = Pa(S, k), c ? t.classBindings = b : t.styleBindings = b
                }(a, c, t, n, b, i)
            }
        }

        function Mc(e, t, n, i, a) {
            let c = null;
            const b = n.directiveEnd;
            let S = n.directiveStylingLast;
            for (-1 === S ? S = n.directiveStart : S++; S < b && (c = t[S], i = Jo(i, c.hostAttrs, a), c !== e);) S++;
            return null !== e && (n.directiveStylingLast = S), i
        }

        function Jo(e, t, n) {
            const i = n ? 1 : 2;
            let a = -1;
            if (null !== t) for (let c = 0; c < t.length; c++) {
                const b = t[c];
                "number" == typeof b ? a = b : a === i && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), Gi(e, b, !!n || t[++c]))
            }
            return void 0 === e ? null : e
        }

        function Eh(e, t, n) {
            Gi(e, t, ws(n))
        }

        function _h(e, t, n, i, a, c, b, S) {
            if (!(3 & t.type)) return;
            const k = e.data, pe = k[S + 1];
            ja(function Od(e) {
                return 1 == (1 & e)
            }(pe) ? Ch(k, t, n, a, Es(pe), b) : void 0) || (ja(c) || function Pd(e) {
                return 2 == (2 & e)
            }(pe) && (c = Ch(k, null, n, a, S, b)), function Dm(e, t, n, i, a) {
                const c = mt(e);
                if (t) a ? c ? e.addClass(n, i) : n.classList.add(i) : c ? e.removeClass(n, i) : n.classList.remove(i); else {
                    let b = -1 === i.indexOf("-") ? void 0 : ps.DashCase;
                    if (null == a) c ? e.removeStyle(n, i, b) : n.style.removeProperty(i); else {
                        const S = "string" == typeof a && a.endsWith("!important");
                        S && (a = a.slice(0, -10), b |= ps.Important), c ? e.setStyle(n, i, a, b) : n.style.setProperty(i, a, S ? "important" : "")
                    }
                }
            }(i, b, hr(o(), n), a, c))
        }

        function Ch(e, t, n, i, a, c) {
            const b = null === t;
            let S;
            for (; a > 0;) {
                const k = e[a], pe = Array.isArray(k), Se = pe ? k[1] : k, et = null === Se;
                let St = n[a + 1];
                St === pr && (St = et ? gn : void 0);
                let $t = et ? dl(St, i) : Se === i ? St : void 0;
                if (pe && !ja($t) && ($t = dl(k, i)), ja($t) && (S = $t, b)) return S;
                const tn = e[a + 1];
                a = b ? Qi(tn) : Es(tn)
            }
            if (null !== t) {
                let k = c ? t.residualClasses : t.residualStyles;
                null != k && (S = dl(k, i))
            }
            return S
        }

        function ja(e) {
            return void 0 !== e
        }

        function Sh(e, t) {
            return 0 != (e.flags & (t ? 16 : 32))
        }

        function Dh(e, t = "") {
            const n = Lt(), i = In(), a = e + 20, c = i.firstCreatePass ? no(i, a, 1, t, null) : i.data[a],
                b = n[a] = function Pl(e, t) {
                    return mt(e) ? e.createText(t) : e.createTextNode(t)
                }(n[11], t);
            Ma(i, n, b, c), Kr(c, !1)
        }

        function Ic(e) {
            return Ya("", e, ""), Ic
        }

        function Ya(e, t, n) {
            const i = Lt(), a = co(i, e, t, n);
            return a !== pr && _s(i, o(), a), Ya
        }

        function kh(e, t, n) {
            is(Gi, vs, co(Lt(), e, t, n), !0)
        }

        const Gs = void 0;
        var sb = ["en", [["a", "p"], ["AM", "PM"], Gs], [["AM", "PM"], Gs, Gs], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Gs, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Gs, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Gs, "{1} 'at' {0}", Gs], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function ib(e) {
            const n = Math.floor(Math.abs(e)), i = e.toString().replace(/^[^.]*\.?/, "").length;
            return 1 === n && 0 === i ? 1 : 5
        }];
        let xo = {};

        function Pc(e) {
            const t = function ob(e) {
                return e.toLowerCase().replace(/_/g, "-")
            }(e);
            let n = Kh(t);
            if (n) return n;
            const i = t.split("-")[0];
            if (n = Kh(i), n) return n;
            if ("en" === i) return sb;
            throw new Error(`Missing locale data for the locale "${e}".`)
        }

        function Wh(e) {
            return Pc(e)[or.PluralCase]
        }

        function Kh(e) {
            return e in xo || (xo[e] = Ht.ng && Ht.ng.common && Ht.ng.common.locales && Ht.ng.common.locales[e]), xo[e]
        }

        var or = (() => ((or = or || {})[or.LocaleId = 0] = "LocaleId", or[or.DayPeriodsFormat = 1] = "DayPeriodsFormat", or[or.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", or[or.DaysFormat = 3] = "DaysFormat", or[or.DaysStandalone = 4] = "DaysStandalone", or[or.MonthsFormat = 5] = "MonthsFormat", or[or.MonthsStandalone = 6] = "MonthsStandalone", or[or.Eras = 7] = "Eras", or[or.FirstDayOfWeek = 8] = "FirstDayOfWeek", or[or.WeekendRange = 9] = "WeekendRange", or[or.DateFormat = 10] = "DateFormat", or[or.TimeFormat = 11] = "TimeFormat", or[or.DateTimeFormat = 12] = "DateTimeFormat", or[or.NumberSymbols = 13] = "NumberSymbols", or[or.NumberFormats = 14] = "NumberFormats", or[or.CurrencyCode = 15] = "CurrencyCode", or[or.CurrencySymbol = 16] = "CurrencySymbol", or[or.CurrencyName = 17] = "CurrencyName", or[or.Currencies = 18] = "Currencies", or[or.Directionality = 19] = "Directionality", or[or.PluralCase = 20] = "PluralCase", or[or.ExtraData = 21] = "ExtraData", or))();
        const Wa = "en-US";
        let qh = Wa;

        function Nc(e, t, n, i, a) {
            if (e = ge(e), Array.isArray(e)) for (let c = 0; c < e.length; c++) Nc(e[c], t, n, i, a); else {
                const c = In(), b = Lt();
                let S = oo(e) ? e : ge(e.provide), k = ff(e);
                const pe = dr(), Se = 1048575 & pe.providerIndexes, et = pe.directiveStart,
                    St = pe.providerIndexes >> 20;
                if (oo(e) || !e.multi) {
                    const $t = new sr(k, a, Zo), tn = Fc(S, t, a ? Se : Se + St, et);
                    -1 === tn ? (Bs(Fs(pe, b), c, S), kc(c, e, t.length), t.push(S), pe.directiveStart++, pe.directiveEnd++, a && (pe.providerIndexes += 1048576), n.push($t), b.push($t)) : (n[tn] = $t, b[tn] = $t)
                } else {
                    const $t = Fc(S, t, Se + St, et), tn = Fc(S, t, Se, Se + St), Tn = $t >= 0 && n[$t],
                        Rn = tn >= 0 && n[tn];
                    if (a && !Rn || !a && !Tn) {
                        Bs(Fs(pe, b), c, S);
                        const Gn = function ix(e, t, n, i, a) {
                            const c = new sr(e, n, Zo);
                            return c.multi = [], c.index = t, c.componentProviders = 0, bp(c, a, i && !n), c
                        }(a ? rx : nx, n.length, a, i, k);
                        !a && Rn && (n[tn].providerFactory = Gn), kc(c, e, t.length, 0), t.push(S), pe.directiveStart++, pe.directiveEnd++, a && (pe.providerIndexes += 1048576), n.push(Gn), b.push(Gn)
                    } else kc(c, e, $t > -1 ? $t : tn, bp(n[a ? tn : $t], k, !a && i));
                    !a && i && Rn && n[tn].componentProviders++
                }
            }
        }

        function kc(e, t, n, i) {
            const a = oo(t), c = function Pv(e) {
                return !!e.useClass
            }(t);
            if (a || c) {
                const k = (c ? ge(t.useClass) : t).prototype.ngOnDestroy;
                if (k) {
                    const pe = e.destroyHooks || (e.destroyHooks = []);
                    if (!a && t.multi) {
                        const Se = pe.indexOf(n);
                        -1 === Se ? pe.push(n, [i, k]) : pe[Se + 1].push(i, k)
                    } else pe.push(n, k)
                }
            }
        }

        function bp(e, t, n) {
            return n && e.componentProviders++, e.multi.push(t) - 1
        }

        function Fc(e, t, n, i) {
            for (let a = n; a < i; a++) if (t[a] === e) return a;
            return -1
        }

        function nx(e, t, n, i) {
            return Lc(this.multi, [])
        }

        function rx(e, t, n, i) {
            const a = this.multi;
            let c;
            if (this.providerFactory) {
                const b = this.providerFactory.componentProviders, S = $s(n, n[1], this.providerFactory.index, i);
                c = S.slice(0, b), Lc(a, c);
                for (let k = b; k < S.length; k++) c.push(S[k])
            } else c = [], Lc(a, c);
            return c
        }

        function Lc(e, t) {
            for (let n = 0; n < e.length; n++) t.push((0, e[n])());
            return t
        }

        function xp(e, t = []) {
            return n => {
                n.providersResolver = (i, a) => function tx(e, t, n) {
                    const i = In();
                    if (i.firstCreatePass) {
                        const a = xr(e);
                        Nc(n, i.data, i.blueprint, a, !0), Nc(t, i.data, i.blueprint, a, !1)
                    }
                }(i, a ? a(e) : e, t)
            }
        }

        class wp {
        }

        class ax {
            resolveComponentFactory(t) {
                throw function ox(e) {
                    const t = Error(`No component factory found for ${M(e)}. Did you add it to @NgModule.entryComponents?`);
                    return t.ngComponent = e, t
                }(t)
            }
        }

        let Ja = (() => {
            class e {
            }

            return e.NULL = new ax, e
        })();

        function lx() {
            return Eo(dr(), Lt())
        }

        function Eo(e, t) {
            return new ra(ir(e, t))
        }

        let ra = (() => {
            class e {
                constructor(n) {
                    this.nativeElement = n
                }
            }

            return e.__NG_ELEMENT_ID__ = lx, e
        })();

        function cx(e) {
            return e instanceof ra ? e.nativeElement : e
        }

        class _p {
        }

        let ux = (() => {
            class e {
            }

            return e.__NG_ELEMENT_ID__ = () => function fx() {
                const e = Lt(), n = Or(dr().index, e);
                return function dx(e) {
                    return e[11]
                }(Zt(n) ? n : e)
            }(), e
        })(), hx = (() => {
            class e {
            }

            return e.\u0275prov = Ye({token: e, providedIn: "root", factory: () => null}), e
        })();

        class Cp {
            constructor(t) {
                this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".")
            }
        }

        const px = new Cp("13.2.7"), Bc = {};

        function Qa(e, t, n, i, a = !1) {
            for (; null !== n;) {
                const c = t[n.index];
                if (null !== c && i.push(vn(c)), hn(c)) for (let S = 10; S < c.length; S++) {
                    const k = c[S], pe = k[1].firstChild;
                    null !== pe && Qa(k[1], k, pe, i)
                }
                const b = n.type;
                if (8 & b) Qa(e, t, n.child, i); else if (32 & b) {
                    const S = Al(n, t);
                    let k;
                    for (; k = S();) i.push(k)
                } else if (16 & b) {
                    const S = bd(t, n);
                    if (Array.isArray(S)) i.push(...S); else {
                        const k = Go(t[16]);
                        Qa(k[1], k, S, i, !0)
                    }
                }
                n = a ? n.projectionNext : n.next
            }
            return i
        }

        class ia {
            constructor(t, n) {
                this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1
            }

            get rootNodes() {
                const t = this._lView, n = t[1];
                return Qa(n, t, n.firstChild, [])
            }

            get context() {
                return this._lView[8]
            }

            set context(t) {
                this._lView[8] = t
            }

            get destroyed() {
                return 256 == (256 & this._lView[2])
            }

            destroy() {
                if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) {
                    const t = this._lView[3];
                    if (hn(t)) {
                        const n = t[8], i = n ? n.indexOf(this) : -1;
                        i > -1 && (Rl(t, i), ba(n, i))
                    }
                    this._attachedToViewContainer = !1
                }
                ud(this._lView[1], this._lView)
            }

            onDestroy(t) {
                Yd(this._lView[1], this._lView, null, t)
            }

            markForCheck() {
                nc(this._cdRefInjectingView || this._lView)
            }

            detach() {
                this._lView[2] &= -129
            }

            reattach() {
                this._lView[2] |= 128
            }

            detectChanges() {
                ic(this._lView[1], this._lView, this.context)
            }

            checkNoChanges() {
                !function xv(e, t, n) {
                    s(!0);
                    try {
                        ic(e, t, n)
                    } finally {
                        s(!1)
                    }
                }(this._lView[1], this._lView, this.context)
            }

            attachToViewContainerRef() {
                if (this._appRef) throw new xe(902, "");
                this._attachedToViewContainer = !0
            }

            detachFromAppRef() {
                this._appRef = null, function mm(e, t) {
                    jo(e, t, t[11], 2, null, null)
                }(this._lView[1], this._lView)
            }

            attachToAppRef(t) {
                if (this._attachedToViewContainer) throw new xe(902, "");
                this._appRef = t
            }
        }

        class gx extends ia {
            constructor(t) {
                super(t), this._view = t
            }

            detectChanges() {
                tf(this._view)
            }

            checkNoChanges() {
                !function wv(e) {
                    s(!0);
                    try {
                        tf(e)
                    } finally {
                        s(!1)
                    }
                }(this._view)
            }

            get context() {
                return null
            }
        }

        class Sp extends Ja {
            constructor(t) {
                super(), this.ngModule = t
            }

            resolveComponentFactory(t) {
                const n = Ut(t);
                return new $c(n, this.ngModule)
            }
        }

        function Dp(e) {
            const t = [];
            for (let n in e) e.hasOwnProperty(n) && t.push({propName: e[n], templateName: n});
            return t
        }

        class $c extends wp {
            constructor(t, n) {
                super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function Fm(e) {
                    return e.map(km).join(",")
                }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n
            }

            get inputs() {
                return Dp(this.componentDef.inputs)
            }

            get outputs() {
                return Dp(this.componentDef.outputs)
            }

            create(t, n, i, a) {
                const c = (a = a || this.ngModule) ? function vx(e, t) {
                        return {
                            get: (n, i, a) => {
                                const c = e.get(n, Bc, a);
                                return c !== Bc || i === Bc ? c : t.get(n, i, a)
                            }
                        }
                    }(t, a.injector) : t, b = c.get(_p, Yt), S = c.get(hx, null),
                    k = b.createRenderer(null, this.componentDef), pe = this.componentDef.selectors[0][0] || "div",
                    Se = i ? function jd(e, t, n) {
                        if (mt(e)) return e.selectRootElement(t, n === Dt.ShadowDom);
                        let i = "string" == typeof t ? e.querySelector(t) : t;
                        return i.textContent = "", i
                    }(k, i, this.componentDef.encapsulation) : Ol(b.createRenderer(null, this.componentDef), pe, function mx(e) {
                        const t = e.toLowerCase();
                        return "svg" === t ? "svg" : "math" === t ? "math" : null
                    }(pe)), et = this.componentDef.onPush ? 576 : 528, St = function Cf(e, t) {
                        return {components: [], scheduler: e || lm, clean: Ev, playerHandler: t || null, flags: 0}
                    }(), $t = Na(0, null, null, 1, 0, null, null, null, null, null),
                    tn = Yo(null, $t, St, et, null, null, b, k, S, c);
                let Tn, Rn;
                ot(tn);
                try {
                    const Gn = function Ef(e, t, n, i, a, c) {
                        const b = n[1];
                        n[20] = e;
                        const k = no(b, 20, 2, "#host", null), pe = k.mergedAttrs = t.hostAttrs;
                        null !== pe && (Fa(k, pe, !0), null !== e && (as(a, e, pe), null !== k.classes && Bl(a, e, k.classes), null !== k.styles && Ed(a, e, k.styles)));
                        const Se = i.createRenderer(e, t),
                            et = Yo(n, zd(t), null, t.onPush ? 64 : 16, n[20], k, i, Se, c || null, null);
                        return b.firstCreatePass && (Bs(Fs(k, n), b, t.type), Zd(b, k), Jd(k, n.length, 1)), ka(n, et), n[20] = et
                    }(Se, this.componentDef, tn, b, k);
                    if (Se) if (i) as(k, Se, ["ng-version", px.full]); else {
                        const {attrs: cn, classes: Jn} = function Lm(e) {
                            const t = [], n = [];
                            let i = 1, a = 2;
                            for (; i < e.length;) {
                                let c = e[i];
                                if ("string" == typeof c) 2 === a ? "" !== c && t.push(c, e[++i]) : 8 === a && n.push(c); else {
                                    if (!Ji(a)) break;
                                    a = c
                                }
                                i++
                            }
                            return {attrs: t, classes: n}
                        }(this.componentDef.selectors[0]);
                        cn && as(k, Se, cn), Jn && Jn.length > 0 && Bl(k, Se, Jn.join(" "))
                    }
                    if (Rn = yr($t, 20), void 0 !== n) {
                        const cn = Rn.projection = [];
                        for (let Jn = 0; Jn < this.ngContentSelectors.length; Jn++) {
                            const Sr = n[Jn];
                            cn.push(null != Sr ? Array.from(Sr) : null)
                        }
                    }
                    Tn = function _f(e, t, n, i, a) {
                        const c = n[1], b = function iv(e, t, n) {
                            const i = dr();
                            e.firstCreatePass && (n.providersResolver && n.providersResolver(n), Qd(e, i, t, ro(e, t, 1, null), n));
                            const a = $s(t, e, i.directiveStart, i);
                            Mi(a, t);
                            const c = ir(i, t);
                            return c && Mi(c, t), a
                        }(c, n, t);
                        if (i.components.push(b), e[8] = b, a && a.forEach(k => k(b, t)), t.contentQueries) {
                            const k = dr();
                            t.contentQueries(1, b, k.directiveStart)
                        }
                        const S = dr();
                        return !c.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (u(S.index), qd(n[1], S, 0, S.directiveStart, S.directiveEnd, t), Xd(t, b)), b
                    }(Gn, this.componentDef, tn, St, [Hv]), Wo($t, tn, null)
                } finally {
                    on()
                }
                return new bx(this.componentType, Tn, Eo(Rn, tn), tn, Rn)
            }
        }

        class bx extends class sx {
        } {
            constructor(t, n, i, a, c) {
                super(), this.location = i, this._rootLView = a, this._tNode = c, this.instance = n, this.hostView = this.changeDetectorRef = new gx(a), this.componentType = t
            }

            get injector() {
                return new Ms(this._tNode, this._rootLView)
            }

            destroy() {
                this.hostView.destroy()
            }

            onDestroy(t) {
                this.hostView.onDestroy(t)
            }
        }

        class _o {
        }

        class Tp {
        }

        const Co = new Map;

        class Ip extends _o {
            constructor(t, n) {
                super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Sp(this);
                const i = un(t);
                this._bootstrapComponents = hs(i.bootstrap), this._r3Injector = df(t, n, [{
                    provide: _o,
                    useValue: this
                }, {
                    provide: Ja,
                    useValue: this.componentFactoryResolver
                }], M(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t)
            }

            get(t, n = es.THROW_IF_NOT_FOUND, i = Me.Default) {
                return t === es || t === _o || t === oc ? this : this._r3Injector.get(t, n, i)
            }

            destroy() {
                const t = this._r3Injector;
                !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null
            }

            onDestroy(t) {
                this.destroyCbs.push(t)
            }
        }

        class Vc extends Tp {
            constructor(t) {
                super(), this.moduleType = t, null !== un(t) && function wx(e) {
                    const t = new Set;
                    !function n(i) {
                        const a = un(i, !0), c = a.id;
                        null !== c && (function Ap(e, t, n) {
                            if (t && t !== n) throw new Error(`Duplicate module registered for ${e} - ${M(t)} vs ${M(t.name)}`)
                        }(c, Co.get(c), i), Co.set(c, i));
                        const b = hs(a.imports);
                        for (const S of b) t.has(S) || (t.add(S), n(S))
                    }(e)
                }(t)
            }

            create(t) {
                return new Ip(this.moduleType, t)
            }
        }

        function Pp(e, t, n) {
            const i = _() + e, a = Lt();
            return a[i] === pr ? ms(a, i, n ? t.call(n) : t()) : function Xo(e, t) {
                return e[t]
            }(a, i)
        }

        function Op(e, t, n, i) {
            return Np(Lt(), _(), e, t, n, i)
        }

        function Rp(e, t, n, i, a, c) {
            return function Fp(e, t, n, i, a, c, b, S) {
                const k = t + n;
                return Ba(e, k, a, c, b) ? ms(e, k + 3, S ? i.call(S, a, c, b) : i(a, c, b)) : sa(e, k + 3)
            }(Lt(), _(), e, t, n, i, a, c)
        }

        function sa(e, t) {
            const n = e[t];
            return n === pr ? void 0 : n
        }

        function Np(e, t, n, i, a, c) {
            const b = t + n;
            return Ii(e, b, a) ? ms(e, b + 1, c ? i.call(c, a) : i(a)) : sa(e, b + 1)
        }

        function $p(e, t) {
            const n = In();
            let i;
            const a = e + 20;
            n.firstCreatePass ? (i = function Mx(e, t) {
                if (t) for (let n = t.length - 1; n >= 0; n--) {
                    const i = t[n];
                    if (e === i.name) return i
                }
            }(t, n.pipeRegistry), n.data[a] = i, i.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(a, i.onDestroy)) : i = n.data[a];
            const c = i.factory || (i.factory = Xr(i.type)), b = de(Zo);
            try {
                const S = di(!1), k = c();
                return di(S), function ey(e, t, n, i) {
                    n >= e.data.length && (e.data[n] = null, e.blueprint[n] = null), t[n] = i
                }(n, Lt(), a, k), k
            } finally {
                de(b)
            }
        }

        function Vp(e, t, n) {
            const i = e + 20, a = Lt(), c = Ar(a, i);
            return function oa(e, t) {
                return e[1].data[t].pure
            }(a, i) ? Np(a, _(), t, c.transform, n, c) : c.transform(n)
        }

        function Uc(e) {
            return t => {
                setTimeout(e, void 0, t)
            }
        }

        const ys = class Nx extends r.xQ {
            constructor(t = !1) {
                super(), this.__isAsync = t
            }

            emit(t) {
                super.next(t)
            }

            subscribe(t, n, i) {
                var a, c, b;
                let S = t, k = n || (() => null), pe = i;
                if (t && "object" == typeof t) {
                    const et = t;
                    S = null === (a = et.next) || void 0 === a ? void 0 : a.bind(et), k = null === (c = et.error) || void 0 === c ? void 0 : c.bind(et), pe = null === (b = et.complete) || void 0 === b ? void 0 : b.bind(et)
                }
                this.__isAsync && (k = Uc(k), S && (S = Uc(S)), pe && (pe = Uc(pe)));
                const Se = super.subscribe({next: S, error: k, complete: pe});
                return t instanceof D.w && t.add(Se), Se
            }
        };

        function kx() {
            return this._results[ao()]()
        }

        class Hc {
            constructor(t = !1) {
                this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0;
                const n = ao(), i = Hc.prototype;
                i[n] || (i[n] = kx)
            }

            get changes() {
                return this._changes || (this._changes = new ys)
            }

            get(t) {
                return this._results[t]
            }

            map(t) {
                return this._results.map(t)
            }

            filter(t) {
                return this._results.filter(t)
            }

            find(t) {
                return this._results.find(t)
            }

            reduce(t, n) {
                return this._results.reduce(t, n)
            }

            forEach(t) {
                this._results.forEach(t)
            }

            some(t) {
                return this._results.some(t)
            }

            toArray() {
                return this._results.slice()
            }

            toString() {
                return this._results.toString()
            }

            reset(t, n) {
                const i = this;
                i.dirty = !1;
                const a = yi(t);
                (this._changesDetected = !function ya(e, t, n) {
                    if (e.length !== t.length) return !1;
                    for (let i = 0; i < e.length; i++) {
                        let a = e[i], c = t[i];
                        if (n && (a = n(a), c = n(c)), c !== a) return !1
                    }
                    return !0
                }(i._results, a, n)) && (i._results = a, i.length = a.length, i.last = a[this.length - 1], i.first = a[0])
            }

            notifyOnChanges() {
                this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this)
            }

            setDirty() {
                this.dirty = !0
            }

            destroy() {
                this.changes.complete(), this.changes.unsubscribe()
            }
        }

        Symbol;
        let aa = (() => {
            class e {
            }

            return e.__NG_ELEMENT_ID__ = Bx, e
        })();
        const Fx = aa, Lx = class extends Fx {
            constructor(t, n, i) {
                super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = i
            }

            createEmbeddedView(t) {
                const n = this._declarationTContainer.tViews,
                    i = Yo(this._declarationLView, n, t, 16, null, n.declTNode, null, null, null, null);
                i[17] = this._declarationLView[this._declarationTContainer.index];
                const c = this._declarationLView[19];
                return null !== c && (i[19] = c.createEmbeddedView(n)), Wo(n, i, t), new ia(i)
            }
        };

        function Bx() {
            return el(dr(), Lt())
        }

        function el(e, t) {
            return 4 & e.type ? new Lx(t, e, Eo(e, t)) : null
        }

        let tl = (() => {
            class e {
            }

            return e.__NG_ELEMENT_ID__ = $x, e
        })();

        function $x() {
            return zp(dr(), Lt())
        }

        const Vx = tl, Up = class extends Vx {
            constructor(t, n, i) {
                super(), this._lContainer = t, this._hostTNode = n, this._hostLView = i
            }

            get element() {
                return Eo(this._hostTNode, this._hostLView)
            }

            get injector() {
                return new Ms(this._hostTNode, this._hostLView)
            }

            get parentInjector() {
                const t = Ls(this._hostTNode, this._hostLView);
                if (ua(t)) {
                    const n = Ts(t, this._hostLView), i = Ds(t);
                    return new Ms(n[1].data[i + 8], n)
                }
                return new Ms(null, this._hostLView)
            }

            clear() {
                for (; this.length > 0;) this.remove(this.length - 1)
            }

            get(t) {
                const n = Hp(this._lContainer);
                return null !== n && n[t] || null
            }

            get length() {
                return this._lContainer.length - 10
            }

            createEmbeddedView(t, n, i) {
                const a = t.createEmbeddedView(n || {});
                return this.insert(a, i), a
            }

            createComponent(t, n, i, a, c) {
                const b = t && !function zi(e) {
                    return "function" == typeof e
                }(t);
                let S;
                if (b) S = n; else {
                    const et = n || {};
                    S = et.index, i = et.injector, a = et.projectableNodes, c = et.ngModuleRef
                }
                const k = b ? t : new $c(Ut(t)), pe = i || this.parentInjector;
                if (!c && null == k.ngModule) {
                    const St = (b ? pe : this.parentInjector).get(_o, null);
                    St && (c = St)
                }
                const Se = k.create(pe, a, void 0, c);
                return this.insert(Se.hostView, S), Se
            }

            insert(t, n) {
                const i = t._lView, a = i[1];
                if (function jr(e) {
                    return hn(e[3])
                }(i)) {
                    const Se = this.indexOf(t);
                    if (-1 !== Se) this.detach(Se); else {
                        const et = i[3], St = new Up(et, et[6], et[3]);
                        St.detach(St.indexOf(t))
                    }
                }
                const c = this._adjustIndex(n), b = this._lContainer;
                !function ym(e, t, n, i) {
                    const a = 10 + i, c = n.length;
                    i > 0 && (n[a - 1][4] = t), i < c - 10 ? (t[4] = n[a], Su(n, 10 + i, t)) : (n.push(t), t[4] = null), t[3] = n;
                    const b = t[17];
                    null !== b && n !== b && function bm(e, t) {
                        const n = e[9];
                        t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t)
                    }(b, t);
                    const S = t[19];
                    null !== S && S.insertView(e), t[2] |= 128
                }(a, i, b, c);
                const S = Fl(c, b), k = i[11], pe = Aa(k, b[7]);
                return null !== pe && function gm(e, t, n, i, a, c) {
                    i[0] = a, i[6] = t, jo(e, i, n, 1, a, c)
                }(a, b[6], k, i, pe, S), t.attachToViewContainerRef(), Su(zc(b), c, t), t
            }

            move(t, n) {
                return this.insert(t, n)
            }

            indexOf(t) {
                const n = Hp(this._lContainer);
                return null !== n ? n.indexOf(t) : -1
            }

            remove(t) {
                const n = this._adjustIndex(t, -1), i = Rl(this._lContainer, n);
                i && (ba(zc(this._lContainer), n), ud(i[1], i))
            }

            detach(t) {
                const n = this._adjustIndex(t, -1), i = Rl(this._lContainer, n);
                return i && null != ba(zc(this._lContainer), n) ? new ia(i) : null
            }

            _adjustIndex(t, n = 0) {
                return null == t ? this.length + n : t
            }
        };

        function Hp(e) {
            return e[8]
        }

        function zc(e) {
            return e[8] || (e[8] = [])
        }

        function zp(e, t) {
            let n;
            const i = t[e.index];
            if (hn(i)) n = i; else {
                let a;
                if (8 & e.type) a = vn(i); else {
                    const c = t[11];
                    a = c.createComment("");
                    const b = ir(e, t);
                    Hs(c, Aa(c, b), a, function _m(e, t) {
                        return mt(e) ? e.nextSibling(t) : t.nextSibling
                    }(c, b), !1)
                }
                t[e.index] = n = ef(i, t, a, e), ka(t, n)
            }
            return new Up(n, e, t)
        }

        class Gc {
            constructor(t) {
                this.queryList = t, this.matches = null
            }

            clone() {
                return new Gc(this.queryList)
            }

            setDirty() {
                this.queryList.setDirty()
            }
        }

        class jc {
            constructor(t = []) {
                this.queries = t
            }

            createEmbeddedView(t) {
                const n = t.queries;
                if (null !== n) {
                    const i = null !== t.contentQueries ? t.contentQueries[0] : n.length, a = [];
                    for (let c = 0; c < i; c++) {
                        const b = n.getByIndex(c);
                        a.push(this.queries[b.indexInDeclarationView].clone())
                    }
                    return new jc(a)
                }
                return null
            }

            insertView(t) {
                this.dirtyQueriesWithMatches(t)
            }

            detachView(t) {
                this.dirtyQueriesWithMatches(t)
            }

            dirtyQueriesWithMatches(t) {
                for (let n = 0; n < this.queries.length; n++) null !== Jp(t, n).matches && this.queries[n].setDirty()
            }
        }

        class Gp {
            constructor(t, n, i = null) {
                this.predicate = t, this.flags = n, this.read = i
            }
        }

        class Yc {
            constructor(t = []) {
                this.queries = t
            }

            elementStart(t, n) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(t, n)
            }

            elementEnd(t) {
                for (let n = 0; n < this.queries.length; n++) this.queries[n].elementEnd(t)
            }

            embeddedTView(t) {
                let n = null;
                for (let i = 0; i < this.length; i++) {
                    const a = null !== n ? n.length : 0, c = this.getByIndex(i).embeddedTView(t, a);
                    c && (c.indexInDeclarationView = i, null !== n ? n.push(c) : n = [c])
                }
                return null !== n ? new Yc(n) : null
            }

            template(t, n) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].template(t, n)
            }

            getByIndex(t) {
                return this.queries[t]
            }

            get length() {
                return this.queries.length
            }

            track(t) {
                this.queries.push(t)
            }
        }

        class Wc {
            constructor(t, n = -1) {
                this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n
            }

            elementStart(t, n) {
                this.isApplyingToNode(n) && this.matchTNode(t, n)
            }

            elementEnd(t) {
                this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1)
            }

            template(t, n) {
                this.elementStart(t, n)
            }

            embeddedTView(t, n) {
                return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, n), new Wc(this.metadata)) : null
            }

            isApplyingToNode(t) {
                if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
                    const n = this._declarationNodeIndex;
                    let i = t.parent;
                    for (; null !== i && 8 & i.type && i.index !== n;) i = i.parent;
                    return n === (null !== i ? i.index : -1)
                }
                return this._appliesToNextNode
            }

            matchTNode(t, n) {
                const i = this.metadata.predicate;
                if (Array.isArray(i)) for (let a = 0; a < i.length; a++) {
                    const c = i[a];
                    this.matchTNodeWithReadOption(t, n, zx(n, c)), this.matchTNodeWithReadOption(t, n, qs(n, t, c, !1, !1))
                } else i === aa ? 4 & n.type && this.matchTNodeWithReadOption(t, n, -1) : this.matchTNodeWithReadOption(t, n, qs(n, t, i, !1, !1))
            }

            matchTNodeWithReadOption(t, n, i) {
                if (null !== i) {
                    const a = this.metadata.read;
                    if (null !== a) if (a === ra || a === tl || a === aa && 4 & n.type) this.addMatch(n.index, -2); else {
                        const c = qs(n, t, a, !1, !1);
                        null !== c && this.addMatch(n.index, c)
                    } else this.addMatch(n.index, i)
                }
            }

            addMatch(t, n) {
                null === this.matches ? this.matches = [t, n] : this.matches.push(t, n)
            }
        }

        function zx(e, t) {
            const n = e.localNames;
            if (null !== n) for (let i = 0; i < n.length; i += 2) if (n[i] === t) return n[i + 1];
            return null
        }

        function jx(e, t, n, i) {
            return -1 === n ? function Gx(e, t) {
                return 11 & e.type ? Eo(e, t) : 4 & e.type ? el(e, t) : null
            }(t, e) : -2 === n ? function Yx(e, t, n) {
                return n === ra ? Eo(t, e) : n === aa ? el(t, e) : n === tl ? zp(t, e) : void 0
            }(e, t, i) : $s(e, e[1], n, t)
        }

        function jp(e, t, n, i) {
            const a = t[19].queries[i];
            if (null === a.matches) {
                const c = e.data, b = n.matches, S = [];
                for (let k = 0; k < b.length; k += 2) {
                    const pe = b[k];
                    S.push(pe < 0 ? null : jx(t, c[pe], b[k + 1], n.metadata.read))
                }
                a.matches = S
            }
            return a.matches
        }

        function Kc(e, t, n, i) {
            const a = e.queries.getByIndex(n), c = a.matches;
            if (null !== c) {
                const b = jp(e, t, a, n);
                for (let S = 0; S < c.length; S += 2) {
                    const k = c[S];
                    if (k > 0) i.push(b[S / 2]); else {
                        const pe = c[S + 1], Se = t[-k];
                        for (let et = 10; et < Se.length; et++) {
                            const St = Se[et];
                            St[17] === St[3] && Kc(St[1], St, pe, i)
                        }
                        if (null !== Se[9]) {
                            const et = Se[9];
                            for (let St = 0; St < et.length; St++) {
                                const $t = et[St];
                                Kc($t[1], $t, pe, i)
                            }
                        }
                    }
                }
            }
            return i
        }

        function Yp(e) {
            const t = Lt(), n = In(), i = nt();
            pt(i + 1);
            const a = Jp(n, i);
            if (e.dirty && Pr(t) === (2 == (2 & a.metadata.flags))) {
                if (null === a.matches) e.reset([]); else {
                    const c = a.crossesNgTemplate ? Kc(n, t, i, []) : jp(n, t, a, i);
                    e.reset(c, cx), e.notifyOnChanges()
                }
                return !0
            }
            return !1
        }

        function Wp(e, t, n) {
            const i = In();
            i.firstCreatePass && (Zp(i, new Gp(e, t, n), -1), 2 == (2 & t) && (i.staticViewQueries = !0)), Xp(i, Lt(), t)
        }

        function Kp(e, t, n, i) {
            const a = In();
            if (a.firstCreatePass) {
                const c = dr();
                Zp(a, new Gp(t, n, i), c.index), function Kx(e, t) {
                    const n = e.contentQueries || (e.contentQueries = []);
                    t !== (n.length ? n[n.length - 1] : -1) && n.push(e.queries.length - 1, t)
                }(a, e), 2 == (2 & n) && (a.staticContentQueries = !0)
            }
            Xp(a, Lt(), n)
        }

        function qp() {
            return function Wx(e, t) {
                return e[19].queries[t].queryList
            }(Lt(), nt())
        }

        function Xp(e, t, n) {
            const i = new Hc(4 == (4 & n));
            Yd(e, t, i, i.destroy), null === t[19] && (t[19] = new jc), t[19].queries.push(new Gc(i))
        }

        function Zp(e, t, n) {
            null === e.queries && (e.queries = new Yc), e.queries.track(new Wc(t, n))
        }

        function Jp(e, t) {
            return e.queries.getByIndex(t)
        }

        function Qp(e, t) {
            return el(e, t)
        }

        function il(...e) {
        }

        const v0 = new L("Application Initializer");
        let eu = (() => {
            class e {
                constructor(n) {
                    this.appInits = n, this.resolve = il, this.reject = il, this.initialized = !1, this.done = !1, this.donePromise = new Promise((i, a) => {
                        this.resolve = i, this.reject = a
                    })
                }

                runInitializers() {
                    if (this.initialized) return;
                    const n = [], i = () => {
                        this.done = !0, this.resolve()
                    };
                    if (this.appInits) for (let a = 0; a < this.appInits.length; a++) {
                        const c = this.appInits[a]();
                        if (Cc(c)) n.push(c); else if (Xf(c)) {
                            const b = new Promise((S, k) => {
                                c.subscribe({complete: S, error: k})
                            });
                            n.push(b)
                        }
                    }
                    Promise.all(n).then(() => {
                        i()
                    }).catch(a => {
                        this.reject(a)
                    }), 0 === n.length && i(), this.initialized = !0
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)(bi(v0, 8))
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac, providedIn: "root"}), e
        })();
        const y0 = new L("AppId", {
            providedIn: "root", factory: function b0() {
                return `${tu()}${tu()}${tu()}`
            }
        });

        function tu() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()))
        }

        const x0 = new L("Platform Initializer"), w0 = new L("Platform ID"), E0 = new L("appBootstrapListener");
        let _0 = (() => {
            class e {
                log(n) {
                    console.log(n)
                }

                warn(n) {
                    console.warn(n)
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac}), e
        })();
        const nu = new L("LocaleId", {
            providedIn: "root",
            factory: () => rg(nu, Me.Optional | Me.SkipSelf) || function d1() {
                return "undefined" != typeof $localize && $localize.locale || Wa
            }()
        }), f1 = new L("DefaultCurrencyCode", {providedIn: "root", factory: () => "USD"});

        class h1 {
            constructor(t, n) {
                this.ngModuleFactory = t, this.componentFactories = n
            }
        }

        let p1 = (() => {
            class e {
                compileModuleSync(n) {
                    return new Vc(n)
                }

                compileModuleAsync(n) {
                    return Promise.resolve(this.compileModuleSync(n))
                }

                compileModuleAndAllComponentsSync(n) {
                    const i = this.compileModuleSync(n), c = hs(un(n).declarations).reduce((b, S) => {
                        const k = Ut(S);
                        return k && b.push(new $c(k)), b
                    }, []);
                    return new h1(i, c)
                }

                compileModuleAndAllComponentsAsync(n) {
                    return Promise.resolve(this.compileModuleAndAllComponentsSync(n))
                }

                clearCache() {
                }

                clearCacheFor(n) {
                }

                getModuleId(n) {
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac, providedIn: "root"}), e
        })();
        const m1 = (() => Promise.resolve(0))();

        function ru(e) {
            "undefined" == typeof Zone ? m1.then(() => {
                e && e.apply(null, null)
            }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e)
        }

        class ss {
            constructor({
                            enableLongStackTrace: t = !1,
                            shouldCoalesceEventChangeDetection: n = !1,
                            shouldCoalesceRunChangeDetection: i = !1
                        }) {
                if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ys(!1), this.onMicrotaskEmpty = new ys(!1), this.onStable = new ys(!1), this.onError = new ys(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched();
                const a = this;
                a._nesting = 0, a._outer = a._inner = Zone.current, Zone.TaskTrackingZoneSpec && (a._inner = a._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (a._inner = a._inner.fork(Zone.longStackTraceZoneSpec)), a.shouldCoalesceEventChangeDetection = !i && n, a.shouldCoalesceRunChangeDetection = i, a.lastRequestAnimationFrameId = -1, a.nativeRequestAnimationFrame = function v1() {
                    let e = Ht.requestAnimationFrame, t = Ht.cancelAnimationFrame;
                    if ("undefined" != typeof Zone && e && t) {
                        const n = e[Zone.__symbol__("OriginalDelegate")];
                        n && (e = n);
                        const i = t[Zone.__symbol__("OriginalDelegate")];
                        i && (t = i)
                    }
                    return {nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t}
                }().nativeRequestAnimationFrame, function x1(e) {
                    const t = () => {
                        !function b1(e) {
                            e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(Ht, () => {
                                e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
                                    e.lastRequestAnimationFrameId = -1, su(e), e.isCheckStableRunning = !0, iu(e), e.isCheckStableRunning = !1
                                }, void 0, () => {
                                }, () => {
                                })), e.fakeTopEventTask.invoke()
                            }), su(e))
                        }(e)
                    };
                    e._inner = e._inner.fork({
                        name: "angular",
                        properties: {isAngularZone: !0},
                        onInvokeTask: (n, i, a, c, b, S) => {
                            try {
                                return C0(e), n.invokeTask(a, c, b, S)
                            } finally {
                                (e.shouldCoalesceEventChangeDetection && "eventTask" === c.type || e.shouldCoalesceRunChangeDetection) && t(), S0(e)
                            }
                        },
                        onInvoke: (n, i, a, c, b, S, k) => {
                            try {
                                return C0(e), n.invoke(a, c, b, S, k)
                            } finally {
                                e.shouldCoalesceRunChangeDetection && t(), S0(e)
                            }
                        },
                        onHasTask: (n, i, a, c) => {
                            n.hasTask(a, c), i === a && ("microTask" == c.change ? (e._hasPendingMicrotasks = c.microTask, su(e), iu(e)) : "macroTask" == c.change && (e.hasPendingMacrotasks = c.macroTask))
                        },
                        onHandleError: (n, i, a, c) => (n.handleError(a, c), e.runOutsideAngular(() => e.onError.emit(c)), !1)
                    })
                }(a)
            }

            static isInAngularZone() {
                return "undefined" != typeof Zone && !0 === Zone.current.get("isAngularZone")
            }

            static assertInAngularZone() {
                if (!ss.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!")
            }

            static assertNotInAngularZone() {
                if (ss.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!")
            }

            run(t, n, i) {
                return this._inner.run(t, n, i)
            }

            runTask(t, n, i, a) {
                const c = this._inner, b = c.scheduleEventTask("NgZoneEvent: " + a, t, y1, il, il);
                try {
                    return c.runTask(b, n, i)
                } finally {
                    c.cancelTask(b)
                }
            }

            runGuarded(t, n, i) {
                return this._inner.runGuarded(t, n, i)
            }

            runOutsideAngular(t) {
                return this._outer.run(t)
            }
        }

        const y1 = {};

        function iu(e) {
            if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try {
                e._nesting++, e.onMicrotaskEmpty.emit(null)
            } finally {
                if (e._nesting--, !e.hasPendingMicrotasks) try {
                    e.runOutsideAngular(() => e.onStable.emit(null))
                } finally {
                    e.isStable = !0
                }
            }
        }

        function su(e) {
            e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId)
        }

        function C0(e) {
            e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null))
        }

        function S0(e) {
            e._nesting--, iu(e)
        }

        class w1 {
            constructor() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ys, this.onMicrotaskEmpty = new ys, this.onStable = new ys, this.onError = new ys
            }

            run(t, n, i) {
                return t.apply(n, i)
            }

            runGuarded(t, n, i) {
                return t.apply(n, i)
            }

            runOutsideAngular(t) {
                return t()
            }

            runTask(t, n, i, a) {
                return t.apply(n, i)
            }
        }

        let D0 = (() => {
            class e {
                constructor(n) {
                    this._ngZone = n, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), n.run(() => {
                        this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone")
                    })
                }

                _watchAngularEvents() {
                    this._ngZone.onUnstable.subscribe({
                        next: () => {
                            this._didWork = !0, this._isZoneStable = !1
                        }
                    }), this._ngZone.runOutsideAngular(() => {
                        this._ngZone.onStable.subscribe({
                            next: () => {
                                ss.assertNotInAngularZone(), ru(() => {
                                    this._isZoneStable = !0, this._runCallbacksIfReady()
                                })
                            }
                        })
                    })
                }

                increasePendingRequestCount() {
                    return this._pendingCount += 1, this._didWork = !0, this._pendingCount
                }

                decreasePendingRequestCount() {
                    if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                    return this._runCallbacksIfReady(), this._pendingCount
                }

                isStable() {
                    return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
                }

                _runCallbacksIfReady() {
                    if (this.isStable()) ru(() => {
                        for (; 0 !== this._callbacks.length;) {
                            let n = this._callbacks.pop();
                            clearTimeout(n.timeoutId), n.doneCb(this._didWork)
                        }
                        this._didWork = !1
                    }); else {
                        let n = this.getPendingTasks();
                        this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(n) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0
                    }
                }

                getPendingTasks() {
                    return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({
                        source: n.source,
                        creationLocation: n.creationLocation,
                        data: n.data
                    })) : []
                }

                addCallback(n, i, a) {
                    let c = -1;
                    i && i > 0 && (c = setTimeout(() => {
                        this._callbacks = this._callbacks.filter(b => b.timeoutId !== c), n(this._didWork, this.getPendingTasks())
                    }, i)), this._callbacks.push({doneCb: n, timeoutId: c, updateCb: a})
                }

                whenStable(n, i, a) {
                    if (a && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
                    this.addCallback(n, i, a), this._runCallbacksIfReady()
                }

                getPendingRequestCount() {
                    return this._pendingCount
                }

                findProviders(n, i, a) {
                    return []
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)(bi(ss))
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac}), e
        })(), T0 = (() => {
            class e {
                constructor() {
                    this._applications = new Map, ou.addToWindow(this)
                }

                registerApplication(n, i) {
                    this._applications.set(n, i)
                }

                unregisterApplication(n) {
                    this._applications.delete(n)
                }

                unregisterAllApplications() {
                    this._applications.clear()
                }

                getTestability(n) {
                    return this._applications.get(n) || null
                }

                getAllTestabilities() {
                    return Array.from(this._applications.values())
                }

                getAllRootElements() {
                    return Array.from(this._applications.keys())
                }

                findTestabilityInTree(n, i = !0) {
                    return ou.findTestabilityInTree(this, n, i)
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac}), e
        })();

        class E1 {
            addToWindow(t) {
            }

            findTestabilityInTree(t, n, i) {
                return null
            }
        }

        function _1(e) {
            ou = e
        }

        let os, ou = new E1;
        const A0 = new L("AllowMultipleToken");

        class D1 {
            constructor(t, n) {
                this.name = t, this.token = n
            }
        }

        function M0(e, t, n = []) {
            const i = `Platform: ${t}`, a = new L(i);
            return (c = []) => {
                let b = I0();
                if (!b || b.injector.get(A0, !1)) if (e) e(n.concat(c).concat({provide: a, useValue: !0})); else {
                    const S = n.concat(c).concat({provide: a, useValue: !0}, {provide: ac, useValue: "platform"});
                    !function T1(e) {
                        if (os && !os.destroyed && !os.injector.get(A0, !1)) throw new xe(400, "");
                        os = e.get(P0);
                        const t = e.get(x0, null);
                        t && t.forEach(n => n())
                    }(es.create({providers: S, name: i}))
                }
                return function A1(e) {
                    const t = I0();
                    if (!t) throw new xe(401, "");
                    return t
                }()
            }
        }

        function I0() {
            return os && !os.destroyed ? os : null
        }

        let P0 = (() => {
            class e {
                constructor(n) {
                    this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1
                }

                bootstrapModuleFactory(n, i) {
                    const S = function M1(e, t) {
                        let n;
                        return n = "noop" === e ? new w1 : ("zone.js" === e ? void 0 : e) || new ss({
                            enableLongStackTrace: !1,
                            shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing),
                            shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing)
                        }), n
                    }(i ? i.ngZone : void 0, {
                        ngZoneEventCoalescing: i && i.ngZoneEventCoalescing || !1,
                        ngZoneRunCoalescing: i && i.ngZoneRunCoalescing || !1
                    }), k = [{provide: ss, useValue: S}];
                    return S.run(() => {
                        const pe = es.create({providers: k, parent: this.injector, name: n.moduleType.name}),
                            Se = n.create(pe), et = Se.injector.get(Ta, null);
                        if (!et) throw new xe(402, "");
                        return S.runOutsideAngular(() => {
                            const St = S.onError.subscribe({
                                next: $t => {
                                    et.handleError($t)
                                }
                            });
                            Se.onDestroy(() => {
                                lu(this._modules, Se), St.unsubscribe()
                            })
                        }), function I1(e, t, n) {
                            try {
                                const i = n();
                                return Cc(i) ? i.catch(a => {
                                    throw t.runOutsideAngular(() => e.handleError(a)), a
                                }) : i
                            } catch (i) {
                                throw t.runOutsideAngular(() => e.handleError(i)), i
                            }
                        }(et, S, () => {
                            const St = Se.injector.get(eu);
                            return St.runInitializers(), St.donePromise.then(() => (function ub(e) {
                                ze(e, "Expected localeId to be defined"), "string" == typeof e && (qh = e.toLowerCase().replace(/_/g, "-"))
                            }(Se.injector.get(nu, Wa) || Wa), this._moduleDoBootstrap(Se), Se))
                        })
                    })
                }

                bootstrapModule(n, i = []) {
                    const a = O0({}, i);
                    return function C1(e, t, n) {
                        const i = new Vc(n);
                        return Promise.resolve(i)
                    }(0, 0, n).then(c => this.bootstrapModuleFactory(c, a))
                }

                _moduleDoBootstrap(n) {
                    const i = n.injector.get(au);
                    if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(a => i.bootstrap(a)); else {
                        if (!n.instance.ngDoBootstrap) throw new xe(403, "");
                        n.instance.ngDoBootstrap(i)
                    }
                    this._modules.push(n)
                }

                onDestroy(n) {
                    this._destroyListeners.push(n)
                }

                get injector() {
                    return this._injector
                }

                destroy() {
                    if (this._destroyed) throw new xe(404, "");
                    this._modules.slice().forEach(n => n.destroy()), this._destroyListeners.forEach(n => n()), this._destroyed = !0
                }

                get destroyed() {
                    return this._destroyed
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)(bi(es))
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac}), e
        })();

        function O0(e, t) {
            return Array.isArray(t) ? t.reduce(O0, e) : Object.assign(Object.assign({}, e), t)
        }

        let au = (() => {
            class e {
                constructor(n, i, a, c, b) {
                    this._zone = n, this._injector = i, this._exceptionHandler = a, this._componentFactoryResolver = c, this._initStatus = b, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                        next: () => {
                            this._zone.run(() => {
                                this.tick()
                            })
                        }
                    });
                    const S = new ie.y(pe => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => {
                            pe.next(this._stable), pe.complete()
                        })
                    }), k = new ie.y(pe => {
                        let Se;
                        this._zone.runOutsideAngular(() => {
                            Se = this._zone.onStable.subscribe(() => {
                                ss.assertNotInAngularZone(), ru(() => {
                                    !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, pe.next(!0))
                                })
                            })
                        });
                        const et = this._zone.onUnstable.subscribe(() => {
                            ss.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                pe.next(!1)
                            }))
                        });
                        return () => {
                            Se.unsubscribe(), et.unsubscribe()
                        }
                    });
                    this.isStable = (0, te.T)(S, k.pipe(function me() {
                        return e => (0, Ne.x)()(function W(e, t) {
                            return function (i) {
                                let a;
                                if (a = "function" == typeof e ? e : function () {
                                    return e
                                }, "function" == typeof t) return i.lift(new Q(a, t));
                                const c = Object.create(i, j.N);
                                return c.source = i, c.subjectFactory = a, c
                            }
                        }(ve)(e))
                    }()))
                }

                bootstrap(n, i) {
                    if (!this._initStatus.done) throw new xe(405, "");
                    let a;
                    a = n instanceof wp ? n : this._componentFactoryResolver.resolveComponentFactory(n), this.componentTypes.push(a.componentType);
                    const c = function S1(e) {
                            return e.isBoundToModule
                        }(a) ? void 0 : this._injector.get(_o), S = a.create(es.NULL, [], i || a.selector, c),
                        k = S.location.nativeElement, pe = S.injector.get(D0, null), Se = pe && S.injector.get(T0);
                    return pe && Se && Se.registerApplication(k, pe), S.onDestroy(() => {
                        this.detachView(S.hostView), lu(this.components, S), Se && Se.unregisterApplication(k)
                    }), this._loadComponent(S), S
                }

                tick() {
                    if (this._runningTick) throw new xe(101, "");
                    try {
                        this._runningTick = !0;
                        for (let n of this._views) n.detectChanges()
                    } catch (n) {
                        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n))
                    } finally {
                        this._runningTick = !1
                    }
                }

                attachView(n) {
                    const i = n;
                    this._views.push(i), i.attachToAppRef(this)
                }

                detachView(n) {
                    const i = n;
                    lu(this._views, i), i.detachFromAppRef()
                }

                _loadComponent(n) {
                    this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(E0, []).concat(this._bootstrapListeners).forEach(a => a(n))
                }

                ngOnDestroy() {
                    this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe()
                }

                get viewCount() {
                    return this._views.length
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)(bi(ss), bi(es), bi(Ta), bi(Ja), bi(eu))
            }, e.\u0275prov = Ye({token: e, factory: e.\u0275fac, providedIn: "root"}), e
        })();

        function lu(e, t) {
            const n = e.indexOf(t);
            n > -1 && e.splice(n, 1)
        }

        let N0 = !0;

        function O1() {
            N0 = !1
        }

        let R1 = (() => {
            class e {
            }

            return e.__NG_ELEMENT_ID__ = N1, e
        })();

        function N1(e) {
            return function k1(e, t, n) {
                if (Zn(e) && !n) {
                    const i = Or(e.index, t);
                    return new ia(i, i)
                }
                return 47 & e.type ? new ia(t[16], t) : null
            }(dr(), Lt(), 16 == (16 & e))
        }

        class $0 {
            constructor() {
            }

            supports(t) {
                return qo(t)
            }

            create(t) {
                return new U1(t)
            }
        }

        const V1 = (e, t) => t;

        class U1 {
            constructor(t) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || V1
            }

            forEachItem(t) {
                let n;
                for (n = this._itHead; null !== n; n = n._next) t(n)
            }

            forEachOperation(t) {
                let n = this._itHead, i = this._removalsHead, a = 0, c = null;
                for (; n || i;) {
                    const b = !i || n && n.currentIndex < U0(i, a, c) ? n : i, S = U0(b, a, c), k = b.currentIndex;
                    if (b === i) a--, i = i._nextRemoved; else if (n = n._next, null == b.previousIndex) a++; else {
                        c || (c = []);
                        const pe = S - a, Se = k - a;
                        if (pe != Se) {
                            for (let St = 0; St < pe; St++) {
                                const $t = St < c.length ? c[St] : c[St] = 0, tn = $t + St;
                                Se <= tn && tn < pe && (c[St] = $t + 1)
                            }
                            c[b.previousIndex] = Se - pe
                        }
                    }
                    S !== k && t(b, S, k)
                }
            }

            forEachPreviousItem(t) {
                let n;
                for (n = this._previousItHead; null !== n; n = n._nextPrevious) t(n)
            }

            forEachAddedItem(t) {
                let n;
                for (n = this._additionsHead; null !== n; n = n._nextAdded) t(n)
            }

            forEachMovedItem(t) {
                let n;
                for (n = this._movesHead; null !== n; n = n._nextMoved) t(n)
            }

            forEachRemovedItem(t) {
                let n;
                for (n = this._removalsHead; null !== n; n = n._nextRemoved) t(n)
            }

            forEachIdentityChange(t) {
                let n;
                for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange) t(n)
            }

            diff(t) {
                if (null == t && (t = []), !qo(t)) throw new xe(900, "");
                return this.check(t) ? this : null
            }

            onDestroy() {
            }

            check(t) {
                this._reset();
                let a, c, b, n = this._itHead, i = !1;
                if (Array.isArray(t)) {
                    this.length = t.length;
                    for (let S = 0; S < this.length; S++) c = t[S], b = this._trackByFn(S, c), null !== n && Object.is(n.trackById, b) ? (i && (n = this._verifyReinsertion(n, c, b, S)), Object.is(n.item, c) || this._addIdentityChange(n, c)) : (n = this._mismatch(n, c, b, S), i = !0), n = n._next
                } else a = 0, function Jv(e, t) {
                    if (Array.isArray(e)) for (let n = 0; n < e.length; n++) t(e[n]); else {
                        const n = e[ao()]();
                        let i;
                        for (; !(i = n.next()).done;) t(i.value)
                    }
                }(t, S => {
                    b = this._trackByFn(a, S), null !== n && Object.is(n.trackById, b) ? (i && (n = this._verifyReinsertion(n, S, b, a)), Object.is(n.item, S) || this._addIdentityChange(n, S)) : (n = this._mismatch(n, S, b, a), i = !0), n = n._next, a++
                }), this.length = a;
                return this._truncate(n), this.collection = t, this.isDirty
            }

            get isDirty() {
                return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
            }

            _reset() {
                if (this.isDirty) {
                    let t;
                    for (t = this._previousItHead = this._itHead; null !== t; t = t._next) t._nextPrevious = t._next;
                    for (t = this._additionsHead; null !== t; t = t._nextAdded) t.previousIndex = t.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved) t.previousIndex = t.currentIndex;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
                }
            }

            _mismatch(t, n, i, a) {
                let c;
                return null === t ? c = this._itTail : (c = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, c, a)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, a)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, c, a)) : t = this._addAfter(new H1(n, i), c, a), t
            }

            _verifyReinsertion(t, n, i, a) {
                let c = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null);
                return null !== c ? t = this._reinsertAfter(c, t._prev, a) : t.currentIndex != a && (t.currentIndex = a, this._addToMoves(t, a)), t
            }

            _truncate(t) {
                for (; null !== t;) {
                    const n = t._next;
                    this._addToRemovals(this._unlink(t)), t = n
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
            }

            _reinsertAfter(t, n, i) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(t);
                const a = t._prevRemoved, c = t._nextRemoved;
                return null === a ? this._removalsHead = c : a._nextRemoved = c, null === c ? this._removalsTail = a : c._prevRemoved = a, this._insertAfter(t, n, i), this._addToMoves(t, i), t
            }

            _moveAfter(t, n, i) {
                return this._unlink(t), this._insertAfter(t, n, i), this._addToMoves(t, i), t
            }

            _addAfter(t, n, i) {
                return this._insertAfter(t, n, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t
            }

            _insertAfter(t, n, i) {
                const a = null === n ? this._itHead : n._next;
                return t._next = a, t._prev = n, null === a ? this._itTail = t : a._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new V0), this._linkedRecords.put(t), t.currentIndex = i, t
            }

            _remove(t) {
                return this._addToRemovals(this._unlink(t))
            }

            _unlink(t) {
                null !== this._linkedRecords && this._linkedRecords.remove(t);
                const n = t._prev, i = t._next;
                return null === n ? this._itHead = i : n._next = i, null === i ? this._itTail = n : i._prev = n, t
            }

            _addToMoves(t, n) {
                return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t
            }

            _addToRemovals(t) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new V0), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t
            }

            _addIdentityChange(t, n) {
                return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t
            }
        }

        class H1 {
            constructor(t, n) {
                this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
            }
        }

        class z1 {
            constructor() {
                this._head = null, this._tail = null
            }

            add(t) {
                null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t)
            }

            get(t, n) {
                let i;
                for (i = this._head; null !== i; i = i._nextDup) if ((null === n || n <= i.currentIndex) && Object.is(i.trackById, t)) return i;
                return null
            }

            remove(t) {
                const n = t._prevDup, i = t._nextDup;
                return null === n ? this._head = i : n._nextDup = i, null === i ? this._tail = n : i._prevDup = n, null === this._head
            }
        }

        class V0 {
            constructor() {
                this.map = new Map
            }

            put(t) {
                const n = t.trackById;
                let i = this.map.get(n);
                i || (i = new z1, this.map.set(n, i)), i.add(t)
            }

            get(t, n) {
                const a = this.map.get(t);
                return a ? a.get(t, n) : null
            }

            remove(t) {
                const n = t.trackById;
                return this.map.get(n).remove(t) && this.map.delete(n), t
            }

            get isEmpty() {
                return 0 === this.map.size
            }

            clear() {
                this.map.clear()
            }
        }

        function U0(e, t, n) {
            const i = e.previousIndex;
            if (null === i) return i;
            let a = 0;
            return n && i < n.length && (a = n[i]), i + t + a
        }

        class H0 {
            constructor() {
            }

            supports(t) {
                return t instanceof Map || pc(t)
            }

            create() {
                return new G1
            }
        }

        class G1 {
            constructor() {
                this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
            }

            get isDirty() {
                return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
            }

            forEachItem(t) {
                let n;
                for (n = this._mapHead; null !== n; n = n._next) t(n)
            }

            forEachPreviousItem(t) {
                let n;
                for (n = this._previousMapHead; null !== n; n = n._nextPrevious) t(n)
            }

            forEachChangedItem(t) {
                let n;
                for (n = this._changesHead; null !== n; n = n._nextChanged) t(n)
            }

            forEachAddedItem(t) {
                let n;
                for (n = this._additionsHead; null !== n; n = n._nextAdded) t(n)
            }

            forEachRemovedItem(t) {
                let n;
                for (n = this._removalsHead; null !== n; n = n._nextRemoved) t(n)
            }

            diff(t) {
                if (t) {
                    if (!(t instanceof Map || pc(t))) throw new xe(900, "")
                } else t = new Map;
                return this.check(t) ? this : null
            }

            onDestroy() {
            }

            check(t) {
                this._reset();
                let n = this._mapHead;
                if (this._appendAfter = null, this._forEach(t, (i, a) => {
                    if (n && n.key === a) this._maybeAddToChanges(n, i), this._appendAfter = n, n = n._next; else {
                        const c = this._getOrCreateRecordForKey(a, i);
                        n = this._insertBeforeOrAppend(n, c)
                    }
                }), n) {
                    n._prev && (n._prev._next = null), this._removalsHead = n;
                    for (let i = n; null !== i; i = i._nextRemoved) i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
            }

            _insertBeforeOrAppend(t, n) {
                if (t) {
                    const i = t._prev;
                    return n._next = t, n._prev = i, t._prev = n, i && (i._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t
                }
                return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null
            }

            _getOrCreateRecordForKey(t, n) {
                if (this._records.has(t)) {
                    const a = this._records.get(t);
                    this._maybeAddToChanges(a, n);
                    const c = a._prev, b = a._next;
                    return c && (c._next = b), b && (b._prev = c), a._next = null, a._prev = null, a
                }
                const i = new j1(t);
                return this._records.set(t, i), i.currentValue = n, this._addToAdditions(i), i
            }

            _reset() {
                if (this.isDirty) {
                    let t;
                    for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next) t._nextPrevious = t._next;
                    for (t = this._changesHead; null !== t; t = t._nextChanged) t.previousValue = t.currentValue;
                    for (t = this._additionsHead; null != t; t = t._nextAdded) t.previousValue = t.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
                }
            }

            _maybeAddToChanges(t, n) {
                Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t))
            }

            _addToAdditions(t) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t)
            }

            _addToChanges(t) {
                null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t)
            }

            _forEach(t, n) {
                t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(i => n(t[i], i))
            }
        }

        class j1 {
            constructor(t) {
                this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
            }
        }

        function z0() {
            return new hu([new $0])
        }

        let hu = (() => {
            class e {
                constructor(n) {
                    this.factories = n
                }

                static create(n, i) {
                    if (null != i) {
                        const a = i.factories.slice();
                        n = n.concat(a)
                    }
                    return new e(n)
                }

                static extend(n) {
                    return {provide: e, useFactory: i => e.create(n, i || z0()), deps: [[e, new Bo, new Lo]]}
                }

                find(n) {
                    const i = this.factories.find(a => a.supports(n));
                    if (null != i) return i;
                    throw new xe(901, "")
                }
            }

            return e.\u0275prov = Ye({token: e, providedIn: "root", factory: z0}), e
        })();

        function G0() {
            return new pu([new H0])
        }

        let pu = (() => {
            class e {
                constructor(n) {
                    this.factories = n
                }

                static create(n, i) {
                    if (i) {
                        const a = i.factories.slice();
                        n = n.concat(a)
                    }
                    return new e(n)
                }

                static extend(n) {
                    return {provide: e, useFactory: i => e.create(n, i || G0()), deps: [[e, new Bo, new Lo]]}
                }

                find(n) {
                    const i = this.factories.find(c => c.supports(n));
                    if (i) return i;
                    throw new xe(901, "")
                }
            }

            return e.\u0275prov = Ye({token: e, providedIn: "root", factory: G0}), e
        })();
        const K1 = M0(null, "core", [{provide: w0, useValue: "unknown"}, {provide: P0, deps: [es]}, {
            provide: T0,
            deps: []
        }, {provide: _0, deps: []}]);
        let q1 = (() => {
            class e {
                constructor(n) {
                }
            }

            return e.\u0275fac = function (n) {
                return new (n || e)(bi(au))
            }, e.\u0275mod = ht({type: e}), e.\u0275inj = _t({}), e
        })()
    }, 4182: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {u5: () => Ar, JU: () => X, a5: () => Xt, JJ: () => On, On: () => Bn, Q7: () => J});
        var r = R(6435), D = R(9808), ie = R(2916), te = R(6688), j = R(4850), W = R(7830), Q = R(5254);

        function ve(re, z) {
            return new ie.y(V => {
                const _e = re.length;
                if (0 === _e) return void V.complete();
                const h = new Array(_e);
                let G = 0, m = 0;
                for (let K = 0; K < _e; K++) {
                    const Re = (0, Q.D)(re[K]);
                    let kt = !1;
                    V.add(Re.subscribe({
                        next: Dn => {
                            kt || (kt = !0, m++), h[K] = Dn
                        }, error: Dn => V.error(Dn), complete: () => {
                            G++, (G === _e || !kt) && (m === _e && V.next(z ? z.reduce((Dn, Lt, In) => (Dn[Lt] = h[In], Dn), {}) : h), V.complete())
                        }
                    }))
                }
            })
        }

        let me = (() => {
            class re {
                constructor(V, _e) {
                    this._renderer = V, this._elementRef = _e, this.onChange = h => {
                    }, this.onTouched = () => {
                    }
                }

                setProperty(V, _e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, V, _e)
                }

                registerOnTouched(V) {
                    this.onTouched = V
                }

                registerOnChange(V) {
                    this.onChange = V
                }

                setDisabledState(V) {
                    this.setProperty("disabled", V)
                }
            }

            return re.\u0275fac = function (V) {
                return new (V || re)(r.Y36(r.Qsj), r.Y36(r.SBq))
            }, re.\u0275dir = r.lG2({type: re}), re
        })(), ae = (() => {
            class re extends me {
            }

            return re.\u0275fac = function () {
                let z;
                return function (_e) {
                    return (z || (z = r.n5z(re)))(_e || re)
                }
            }(), re.\u0275dir = r.lG2({type: re, features: [r.qOj]}), re
        })();
        const X = new r.OlP("NgValueAccessor"), F = {provide: X, useExisting: (0, r.Gpc)(() => Ie), multi: !0},
            ge = new r.OlP("CompositionEventMode");
        let Ie = (() => {
            class re extends me {
                constructor(V, _e, h) {
                    super(V, _e), this._compositionMode = h, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function oe() {
                        const re = (0, D.q)() ? (0, D.q)().getUserAgent() : "";
                        return /android (\d+)/.test(re.toLowerCase())
                    }())
                }

                writeValue(V) {
                    this.setProperty("value", null == V ? "" : V)
                }

                _handleInput(V) {
                    (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(V)
                }

                _compositionStart() {
                    this._composing = !0
                }

                _compositionEnd(V) {
                    this._composing = !1, this._compositionMode && this.onChange(V)
                }
            }

            return re.\u0275fac = function (V) {
                return new (V || re)(r.Y36(r.Qsj), r.Y36(r.SBq), r.Y36(ge, 8))
            }, re.\u0275dir = r.lG2({
                type: re,
                selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
                hostBindings: function (V, _e) {
                    1 & V && r.NdJ("input", function (G) {
                        return _e._handleInput(G.target.value)
                    })("blur", function () {
                        return _e.onTouched()
                    })("compositionstart", function () {
                        return _e._compositionStart()
                    })("compositionend", function (G) {
                        return _e._compositionEnd(G.target.value)
                    })
                },
                features: [r._Bn([F]), r.qOj]
            }), re
        })();
        const Ue = new r.OlP("NgValidators"), it = new r.OlP("NgAsyncValidators");

        function Xe(re) {
            return function he(re) {
                return null == re || 0 === re.length
            }(re.value) ? {required: !0} : null
        }

        function g(re) {
            return null
        }

        function v(re) {
            return null != re
        }

        function w(re) {
            const z = (0, r.QGY)(re) ? (0, Q.D)(re) : re;
            return (0, r.CqO)(z), z
        }

        function P(re) {
            let z = {};
            return re.forEach(V => {
                z = null != V ? Object.assign(Object.assign({}, z), V) : z
            }), 0 === Object.keys(z).length ? null : z
        }

        function B(re, z) {
            return z.map(V => V(re))
        }

        function E(re) {
            return re.map(z => function O(re) {
                return !re.validate
            }(z) ? z : V => z.validate(V))
        }

        function ze(re) {
            return null != re ? function Z(re) {
                if (!re) return null;
                const z = re.filter(v);
                return 0 == z.length ? null : function (V) {
                    return P(B(V, z))
                }
            }(E(re)) : null
        }

        function q(re) {
            return null != re ? function Je(re) {
                if (!re) return null;
                const z = re.filter(v);
                return 0 == z.length ? null : function (V) {
                    return function Ne(...re) {
                        if (1 === re.length) {
                            const z = re[0];
                            if ((0, te.k)(z)) return ve(z, null);
                            if ((0, W.K)(z) && Object.getPrototypeOf(z) === Object.prototype) {
                                const V = Object.keys(z);
                                return ve(V.map(_e => z[_e]), V)
                            }
                        }
                        if ("function" == typeof re[re.length - 1]) {
                            const z = re.pop();
                            return ve(re = 1 === re.length && (0, te.k)(re[0]) ? re[0] : re, null).pipe((0, j.U)(V => z(...V)))
                        }
                        return ve(re, null)
                    }(B(V, z).map(w)).pipe((0, j.U)(P))
                }
            }(E(re)) : null
        }

        function Le(re, z) {
            return null === re ? [z] : Array.isArray(re) ? [...re, z] : [re, z]
        }

        function Mt(re) {
            return re ? Array.isArray(re) ? re : [re] : []
        }

        function _t(re, z) {
            return Array.isArray(re) ? re.includes(z) : re === z
        }

        function Pt(re, z) {
            const V = Mt(z);
            return Mt(re).forEach(h => {
                _t(V, h) || V.push(h)
            }), V
        }

        function Gt(re, z) {
            return Mt(z).filter(V => !_t(re, V))
        }

        class yn {
            constructor() {
                this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = []
            }

            get value() {
                return this.control ? this.control.value : null
            }

            get valid() {
                return this.control ? this.control.valid : null
            }

            get invalid() {
                return this.control ? this.control.invalid : null
            }

            get pending() {
                return this.control ? this.control.pending : null
            }

            get disabled() {
                return this.control ? this.control.disabled : null
            }

            get enabled() {
                return this.control ? this.control.enabled : null
            }

            get errors() {
                return this.control ? this.control.errors : null
            }

            get pristine() {
                return this.control ? this.control.pristine : null
            }

            get dirty() {
                return this.control ? this.control.dirty : null
            }

            get touched() {
                return this.control ? this.control.touched : null
            }

            get status() {
                return this.control ? this.control.status : null
            }

            get untouched() {
                return this.control ? this.control.untouched : null
            }

            get statusChanges() {
                return this.control ? this.control.statusChanges : null
            }

            get valueChanges() {
                return this.control ? this.control.valueChanges : null
            }

            get path() {
                return null
            }

            _setValidators(z) {
                this._rawValidators = z || [], this._composedValidatorFn = ze(this._rawValidators)
            }

            _setAsyncValidators(z) {
                this._rawAsyncValidators = z || [], this._composedAsyncValidatorFn = q(this._rawAsyncValidators)
            }

            get validator() {
                return this._composedValidatorFn || null
            }

            get asyncValidator() {
                return this._composedAsyncValidatorFn || null
            }

            _registerOnDestroy(z) {
                this._onDestroyCallbacks.push(z)
            }

            _invokeOnDestroyCallbacks() {
                this._onDestroyCallbacks.forEach(z => z()), this._onDestroyCallbacks = []
            }

            reset(z) {
                this.control && this.control.reset(z)
            }

            hasError(z, V) {
                return !!this.control && this.control.hasError(z, V)
            }

            getError(z, V) {
                return this.control ? this.control.getError(z, V) : null
            }
        }

        class Xt extends yn {
            constructor() {
                super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null
            }
        }

        class xn extends yn {
            get formDirective() {
                return null
            }

            get path() {
                return null
            }
        }

        let On = (() => {
            class re extends class Fn {
                constructor(z) {
                    this._cd = z
                }

                is(z) {
                    var V, _e, h;
                    return "submitted" === z ? !!(null === (V = this._cd) || void 0 === V ? void 0 : V.submitted) : !!(null === (h = null === (_e = this._cd) || void 0 === _e ? void 0 : _e.control) || void 0 === h ? void 0 : h[z])
                }
            } {
                constructor(V) {
                    super(V)
                }
            }

            return re.\u0275fac = function (V) {
                return new (V || re)(r.Y36(Xt, 2))
            }, re.\u0275dir = r.lG2({
                type: re,
                selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
                hostVars: 14,
                hostBindings: function (V, _e) {
                    2 & V && r.ekj("ng-untouched", _e.is("untouched"))("ng-touched", _e.is("touched"))("ng-pristine", _e.is("pristine"))("ng-dirty", _e.is("dirty"))("ng-valid", _e.is("valid"))("ng-invalid", _e.is("invalid"))("ng-pending", _e.is("pending"))
                },
                features: [r.qOj]
            }), re
        })();

        function rn(re, z) {
            (function fr(re, z) {
                const V = function ut(re) {
                    return re._rawValidators
                }(re);
                null !== z.validator ? re.setValidators(Le(V, z.validator)) : "function" == typeof V && re.setValidators([V]);
                const _e = function Ye(re) {
                    return re._rawAsyncValidators
                }(re);
                null !== z.asyncValidator ? re.setAsyncValidators(Le(_e, z.asyncValidator)) : "function" == typeof _e && re.setAsyncValidators([_e]);
                const h = () => re.updateValueAndValidity();
                Hn(z._rawValidators, h), Hn(z._rawAsyncValidators, h)
            })(re, z), z.valueAccessor.writeValue(re.value), function Yn(re, z) {
                z.valueAccessor.registerOnChange(V => {
                    re._pendingValue = V, re._pendingChange = !0, re._pendingDirty = !0, "change" === re.updateOn && Wn(re, z)
                })
            }(re, z), function Xn(re, z) {
                const V = (_e, h) => {
                    z.valueAccessor.writeValue(_e), h && z.viewToModelUpdate(_e)
                };
                re.registerOnChange(V), z._registerOnDestroy(() => {
                    re._unregisterOnChange(V)
                })
            }(re, z), function Qn(re, z) {
                z.valueAccessor.registerOnTouched(() => {
                    re._pendingTouched = !0, "blur" === re.updateOn && re._pendingChange && Wn(re, z), "submit" !== re.updateOn && re.markAsTouched()
                })
            }(re, z), function jn(re, z) {
                if (z.valueAccessor.setDisabledState) {
                    const V = _e => {
                        z.valueAccessor.setDisabledState(_e)
                    };
                    re.registerOnDisabledChange(V), z._registerOnDestroy(() => {
                        re._unregisterOnDisabledChange(V)
                    })
                }
            }(re, z)
        }

        function Hn(re, z) {
            re.forEach(V => {
                V.registerOnValidatorChange && V.registerOnValidatorChange(z)
            })
        }

        function Wn(re, z) {
            re._pendingDirty && re.markAsDirty(), re.setValue(re._pendingValue, {emitModelToViewChange: !1}), z.viewToModelUpdate(re._pendingValue), re._pendingChange = !1
        }

        function Qt(re, z) {
            const V = re.indexOf(z);
            V > -1 && re.splice(V, 1)
        }

        const Pn = "VALID", mn = "INVALID", Mn = "PENDING", an = "DISABLED";

        function Sn(re) {
            return (_n(re) ? re.validators : re) || null
        }

        function ar(re) {
            return Array.isArray(re) ? ze(re) : re || null
        }

        function Un(re, z) {
            return (_n(z) ? z.asyncValidators : re) || null
        }

        function nn(re) {
            return Array.isArray(re) ? q(re) : re || null
        }

        function _n(re) {
            return null != re && !Array.isArray(re) && "object" == typeof re
        }

        const nr = re => re instanceof $n;

        function gr(re) {
            return (re => re instanceof Vn)(re) ? re.value : re.getRawValue()
        }

        function Ir(re, z) {
            const V = nr(re), _e = re.controls;
            if (!(V ? Object.keys(_e) : _e).length) throw new r.vHH(1e3, "");
            if (!_e[z]) throw new r.vHH(1001, "")
        }

        function rr(re, z) {
            nr(re), re._forEachChild((_e, h) => {
                if (void 0 === z[h]) throw new r.vHH(1002, "")
            })
        }

        class br {
            constructor(z, V) {
                this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => {
                }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = z, this._rawAsyncValidators = V, this._composedValidatorFn = ar(this._rawValidators), this._composedAsyncValidatorFn = nn(this._rawAsyncValidators)
            }

            get validator() {
                return this._composedValidatorFn
            }

            set validator(z) {
                this._rawValidators = this._composedValidatorFn = z
            }

            get asyncValidator() {
                return this._composedAsyncValidatorFn
            }

            set asyncValidator(z) {
                this._rawAsyncValidators = this._composedAsyncValidatorFn = z
            }

            get parent() {
                return this._parent
            }

            get valid() {
                return this.status === Pn
            }

            get invalid() {
                return this.status === mn
            }

            get pending() {
                return this.status == Mn
            }

            get disabled() {
                return this.status === an
            }

            get enabled() {
                return this.status !== an
            }

            get dirty() {
                return !this.pristine
            }

            get untouched() {
                return !this.touched
            }

            get updateOn() {
                return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
            }

            setValidators(z) {
                this._rawValidators = z, this._composedValidatorFn = ar(z)
            }

            setAsyncValidators(z) {
                this._rawAsyncValidators = z, this._composedAsyncValidatorFn = nn(z)
            }

            addValidators(z) {
                this.setValidators(Pt(z, this._rawValidators))
            }

            addAsyncValidators(z) {
                this.setAsyncValidators(Pt(z, this._rawAsyncValidators))
            }

            removeValidators(z) {
                this.setValidators(Gt(z, this._rawValidators))
            }

            removeAsyncValidators(z) {
                this.setAsyncValidators(Gt(z, this._rawAsyncValidators))
            }

            hasValidator(z) {
                return _t(this._rawValidators, z)
            }

            hasAsyncValidator(z) {
                return _t(this._rawAsyncValidators, z)
            }

            clearValidators() {
                this.validator = null
            }

            clearAsyncValidators() {
                this.asyncValidator = null
            }

            markAsTouched(z = {}) {
                this.touched = !0, this._parent && !z.onlySelf && this._parent.markAsTouched(z)
            }

            markAllAsTouched() {
                this.markAsTouched({onlySelf: !0}), this._forEachChild(z => z.markAllAsTouched())
            }

            markAsUntouched(z = {}) {
                this.touched = !1, this._pendingTouched = !1, this._forEachChild(V => {
                    V.markAsUntouched({onlySelf: !0})
                }), this._parent && !z.onlySelf && this._parent._updateTouched(z)
            }

            markAsDirty(z = {}) {
                this.pristine = !1, this._parent && !z.onlySelf && this._parent.markAsDirty(z)
            }

            markAsPristine(z = {}) {
                this.pristine = !0, this._pendingDirty = !1, this._forEachChild(V => {
                    V.markAsPristine({onlySelf: !0})
                }), this._parent && !z.onlySelf && this._parent._updatePristine(z)
            }

            markAsPending(z = {}) {
                this.status = Mn, !1 !== z.emitEvent && this.statusChanges.emit(this.status), this._parent && !z.onlySelf && this._parent.markAsPending(z)
            }

            disable(z = {}) {
                const V = this._parentMarkedDirty(z.onlySelf);
                this.status = an, this.errors = null, this._forEachChild(_e => {
                    _e.disable(Object.assign(Object.assign({}, z), {onlySelf: !0}))
                }), this._updateValue(), !1 !== z.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, z), {skipPristineCheck: V})), this._onDisabledChange.forEach(_e => _e(!0))
            }

            enable(z = {}) {
                const V = this._parentMarkedDirty(z.onlySelf);
                this.status = Pn, this._forEachChild(_e => {
                    _e.enable(Object.assign(Object.assign({}, z), {onlySelf: !0}))
                }), this.updateValueAndValidity({
                    onlySelf: !0,
                    emitEvent: z.emitEvent
                }), this._updateAncestors(Object.assign(Object.assign({}, z), {skipPristineCheck: V})), this._onDisabledChange.forEach(_e => _e(!1))
            }

            _updateAncestors(z) {
                this._parent && !z.onlySelf && (this._parent.updateValueAndValidity(z), z.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched())
            }

            setParent(z) {
                this._parent = z
            }

            updateValueAndValidity(z = {}) {
                this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Pn || this.status === Mn) && this._runAsyncValidator(z.emitEvent)), !1 !== z.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !z.onlySelf && this._parent.updateValueAndValidity(z)
            }

            _updateTreeValidity(z = {emitEvent: !0}) {
                this._forEachChild(V => V._updateTreeValidity(z)), this.updateValueAndValidity({
                    onlySelf: !0,
                    emitEvent: z.emitEvent
                })
            }

            _setInitialStatus() {
                this.status = this._allControlsDisabled() ? an : Pn
            }

            _runValidator() {
                return this.validator ? this.validator(this) : null
            }

            _runAsyncValidator(z) {
                if (this.asyncValidator) {
                    this.status = Mn, this._hasOwnPendingAsyncValidator = !0;
                    const V = w(this.asyncValidator(this));
                    this._asyncValidationSubscription = V.subscribe(_e => {
                        this._hasOwnPendingAsyncValidator = !1, this.setErrors(_e, {emitEvent: z})
                    })
                }
            }

            _cancelExistingSubscription() {
                this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1)
            }

            setErrors(z, V = {}) {
                this.errors = z, this._updateControlsErrors(!1 !== V.emitEvent)
            }

            get(z) {
                return function En(re, z, V) {
                    if (null == z || (Array.isArray(z) || (z = z.split(V)), Array.isArray(z) && 0 === z.length)) return null;
                    let _e = re;
                    return z.forEach(h => {
                        _e = nr(_e) ? _e.controls.hasOwnProperty(h) ? _e.controls[h] : null : (re => re instanceof Br)(_e) && _e.at(h) || null
                    }), _e
                }(this, z, ".")
            }

            getError(z, V) {
                const _e = V ? this.get(V) : this;
                return _e && _e.errors ? _e.errors[z] : null
            }

            hasError(z, V) {
                return !!this.getError(z, V)
            }

            get root() {
                let z = this;
                for (; z._parent;) z = z._parent;
                return z
            }

            _updateControlsErrors(z) {
                this.status = this._calculateStatus(), z && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(z)
            }

            _initObservables() {
                this.valueChanges = new r.vpe, this.statusChanges = new r.vpe
            }

            _calculateStatus() {
                return this._allControlsDisabled() ? an : this.errors ? mn : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Mn) ? Mn : this._anyControlsHaveStatus(mn) ? mn : Pn
            }

            _anyControlsHaveStatus(z) {
                return this._anyControls(V => V.status === z)
            }

            _anyControlsDirty() {
                return this._anyControls(z => z.dirty)
            }

            _anyControlsTouched() {
                return this._anyControls(z => z.touched)
            }

            _updatePristine(z = {}) {
                this.pristine = !this._anyControlsDirty(), this._parent && !z.onlySelf && this._parent._updatePristine(z)
            }

            _updateTouched(z = {}) {
                this.touched = this._anyControlsTouched(), this._parent && !z.onlySelf && this._parent._updateTouched(z)
            }

            _isBoxedValue(z) {
                return "object" == typeof z && null !== z && 2 === Object.keys(z).length && "value" in z && "disabled" in z
            }

            _registerOnCollectionChange(z) {
                this._onCollectionChange = z
            }

            _setUpdateStrategy(z) {
                _n(z) && null != z.updateOn && (this._updateOn = z.updateOn)
            }

            _parentMarkedDirty(z) {
                return !z && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty()
            }
        }

        class Vn extends br {
            constructor(z = null, V, _e) {
                super(Sn(V), Un(_e, V)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(z), this._setUpdateStrategy(V), this._initObservables(), this.updateValueAndValidity({
                    onlySelf: !0,
                    emitEvent: !!this.asyncValidator
                }), _n(V) && V.initialValueIsDefault && (this.defaultValue = this._isBoxedValue(z) ? z.value : z)
            }

            setValue(z, V = {}) {
                this.value = this._pendingValue = z, this._onChange.length && !1 !== V.emitModelToViewChange && this._onChange.forEach(_e => _e(this.value, !1 !== V.emitViewToModelChange)), this.updateValueAndValidity(V)
            }

            patchValue(z, V = {}) {
                this.setValue(z, V)
            }

            reset(z = this.defaultValue, V = {}) {
                this._applyFormState(z), this.markAsPristine(V), this.markAsUntouched(V), this.setValue(this.value, V), this._pendingChange = !1
            }

            _updateValue() {
            }

            _anyControls(z) {
                return !1
            }

            _allControlsDisabled() {
                return this.disabled
            }

            registerOnChange(z) {
                this._onChange.push(z)
            }

            _unregisterOnChange(z) {
                Qt(this._onChange, z)
            }

            registerOnDisabledChange(z) {
                this._onDisabledChange.push(z)
            }

            _unregisterOnDisabledChange(z) {
                Qt(this._onDisabledChange, z)
            }

            _forEachChild(z) {
            }

            _syncPendingControls() {
                return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, {
                    onlySelf: !0,
                    emitModelToViewChange: !1
                }), 0))
            }

            _applyFormState(z) {
                this._isBoxedValue(z) ? (this.value = this._pendingValue = z.value, z.disabled ? this.disable({
                    onlySelf: !0,
                    emitEvent: !1
                }) : this.enable({onlySelf: !0, emitEvent: !1})) : this.value = this._pendingValue = z
            }
        }

        class $n extends br {
            constructor(z, V, _e) {
                super(Sn(V), Un(_e, V)), this.controls = z, this._initObservables(), this._setUpdateStrategy(V), this._setUpControls(), this.updateValueAndValidity({
                    onlySelf: !0,
                    emitEvent: !!this.asyncValidator
                })
            }

            registerControl(z, V) {
                return this.controls[z] ? this.controls[z] : (this.controls[z] = V, V.setParent(this), V._registerOnCollectionChange(this._onCollectionChange), V)
            }

            addControl(z, V, _e = {}) {
                this.registerControl(z, V), this.updateValueAndValidity({emitEvent: _e.emitEvent}), this._onCollectionChange()
            }

            removeControl(z, V = {}) {
                this.controls[z] && this.controls[z]._registerOnCollectionChange(() => {
                }), delete this.controls[z], this.updateValueAndValidity({emitEvent: V.emitEvent}), this._onCollectionChange()
            }

            setControl(z, V, _e = {}) {
                this.controls[z] && this.controls[z]._registerOnCollectionChange(() => {
                }), delete this.controls[z], V && this.registerControl(z, V), this.updateValueAndValidity({emitEvent: _e.emitEvent}), this._onCollectionChange()
            }

            contains(z) {
                return this.controls.hasOwnProperty(z) && this.controls[z].enabled
            }

            setValue(z, V = {}) {
                rr(this, z), Object.keys(z).forEach(_e => {
                    Ir(this, _e), this.controls[_e].setValue(z[_e], {onlySelf: !0, emitEvent: V.emitEvent})
                }), this.updateValueAndValidity(V)
            }

            patchValue(z, V = {}) {
                null != z && (Object.keys(z).forEach(_e => {
                    this.controls[_e] && this.controls[_e].patchValue(z[_e], {onlySelf: !0, emitEvent: V.emitEvent})
                }), this.updateValueAndValidity(V))
            }

            reset(z = {}, V = {}) {
                this._forEachChild((_e, h) => {
                    _e.reset(z[h], {onlySelf: !0, emitEvent: V.emitEvent})
                }), this._updatePristine(V), this._updateTouched(V), this.updateValueAndValidity(V)
            }

            getRawValue() {
                return this._reduceChildren({}, (z, V, _e) => (z[_e] = gr(V), z))
            }

            _syncPendingControls() {
                let z = this._reduceChildren(!1, (V, _e) => !!_e._syncPendingControls() || V);
                return z && this.updateValueAndValidity({onlySelf: !0}), z
            }

            _forEachChild(z) {
                Object.keys(this.controls).forEach(V => {
                    const _e = this.controls[V];
                    _e && z(_e, V)
                })
            }

            _setUpControls() {
                this._forEachChild(z => {
                    z.setParent(this), z._registerOnCollectionChange(this._onCollectionChange)
                })
            }

            _updateValue() {
                this.value = this._reduceValue()
            }

            _anyControls(z) {
                for (const V of Object.keys(this.controls)) {
                    const _e = this.controls[V];
                    if (this.contains(V) && z(_e)) return !0
                }
                return !1
            }

            _reduceValue() {
                return this._reduceChildren({}, (z, V, _e) => ((V.enabled || this.disabled) && (z[_e] = V.value), z))
            }

            _reduceChildren(z, V) {
                let _e = z;
                return this._forEachChild((h, G) => {
                    _e = V(_e, h, G)
                }), _e
            }

            _allControlsDisabled() {
                for (const z of Object.keys(this.controls)) if (this.controls[z].enabled) return !1;
                return Object.keys(this.controls).length > 0 || this.disabled
            }
        }

        class Br extends br {
            constructor(z, V, _e) {
                super(Sn(V), Un(_e, V)), this.controls = z, this._initObservables(), this._setUpdateStrategy(V), this._setUpControls(), this.updateValueAndValidity({
                    onlySelf: !0,
                    emitEvent: !!this.asyncValidator
                })
            }

            at(z) {
                return this.controls[z]
            }

            push(z, V = {}) {
                this.controls.push(z), this._registerControl(z), this.updateValueAndValidity({emitEvent: V.emitEvent}), this._onCollectionChange()
            }

            insert(z, V, _e = {}) {
                this.controls.splice(z, 0, V), this._registerControl(V), this.updateValueAndValidity({emitEvent: _e.emitEvent})
            }

            removeAt(z, V = {}) {
                this.controls[z] && this.controls[z]._registerOnCollectionChange(() => {
                }), this.controls.splice(z, 1), this.updateValueAndValidity({emitEvent: V.emitEvent})
            }

            setControl(z, V, _e = {}) {
                this.controls[z] && this.controls[z]._registerOnCollectionChange(() => {
                }), this.controls.splice(z, 1), V && (this.controls.splice(z, 0, V), this._registerControl(V)), this.updateValueAndValidity({emitEvent: _e.emitEvent}), this._onCollectionChange()
            }

            get length() {
                return this.controls.length
            }

            setValue(z, V = {}) {
                rr(this, z), z.forEach((_e, h) => {
                    Ir(this, h), this.at(h).setValue(_e, {onlySelf: !0, emitEvent: V.emitEvent})
                }), this.updateValueAndValidity(V)
            }

            patchValue(z, V = {}) {
                null != z && (z.forEach((_e, h) => {
                    this.at(h) && this.at(h).patchValue(_e, {onlySelf: !0, emitEvent: V.emitEvent})
                }), this.updateValueAndValidity(V))
            }

            reset(z = [], V = {}) {
                this._forEachChild((_e, h) => {
                    _e.reset(z[h], {onlySelf: !0, emitEvent: V.emitEvent})
                }), this._updatePristine(V), this._updateTouched(V), this.updateValueAndValidity(V)
            }

            getRawValue() {
                return this.controls.map(z => gr(z))
            }

            clear(z = {}) {
                this.controls.length < 1 || (this._forEachChild(V => V._registerOnCollectionChange(() => {
                })), this.controls.splice(0), this.updateValueAndValidity({emitEvent: z.emitEvent}))
            }

            _syncPendingControls() {
                let z = this.controls.reduce((V, _e) => !!_e._syncPendingControls() || V, !1);
                return z && this.updateValueAndValidity({onlySelf: !0}), z
            }

            _forEachChild(z) {
                this.controls.forEach((V, _e) => {
                    z(V, _e)
                })
            }

            _updateValue() {
                this.value = this.controls.filter(z => z.enabled || this.disabled).map(z => z.value)
            }

            _anyControls(z) {
                return this.controls.some(V => V.enabled && z(V))
            }

            _setUpControls() {
                this._forEachChild(z => this._registerControl(z))
            }

            _allControlsDisabled() {
                for (const z of this.controls) if (z.enabled) return !1;
                return this.controls.length > 0 || this.disabled
            }

            _registerControl(z) {
                z.setParent(this), z._registerOnCollectionChange(this._onCollectionChange)
            }
        }

        const Zt = {provide: Xt, useExisting: (0, r.Gpc)(() => Bn)}, hn = (() => Promise.resolve(null))();
        let Bn = (() => {
            class re extends Xt {
                constructor(V, _e, h, G, m) {
                    super(), this._changeDetectorRef = m, this.control = new Vn, this._registered = !1, this.update = new r.vpe, this._parent = V, this._setValidators(_e), this._setAsyncValidators(h), this.valueAccessor = function Ut(re, z) {
                        if (!z) return null;
                        let V, _e, h;
                        return Array.isArray(z), z.forEach(G => {
                            G.constructor === Ie ? V = G : function dt(re) {
                                return Object.getPrototypeOf(re.constructor) === ae
                            }(G) ? _e = G : h = G
                        }), h || _e || V || null
                    }(0, G)
                }

                ngOnChanges(V) {
                    if (this._checkForErrors(), !this._registered || "name" in V) {
                        if (this._registered && (this._checkName(), this.formDirective)) {
                            const _e = V.name.previousValue;
                            this.formDirective.removeControl({name: _e, path: this._getPath(_e)})
                        }
                        this._setUpControl()
                    }
                    "isDisabled" in V && this._updateDisabled(V), function gt(re, z) {
                        if (!re.hasOwnProperty("model")) return !1;
                        const V = re.model;
                        return !!V.isFirstChange() || !Object.is(z, V.currentValue)
                    }(V, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model)
                }

                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeControl(this)
                }

                get path() {
                    return this._getPath(this.name)
                }

                get formDirective() {
                    return this._parent ? this._parent.formDirective : null
                }

                viewToModelUpdate(V) {
                    this.viewModel = V, this.update.emit(V)
                }

                _setUpControl() {
                    this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0
                }

                _setUpdateStrategy() {
                    this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn)
                }

                _isStandalone() {
                    return !this._parent || !(!this.options || !this.options.standalone)
                }

                _setUpStandalone() {
                    rn(this.control, this), this.control.updateValueAndValidity({emitEvent: !1})
                }

                _checkForErrors() {
                    this._isStandalone() || this._checkParentType(), this._checkName()
                }

                _checkParentType() {
                }

                _checkName() {
                    this.options && this.options.name && (this.name = this.options.name), this._isStandalone()
                }

                _updateValue(V) {
                    hn.then(() => {
                        var _e;
                        this.control.setValue(V, {emitViewToModelChange: !1}), null === (_e = this._changeDetectorRef) || void 0 === _e || _e.markForCheck()
                    })
                }

                _updateDisabled(V) {
                    const _e = V.isDisabled.currentValue, h = "" === _e || _e && "false" !== _e;
                    hn.then(() => {
                        var G;
                        h && !this.control.disabled ? this.control.disable() : !h && this.control.disabled && this.control.enable(), null === (G = this._changeDetectorRef) || void 0 === G || G.markForCheck()
                    })
                }

                _getPath(V) {
                    return this._parent ? function fn(re, z) {
                        return [...z.path, re]
                    }(V, this._parent) : [V]
                }
            }

            return re.\u0275fac = function (V) {
                return new (V || re)(r.Y36(xn, 9), r.Y36(Ue, 10), r.Y36(it, 10), r.Y36(X, 10), r.Y36(r.sBO, 8))
            }, re.\u0275dir = r.lG2({
                type: re,
                selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
                inputs: {
                    name: "name",
                    isDisabled: ["disabled", "isDisabled"],
                    model: ["ngModel", "model"],
                    options: ["ngModelOptions", "options"]
                },
                outputs: {update: "ngModelChange"},
                exportAs: ["ngModel"],
                features: [r._Bn([Zt]), r.qOj, r.TTD]
            }), re
        })(), li = (() => {
            class re {
            }

            return re.\u0275fac = function (V) {
                return new (V || re)
            }, re.\u0275mod = r.oAB({type: re}), re.\u0275inj = r.cJS({}), re
        })(), ri = (() => {
            class re {
                constructor() {
                    this._validator = g
                }

                ngOnChanges(V) {
                    if (this.inputName in V) {
                        const _e = this.normalizeInput(V[this.inputName].currentValue);
                        this._enabled = this.enabled(_e), this._validator = this._enabled ? this.createValidator(_e) : g, this._onChange && this._onChange()
                    }
                }

                validate(V) {
                    return this._validator(V)
                }

                registerOnValidatorChange(V) {
                    this._onChange = V
                }

                enabled(V) {
                    return null != V
                }
            }

            return re.\u0275fac = function (V) {
                return new (V || re)
            }, re.\u0275dir = r.lG2({type: re, features: [r.TTD]}), re
        })();
        const Zi = {provide: Ue, useExisting: (0, r.Gpc)(() => J), multi: !0};
        let J = (() => {
            class re extends ri {
                constructor() {
                    super(...arguments), this.inputName = "required", this.normalizeInput = V => function Ei(re) {
                        return null != re && !1 !== re && "false" != `${re}`
                    }(V), this.createValidator = V => Xe
                }

                enabled(V) {
                    return V
                }
            }

            return re.\u0275fac = function () {
                let z;
                return function (_e) {
                    return (z || (z = r.n5z(re)))(_e || re)
                }
            }(), re.\u0275dir = r.lG2({
                type: re,
                selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
                hostVars: 1,
                hostBindings: function (V, _e) {
                    2 & V && r.uIk("required", _e._enabled ? "" : null)
                },
                inputs: {required: "required"},
                features: [r._Bn([Zi]), r.qOj]
            }), re
        })(), yr = (() => {
            class re {
            }

            return re.\u0275fac = function (V) {
                return new (V || re)
            }, re.\u0275mod = r.oAB({type: re}), re.\u0275inj = r.cJS({imports: [[li]]}), re
        })(), Ar = (() => {
            class re {
            }

            return re.\u0275fac = function (V) {
                return new (V || re)
            }, re.\u0275mod = r.oAB({type: re}), re.\u0275inj = r.cJS({imports: [yr]}), re
        })()
    }, 2313: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {b2: () => yn, Cu: () => bn, H7: () => Qn, q6: () => Pt});
        var r = R(9808), D = R(6435);

        class ie extends r.w_ {
            constructor() {
                super(...arguments), this.supportsDOMEvents = !0
            }
        }

        class te extends ie {
            static makeCurrent() {
                (0, r.HT)(new te)
            }

            onAndCancel(vt, Qe, ht) {
                return vt.addEventListener(Qe, ht, !1), () => {
                    vt.removeEventListener(Qe, ht, !1)
                }
            }

            dispatchEvent(vt, Qe) {
                vt.dispatchEvent(Qe)
            }

            remove(vt) {
                vt.parentNode && vt.parentNode.removeChild(vt)
            }

            createElement(vt, Qe) {
                return (Qe = Qe || this.getDefaultDocument()).createElement(vt)
            }

            createHtmlDocument() {
                return document.implementation.createHTMLDocument("fakeTitle")
            }

            getDefaultDocument() {
                return document
            }

            isElementNode(vt) {
                return vt.nodeType === Node.ELEMENT_NODE
            }

            isShadowRoot(vt) {
                return vt instanceof DocumentFragment
            }

            getGlobalEventTarget(vt, Qe) {
                return "window" === Qe ? window : "document" === Qe ? vt : "body" === Qe ? vt.body : null
            }

            getBaseHref(vt) {
                const Qe = function W() {
                    return j = j || document.querySelector("base"), j ? j.getAttribute("href") : null
                }();
                return null == Qe ? null : function Ne(It) {
                    Q = Q || document.createElement("a"), Q.setAttribute("href", It);
                    const vt = Q.pathname;
                    return "/" === vt.charAt(0) ? vt : `/${vt}`
                }(Qe)
            }

            resetBaseElement() {
                j = null
            }

            getUserAgent() {
                return window.navigator.userAgent
            }

            getCookie(vt) {
                return (0, r.Mx)(document.cookie, vt)
            }
        }

        let Q, j = null;
        const ve = new D.OlP("TRANSITION_ID"), ae = [{
            provide: D.ip1, useFactory: function me(It, vt, Qe) {
                return () => {
                    Qe.get(D.CZH).donePromise.then(() => {
                        const ht = (0, r.q)(), jt = vt.querySelectorAll(`style[ng-transition="${It}"]`);
                        for (let gt = 0; gt < jt.length; gt++) ht.remove(jt[gt])
                    })
                }
            }, deps: [ve, r.K0, D.zs3], multi: !0
        }];

        class X {
            static init() {
                (0, D.VLi)(new X)
            }

            addToWindow(vt) {
                D.dqk.getAngularTestability = (ht, jt = !0) => {
                    const gt = vt.findTestabilityInTree(ht, jt);
                    if (null == gt) throw new Error("Could not find testability for element.");
                    return gt
                }, D.dqk.getAllAngularTestabilities = () => vt.getAllTestabilities(), D.dqk.getAllAngularRootElements = () => vt.getAllRootElements(), D.dqk.frameworkStabilizers || (D.dqk.frameworkStabilizers = []), D.dqk.frameworkStabilizers.push(ht => {
                    const jt = D.dqk.getAllAngularTestabilities();
                    let gt = jt.length, dt = !1;
                    const wt = function (Ut) {
                        dt = dt || Ut, gt--, 0 == gt && ht(dt)
                    };
                    jt.forEach(function (Ut) {
                        Ut.whenStable(wt)
                    })
                })
            }

            findTestabilityInTree(vt, Qe, ht) {
                if (null == Qe) return null;
                const jt = vt.getTestability(Qe);
                return null != jt ? jt : ht ? (0, r.q)().isShadowRoot(Qe) ? this.findTestabilityInTree(vt, Qe.host, !0) : this.findTestabilityInTree(vt, Qe.parentElement, !0) : null
            }
        }

        let M = (() => {
            class It {
                build() {
                    return new XMLHttpRequest
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();
        const H = new D.OlP("EventManagerPlugins");
        let F = (() => {
            class It {
                constructor(Qe, ht) {
                    this._zone = ht, this._eventNameToPlugin = new Map, Qe.forEach(jt => jt.manager = this), this._plugins = Qe.slice().reverse()
                }

                addEventListener(Qe, ht, jt) {
                    return this._findPluginFor(ht).addEventListener(Qe, ht, jt)
                }

                addGlobalEventListener(Qe, ht, jt) {
                    return this._findPluginFor(ht).addGlobalEventListener(Qe, ht, jt)
                }

                getZone() {
                    return this._zone
                }

                _findPluginFor(Qe) {
                    const ht = this._eventNameToPlugin.get(Qe);
                    if (ht) return ht;
                    const jt = this._plugins;
                    for (let gt = 0; gt < jt.length; gt++) {
                        const dt = jt[gt];
                        if (dt.supports(Qe)) return this._eventNameToPlugin.set(Qe, dt), dt
                    }
                    throw new Error(`No event manager plugin found for event ${Qe}`)
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(H), D.LFG(D.R0b))
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();

        class oe {
            constructor(vt) {
                this._doc = vt
            }

            addGlobalEventListener(vt, Qe, ht) {
                const jt = (0, r.q)().getGlobalEventTarget(this._doc, vt);
                if (!jt) throw new Error(`Unsupported event target ${jt} for event ${Qe}`);
                return this.addEventListener(jt, Qe, ht)
            }
        }

        let ge = (() => {
            class It {
                constructor() {
                    this._stylesSet = new Set
                }

                addStyles(Qe) {
                    const ht = new Set;
                    Qe.forEach(jt => {
                        this._stylesSet.has(jt) || (this._stylesSet.add(jt), ht.add(jt))
                    }), this.onStylesAdded(ht)
                }

                onStylesAdded(Qe) {
                }

                getAllStyles() {
                    return Array.from(this._stylesSet)
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })(), Ie = (() => {
            class It extends ge {
                constructor(Qe) {
                    super(), this._doc = Qe, this._hostNodes = new Map, this._hostNodes.set(Qe.head, [])
                }

                _addStylesToHost(Qe, ht, jt) {
                    Qe.forEach(gt => {
                        const dt = this._doc.createElement("style");
                        dt.textContent = gt, jt.push(ht.appendChild(dt))
                    })
                }

                addHost(Qe) {
                    const ht = [];
                    this._addStylesToHost(this._stylesSet, Qe, ht), this._hostNodes.set(Qe, ht)
                }

                removeHost(Qe) {
                    const ht = this._hostNodes.get(Qe);
                    ht && ht.forEach(he), this._hostNodes.delete(Qe)
                }

                onStylesAdded(Qe) {
                    this._hostNodes.forEach((ht, jt) => {
                        this._addStylesToHost(Qe, jt, ht)
                    })
                }

                ngOnDestroy() {
                    this._hostNodes.forEach(Qe => Qe.forEach(he))
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(r.K0))
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();

        function he(It) {
            (0, r.q)().remove(It)
        }

        const xe = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/",
            math: "http://www.w3.org/1998/MathML/"
        }, Ue = /%COMP%/g;

        function Ee(It, vt, Qe) {
            for (let ht = 0; ht < vt.length; ht++) {
                let jt = vt[ht];
                Array.isArray(jt) ? Ee(It, jt, Qe) : (jt = jt.replace(Ue, It), Qe.push(jt))
            }
            return Qe
        }

        function ce(It) {
            return vt => {
                if ("__ngUnwrap__" === vt) return It;
                !1 === It(vt) && (vt.preventDefault(), vt.returnValue = !1)
            }
        }

        let l = (() => {
            class It {
                constructor(Qe, ht, jt) {
                    this.eventManager = Qe, this.sharedStylesHost = ht, this.appId = jt, this.rendererByCompId = new Map, this.defaultRenderer = new f(Qe)
                }

                createRenderer(Qe, ht) {
                    if (!Qe || !ht) return this.defaultRenderer;
                    switch (ht.encapsulation) {
                        case D.ifc.Emulated: {
                            let jt = this.rendererByCompId.get(ht.id);
                            return jt || (jt = new w(this.eventManager, this.sharedStylesHost, ht, this.appId), this.rendererByCompId.set(ht.id, jt)), jt.applyToHost(Qe), jt
                        }
                        case 1:
                        case D.ifc.ShadowDom:
                            return new P(this.eventManager, this.sharedStylesHost, Qe, ht);
                        default:
                            if (!this.rendererByCompId.has(ht.id)) {
                                const jt = Ee(ht.id, ht.styles, []);
                                this.sharedStylesHost.addStyles(jt), this.rendererByCompId.set(ht.id, this.defaultRenderer)
                            }
                            return this.defaultRenderer
                    }
                }

                begin() {
                }

                end() {
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(F), D.LFG(Ie), D.LFG(D.AFp))
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();

        class f {
            constructor(vt) {
                this.eventManager = vt, this.data = Object.create(null), this.destroyNode = null
            }

            destroy() {
            }

            createElement(vt, Qe) {
                return Qe ? document.createElementNS(xe[Qe] || Qe, vt) : document.createElement(vt)
            }

            createComment(vt) {
                return document.createComment(vt)
            }

            createText(vt) {
                return document.createTextNode(vt)
            }

            appendChild(vt, Qe) {
                vt.appendChild(Qe)
            }

            insertBefore(vt, Qe, ht) {
                vt && vt.insertBefore(Qe, ht)
            }

            removeChild(vt, Qe) {
                vt && vt.removeChild(Qe)
            }

            selectRootElement(vt, Qe) {
                let ht = "string" == typeof vt ? document.querySelector(vt) : vt;
                if (!ht) throw new Error(`The selector "${vt}" did not match any elements`);
                return Qe || (ht.textContent = ""), ht
            }

            parentNode(vt) {
                return vt.parentNode
            }

            nextSibling(vt) {
                return vt.nextSibling
            }

            setAttribute(vt, Qe, ht, jt) {
                if (jt) {
                    Qe = jt + ":" + Qe;
                    const gt = xe[jt];
                    gt ? vt.setAttributeNS(gt, Qe, ht) : vt.setAttribute(Qe, ht)
                } else vt.setAttribute(Qe, ht)
            }

            removeAttribute(vt, Qe, ht) {
                if (ht) {
                    const jt = xe[ht];
                    jt ? vt.removeAttributeNS(jt, Qe) : vt.removeAttribute(`${ht}:${Qe}`)
                } else vt.removeAttribute(Qe)
            }

            addClass(vt, Qe) {
                vt.classList.add(Qe)
            }

            removeClass(vt, Qe) {
                vt.classList.remove(Qe)
            }

            setStyle(vt, Qe, ht, jt) {
                jt & (D.JOm.DashCase | D.JOm.Important) ? vt.style.setProperty(Qe, ht, jt & D.JOm.Important ? "important" : "") : vt.style[Qe] = ht
            }

            removeStyle(vt, Qe, ht) {
                ht & D.JOm.DashCase ? vt.style.removeProperty(Qe) : vt.style[Qe] = ""
            }

            setProperty(vt, Qe, ht) {
                vt[Qe] = ht
            }

            setValue(vt, Qe) {
                vt.nodeValue = Qe
            }

            listen(vt, Qe, ht) {
                return "string" == typeof vt ? this.eventManager.addGlobalEventListener(vt, Qe, ce(ht)) : this.eventManager.addEventListener(vt, Qe, ce(ht))
            }
        }

        class w extends f {
            constructor(vt, Qe, ht, jt) {
                super(vt), this.component = ht;
                const gt = Ee(jt + "-" + ht.id, ht.styles, []);
                Qe.addStyles(gt), this.contentAttr = function rt(It) {
                    return "_ngcontent-%COMP%".replace(Ue, It)
                }(jt + "-" + ht.id), this.hostAttr = function Xe(It) {
                    return "_nghost-%COMP%".replace(Ue, It)
                }(jt + "-" + ht.id)
            }

            applyToHost(vt) {
                super.setAttribute(vt, this.hostAttr, "")
            }

            createElement(vt, Qe) {
                const ht = super.createElement(vt, Qe);
                return super.setAttribute(ht, this.contentAttr, ""), ht
            }
        }

        class P extends f {
            constructor(vt, Qe, ht, jt) {
                super(vt), this.sharedStylesHost = Qe, this.hostEl = ht, this.shadowRoot = ht.attachShadow({mode: "open"}), this.sharedStylesHost.addHost(this.shadowRoot);
                const gt = Ee(jt.id, jt.styles, []);
                for (let dt = 0; dt < gt.length; dt++) {
                    const wt = document.createElement("style");
                    wt.textContent = gt[dt], this.shadowRoot.appendChild(wt)
                }
            }

            nodeOrShadowRoot(vt) {
                return vt === this.hostEl ? this.shadowRoot : vt
            }

            destroy() {
                this.sharedStylesHost.removeHost(this.shadowRoot)
            }

            appendChild(vt, Qe) {
                return super.appendChild(this.nodeOrShadowRoot(vt), Qe)
            }

            insertBefore(vt, Qe, ht) {
                return super.insertBefore(this.nodeOrShadowRoot(vt), Qe, ht)
            }

            removeChild(vt, Qe) {
                return super.removeChild(this.nodeOrShadowRoot(vt), Qe)
            }

            parentNode(vt) {
                return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(vt)))
            }
        }

        let B = (() => {
            class It extends oe {
                constructor(Qe) {
                    super(Qe)
                }

                supports(Qe) {
                    return !0
                }

                addEventListener(Qe, ht, jt) {
                    return Qe.addEventListener(ht, jt, !1), () => this.removeEventListener(Qe, ht, jt)
                }

                removeEventListener(Qe, ht, jt) {
                    return Qe.removeEventListener(ht, jt)
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(r.K0))
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();
        const O = ["alt", "control", "meta", "shift"], Z = {
            "\b": "Backspace",
            "\t": "Tab",
            "\x7f": "Delete",
            "\x1b": "Escape",
            Del: "Delete",
            Esc: "Escape",
            Left: "ArrowLeft",
            Right: "ArrowRight",
            Up: "ArrowUp",
            Down: "ArrowDown",
            Menu: "ContextMenu",
            Scroll: "ScrollLock",
            Win: "OS"
        }, ze = {
            A: "1",
            B: "2",
            C: "3",
            D: "4",
            E: "5",
            F: "6",
            G: "7",
            H: "8",
            I: "9",
            J: "*",
            K: "+",
            M: "-",
            N: ".",
            O: "/",
            "`": "0",
            "\x90": "NumLock"
        }, Je = {alt: It => It.altKey, control: It => It.ctrlKey, meta: It => It.metaKey, shift: It => It.shiftKey};
        let q = (() => {
            class It extends oe {
                constructor(Qe) {
                    super(Qe)
                }

                supports(Qe) {
                    return null != It.parseEventName(Qe)
                }

                addEventListener(Qe, ht, jt) {
                    const gt = It.parseEventName(ht), dt = It.eventCallback(gt.fullKey, jt, this.manager.getZone());
                    return this.manager.getZone().runOutsideAngular(() => (0, r.q)().onAndCancel(Qe, gt.domEventName, dt))
                }

                static parseEventName(Qe) {
                    const ht = Qe.toLowerCase().split("."), jt = ht.shift();
                    if (0 === ht.length || "keydown" !== jt && "keyup" !== jt) return null;
                    const gt = It._normalizeKey(ht.pop());
                    let dt = "";
                    if (O.forEach(Ut => {
                        const Qt = ht.indexOf(Ut);
                        Qt > -1 && (ht.splice(Qt, 1), dt += Ut + ".")
                    }), dt += gt, 0 != ht.length || 0 === gt.length) return null;
                    const wt = {};
                    return wt.domEventName = jt, wt.fullKey = dt, wt
                }

                static getEventFullKey(Qe) {
                    let ht = "", jt = function Le(It) {
                        let vt = It.key;
                        if (null == vt) {
                            if (vt = It.keyIdentifier, null == vt) return "Unidentified";
                            vt.startsWith("U+") && (vt = String.fromCharCode(parseInt(vt.substring(2), 16)), 3 === It.location && ze.hasOwnProperty(vt) && (vt = ze[vt]))
                        }
                        return Z[vt] || vt
                    }(Qe);
                    return jt = jt.toLowerCase(), " " === jt ? jt = "space" : "." === jt && (jt = "dot"), O.forEach(gt => {
                        gt != jt && Je[gt](Qe) && (ht += gt + ".")
                    }), ht += jt, ht
                }

                static eventCallback(Qe, ht, jt) {
                    return gt => {
                        It.getEventFullKey(gt) === Qe && jt.runGuarded(() => ht(gt))
                    }
                }

                static _normalizeKey(Qe) {
                    return "esc" === Qe ? "escape" : Qe
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(r.K0))
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();
        const Pt = (0, D.eFA)(D._c5, "browser", [{provide: D.Lbi, useValue: r.bD}, {
            provide: D.g9A,
            useValue: function ut() {
                te.makeCurrent(), X.init()
            },
            multi: !0
        }, {
            provide: r.K0, useFactory: function Mt() {
                return (0, D.RDi)(document), document
            }, deps: []
        }]), Gt = [{provide: D.zSh, useValue: "root"}, {
            provide: D.qLn, useFactory: function Ye() {
                return new D.qLn
            }, deps: []
        }, {provide: H, useClass: B, multi: !0, deps: [r.K0, D.R0b, D.Lbi]}, {
            provide: H,
            useClass: q,
            multi: !0,
            deps: [r.K0]
        }, {provide: l, useClass: l, deps: [F, Ie, D.AFp]}, {provide: D.FYo, useExisting: l}, {
            provide: ge,
            useExisting: Ie
        }, {provide: Ie, useClass: Ie, deps: [r.K0]}, {provide: D.dDg, useClass: D.dDg, deps: [D.R0b]}, {
            provide: F,
            useClass: F,
            deps: [H, D.R0b]
        }, {provide: r.JF, useClass: M, deps: []}];
        let yn = (() => {
            class It {
                constructor(Qe) {
                    if (Qe) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")
                }

                static withServerTransition(Qe) {
                    return {
                        ngModule: It,
                        providers: [{provide: D.AFp, useValue: Qe.appId}, {provide: ve, useExisting: D.AFp}, ae]
                    }
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(It, 12))
            }, It.\u0275mod = D.oAB({type: It}), It.\u0275inj = D.cJS({providers: Gt, imports: [r.ez, D.hGG]}), It
        })();
        "undefined" != typeof window && window;
        let Bt = (() => {
            class It {
                constructor() {
                    this.store = {}, this.onSerializeCallbacks = {}
                }

                static init(Qe) {
                    const ht = new It;
                    return ht.store = Qe, ht
                }

                get(Qe, ht) {
                    return void 0 !== this.store[Qe] ? this.store[Qe] : ht
                }

                set(Qe, ht) {
                    this.store[Qe] = ht
                }

                remove(Qe) {
                    delete this.store[Qe]
                }

                hasKey(Qe) {
                    return this.store.hasOwnProperty(Qe)
                }

                onSerialize(Qe, ht) {
                    this.onSerializeCallbacks[Qe] = ht
                }

                toJson() {
                    for (const Qe in this.onSerializeCallbacks) if (this.onSerializeCallbacks.hasOwnProperty(Qe)) try {
                        this.store[Qe] = this.onSerializeCallbacks[Qe]()
                    } catch (ht) {
                        console.warn("Exception in onSerialize callback: ", ht)
                    }
                    return JSON.stringify(this.store)
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)
            }, It.\u0275prov = D.Yz7({token: It, factory: It.\u0275fac}), It
        })();

        function Ht(It, vt) {
            const Qe = It.getElementById(vt + "-state");
            let ht = {};
            if (Qe && Qe.textContent) try {
                ht = JSON.parse(function zt(It) {
                    const vt = {"&a;": "&", "&q;": '"', "&s;": "'", "&l;": "<", "&g;": ">"};
                    return It.replace(/&[^;]+;/g, Qe => vt[Qe])
                }(Qe.textContent))
            } catch (jt) {
                console.warn("Exception while restoring TransferState for app " + vt, jt)
            }
            return Bt.init(ht)
        }

        let bn = (() => {
            class It {
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)
            }, It.\u0275mod = D.oAB({type: It}), It.\u0275inj = D.cJS({
                providers: [{
                    provide: Bt,
                    useFactory: Ht,
                    deps: [r.K0, D.AFp]
                }]
            }), It
        })(), Qn = (() => {
            class It {
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)
            }, It.\u0275prov = D.Yz7({
                token: It, factory: function (Qe) {
                    let ht = null;
                    return ht = Qe ? new (Qe || It) : D.LFG(Xn), ht
                }, providedIn: "root"
            }), It
        })(), Xn = (() => {
            class It extends Qn {
                constructor(Qe) {
                    super(), this._doc = Qe
                }

                sanitize(Qe, ht) {
                    if (null == ht) return null;
                    switch (Qe) {
                        case D.q3G.NONE:
                            return ht;
                        case D.q3G.HTML:
                            return (0, D.qzn)(ht, "HTML") ? (0, D.z3N)(ht) : (0, D.EiD)(this._doc, String(ht)).toString();
                        case D.q3G.STYLE:
                            return (0, D.qzn)(ht, "Style") ? (0, D.z3N)(ht) : ht;
                        case D.q3G.SCRIPT:
                            if ((0, D.qzn)(ht, "Script")) return (0, D.z3N)(ht);
                            throw new Error("unsafe value used in a script context");
                        case D.q3G.URL:
                            return (0, D.yhl)(ht), (0, D.qzn)(ht, "URL") ? (0, D.z3N)(ht) : (0, D.mCW)(String(ht));
                        case D.q3G.RESOURCE_URL:
                            if ((0, D.qzn)(ht, "ResourceURL")) return (0, D.z3N)(ht);
                            throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
                        default:
                            throw new Error(`Unexpected SecurityContext ${Qe} (see https://g.co/ng/security#xss)`)
                    }
                }

                bypassSecurityTrustHtml(Qe) {
                    return (0, D.JVY)(Qe)
                }

                bypassSecurityTrustStyle(Qe) {
                    return (0, D.L6k)(Qe)
                }

                bypassSecurityTrustScript(Qe) {
                    return (0, D.eBb)(Qe)
                }

                bypassSecurityTrustUrl(Qe) {
                    return (0, D.LAX)(Qe)
                }

                bypassSecurityTrustResourceUrl(Qe) {
                    return (0, D.pB0)(Qe)
                }
            }

            return It.\u0275fac = function (Qe) {
                return new (Qe || It)(D.LFG(r.K0))
            }, It.\u0275prov = D.Yz7({
                token: It, factory: function (Qe) {
                    let ht = null;
                    return ht = Qe ? new Qe : function Wn(It) {
                        return new Xn(It.get(r.K0))
                    }(D.LFG(D.zs3)), ht
                }, providedIn: "root"
            }), It
        })()
    }, 9800: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {
            gz: () => ei,
            y6: () => z,
            OD: () => bn,
            eC: () => ht,
            wm: () => Ls,
            wN: () => Ss,
            F0: () => di,
            rH: () => ks,
            Bz: () => qs,
            Hx: () => We
        });
        var r = R(6435), D = R(2866), ie = R(6688), te = R(3489);

        class j extends te.L {
            notifyNext(x, y, L, ue, Fe) {
                this.destination.next(y)
            }

            notifyError(x, y) {
                this.destination.error(x)
            }

            notifyComplete(x) {
                this.destination.complete()
            }
        }

        class W extends te.L {
            constructor(x, y, L) {
                super(), this.parent = x, this.outerValue = y, this.outerIndex = L, this.index = 0
            }

            _next(x) {
                this.parent.notifyNext(this.outerValue, x, this.outerIndex, this.index++, this)
            }

            _error(x) {
                this.parent.notifyError(x, this), this.unsubscribe()
            }

            _complete() {
                this.parent.notifyComplete(this), this.unsubscribe()
            }
        }

        var Q = R(9249), Ne = R(2916);

        function ve(A, x, y, L, ue = new W(A, y, L)) {
            if (!ue.closed) return x instanceof Ne.y ? x.subscribe(ue) : (0, Q.s)(x)(ue)
        }

        var me = R(3009);
        const ae = {};

        class M {
            constructor(x) {
                this.resultSelector = x
            }

            call(x, y) {
                return y.subscribe(new H(x, this.resultSelector))
            }
        }

        class H extends j {
            constructor(x, y) {
                super(x), this.resultSelector = y, this.active = 0, this.values = [], this.observables = []
            }

            _next(x) {
                this.values.push(ae), this.observables.push(x)
            }

            _complete() {
                const x = this.observables, y = x.length;
                if (0 === y) this.destination.complete(); else {
                    this.active = y, this.toRespond = y;
                    for (let L = 0; L < y; L++) this.add(ve(this, x[L], void 0, L))
                }
            }

            notifyComplete(x) {
                0 == (this.active -= 1) && this.destination.complete()
            }

            notifyNext(x, y, L) {
                const ue = this.values, ft = this.toRespond ? ue[L] === ae ? --this.toRespond : this.toRespond : 0;
                ue[L] = y, 0 === ft && (this.resultSelector ? this._tryResultSelector(ue) : this.destination.next(ue.slice()))
            }

            _tryResultSelector(x) {
                let y;
                try {
                    y = this.resultSelector.apply(this, x)
                } catch (L) {
                    return void this.destination.error(L)
                }
                this.destination.next(y)
            }
        }

        function F(A, x) {
            return new Ne.y(x ? y => x.schedule(oe, 0, {error: A, subscriber: y}) : y => y.error(A))
        }

        function oe({error: A, subscriber: x}) {
            x.error(A)
        }

        const Ie = (() => {
            function A() {
                return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this
            }

            return A.prototype = Object.create(Error.prototype), A
        })();
        var he = R(1086), xe = R(9146);

        function it(...A) {
            return function Ue() {
                return (0, xe.J)(1)
            }()((0, he.of)(...A))
        }

        var yt = R(5254);
        const Ce = new Ne.y(A => A.complete());

        function $e(A) {
            return A ? function rt(A) {
                return new Ne.y(x => A.schedule(() => x.complete()))
            }(A) : Ce
        }

        function Xe(A) {
            return new Ne.y(x => {
                let y;
                try {
                    y = A()
                } catch (ue) {
                    return void x.error(ue)
                }
                return (y ? (0, yt.D)(y) : $e()).subscribe(x)
            })
        }

        var Ee = R(591), ce = R(1762), I = R(5529);
        const f = (() => {
            function A() {
                return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this
            }

            return A.prototype = Object.create(Error.prototype), A
        })();

        function g(A) {
            return x => 0 === A ? $e() : x.lift(new v(A))
        }

        class v {
            constructor(x) {
                if (this.total = x, this.total < 0) throw new f
            }

            call(x, y) {
                return y.subscribe(new w(x, this.total))
            }
        }

        class w extends te.L {
            constructor(x, y) {
                super(x), this.total = y, this.count = 0
            }

            _next(x) {
                const y = this.total, L = ++this.count;
                L <= y && (this.destination.next(x), L === y && (this.destination.complete(), this.unsubscribe()))
            }
        }

        function B(A, x) {
            let y = !1;
            return arguments.length >= 2 && (y = !0), function (ue) {
                return ue.lift(new O(A, x, y))
            }
        }

        class O {
            constructor(x, y, L = !1) {
                this.accumulator = x, this.seed = y, this.hasSeed = L
            }

            call(x, y) {
                return y.subscribe(new E(x, this.accumulator, this.seed, this.hasSeed))
            }
        }

        class E extends te.L {
            constructor(x, y, L, ue) {
                super(x), this.accumulator = y, this._seed = L, this.hasSeed = ue, this.index = 0
            }

            get seed() {
                return this._seed
            }

            set seed(x) {
                this.hasSeed = !0, this._seed = x
            }

            _next(x) {
                if (this.hasSeed) return this._tryNext(x);
                this.seed = x, this.destination.next(x)
            }

            _tryNext(x) {
                const y = this.index++;
                let L;
                try {
                    L = this.accumulator(this.seed, x, y)
                } catch (ue) {
                    this.destination.error(ue)
                }
                this.seed = L, this.destination.next(L)
            }
        }

        var Z = R(1177);

        function ze(A) {
            return function (y) {
                const L = new Je(A), ue = y.lift(L);
                return L.caught = ue
            }
        }

        class Je {
            constructor(x) {
                this.selector = x
            }

            call(x, y) {
                return y.subscribe(new q(x, this.selector, this.caught))
            }
        }

        class q extends Z.Ds {
            constructor(x, y, L) {
                super(x), this.selector = y, this.caught = L
            }

            error(x) {
                if (!this.isStopped) {
                    let y;
                    try {
                        y = this.selector(x, this.caught)
                    } catch (Fe) {
                        return void super.error(Fe)
                    }
                    this._unsubscribeAndRecycle();
                    const L = new Z.IY(this);
                    this.add(L);
                    const ue = (0, Z.ft)(y, L);
                    ue !== L && this.add(ue)
                }
            }
        }

        var Le = R(2198);

        function ut(A) {
            return function (y) {
                return 0 === A ? $e() : y.lift(new Ye(A))
            }
        }

        class Ye {
            constructor(x) {
                if (this.total = x, this.total < 0) throw new f
            }

            call(x, y) {
                return y.subscribe(new Mt(x, this.total))
            }
        }

        class Mt extends te.L {
            constructor(x, y) {
                super(x), this.total = y, this.ring = new Array, this.count = 0
            }

            _next(x) {
                const y = this.ring, L = this.total, ue = this.count++;
                y.length < L ? y.push(x) : y[ue % L] = x
            }

            _complete() {
                const x = this.destination;
                let y = this.count;
                if (y > 0) {
                    const L = this.count >= this.total ? this.total : this.count, ue = this.ring;
                    for (let Fe = 0; Fe < L; Fe++) {
                        const ft = y++ % L;
                        x.next(ue[ft])
                    }
                }
                x.complete()
            }
        }

        function _t(A = yn) {
            return x => x.lift(new Pt(A))
        }

        class Pt {
            constructor(x) {
                this.errorFactory = x
            }

            call(x, y) {
                return y.subscribe(new Gt(x, this.errorFactory))
            }
        }

        class Gt extends te.L {
            constructor(x, y) {
                super(x), this.errorFactory = y, this.hasValue = !1
            }

            _next(x) {
                this.hasValue = !0, this.destination.next(x)
            }

            _complete() {
                if (this.hasValue) return this.destination.complete();
                {
                    let x;
                    try {
                        x = this.errorFactory()
                    } catch (y) {
                        x = y
                    }
                    this.destination.error(x)
                }
            }
        }

        function yn() {
            return new Ie
        }

        function Xt(A = null) {
            return x => x.lift(new xn(A))
        }

        class xn {
            constructor(x) {
                this.defaultValue = x
            }

            call(x, y) {
                return y.subscribe(new Fn(x, this.defaultValue))
            }
        }

        class Fn extends te.L {
            constructor(x, y) {
                super(x), this.defaultValue = y, this.isEmpty = !0
            }

            _next(x) {
                this.isEmpty = !1, this.destination.next(x)
            }

            _complete() {
                this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete()
            }
        }

        var wn = R(5379);

        function On(A, x) {
            const y = arguments.length >= 2;
            return L => L.pipe(A ? (0, Le.h)((ue, Fe) => A(ue, Fe, L)) : wn.y, g(1), y ? Xt(x) : _t(() => new Ie))
        }

        function Me() {
        }

        var ne = R(7043);

        function U(A, x, y) {
            return function (ue) {
                return ue.lift(new de(A, x, y))
            }
        }

        class de {
            constructor(x, y, L) {
                this.nextOrObserver = x, this.error = y, this.complete = L
            }

            call(x, y) {
                return y.subscribe(new Ze(x, this.nextOrObserver, this.error, this.complete))
            }
        }

        class Ze extends te.L {
            constructor(x, y, L, ue) {
                super(x), this._tapNext = Me, this._tapError = Me, this._tapComplete = Me, this._tapError = L || Me, this._tapComplete = ue || Me, (0, ne.m)(y) ? (this._context = this, this._tapNext = y) : y && (this._context = y, this._tapNext = y.next || Me, this._tapError = y.error || Me, this._tapComplete = y.complete || Me)
            }

            _next(x) {
                try {
                    this._tapNext.call(this._context, x)
                } catch (y) {
                    return void this.destination.error(y)
                }
                this.destination.next(x)
            }

            _error(x) {
                try {
                    this._tapError.call(this._context, x)
                } catch (y) {
                    return void this.destination.error(y)
                }
                this.destination.error(x)
            }

            _complete() {
                try {
                    this._tapComplete.call(this._context)
                } catch (x) {
                    return void this.destination.error(x)
                }
                return this.destination.complete()
            }
        }

        var Ge = R(2654);

        class Te {
            constructor(x) {
                this.callback = x
            }

            call(x, y) {
                return y.subscribe(new Be(x, this.callback))
            }
        }

        class Be extends te.L {
            constructor(x, y) {
                super(x), this.add(new Ge.w(y))
            }
        }

        var tt = R(4850), Dt = R(7545), Ft = R(1406), zt = R(1709), dn = R(4327), Bt = R(9808);

        class Ht {
            constructor(x, y) {
                this.id = x, this.url = y
            }
        }

        class bn extends Ht {
            constructor(x, y, L = "imperative", ue = null) {
                super(x, y), this.navigationTrigger = L, this.restoredState = ue
            }

            toString() {
                return `NavigationStart(id: ${this.id}, url: '${this.url}')`
            }
        }

        class fn extends Ht {
            constructor(x, y, L) {
                super(x, y), this.urlAfterRedirects = L
            }

            toString() {
                return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
            }
        }

        class rn extends Ht {
            constructor(x, y, L) {
                super(x, y), this.reason = L
            }

            toString() {
                return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
            }
        }

        class gn extends Ht {
            constructor(x, y, L) {
                super(x, y), this.error = L
            }

            toString() {
                return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
            }
        }

        class Hn extends Ht {
            constructor(x, y, L, ue) {
                super(x, y), this.urlAfterRedirects = L, this.state = ue
            }

            toString() {
                return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
            }
        }

        class jn extends Ht {
            constructor(x, y, L, ue) {
                super(x, y), this.urlAfterRedirects = L, this.state = ue
            }

            toString() {
                return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
            }
        }

        class fr extends Ht {
            constructor(x, y, L, ue, Fe) {
                super(x, y), this.urlAfterRedirects = L, this.state = ue, this.shouldActivate = Fe
            }

            toString() {
                return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
            }
        }

        class qn extends Ht {
            constructor(x, y, L, ue) {
                super(x, y), this.urlAfterRedirects = L, this.state = ue
            }

            toString() {
                return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
            }
        }

        class Yn extends Ht {
            constructor(x, y, L, ue) {
                super(x, y), this.urlAfterRedirects = L, this.state = ue
            }

            toString() {
                return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
            }
        }

        class Qn {
            constructor(x) {
                this.route = x
            }

            toString() {
                return `RouteConfigLoadStart(path: ${this.route.path})`
            }
        }

        class Wn {
            constructor(x) {
                this.route = x
            }

            toString() {
                return `RouteConfigLoadEnd(path: ${this.route.path})`
            }
        }

        class Xn {
            constructor(x) {
                this.snapshot = x
            }

            toString() {
                return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
            }
        }

        class Dr {
            constructor(x) {
                this.snapshot = x
            }

            toString() {
                return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
            }
        }

        class It {
            constructor(x) {
                this.snapshot = x
            }

            toString() {
                return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
            }
        }

        class vt {
            constructor(x) {
                this.snapshot = x
            }

            toString() {
                return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
            }
        }

        class Qe {
            constructor(x, y, L) {
                this.routerEvent = x, this.position = y, this.anchor = L
            }

            toString() {
                return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')`
            }
        }

        const ht = "primary";

        class jt {
            constructor(x) {
                this.params = x || {}
            }

            has(x) {
                return Object.prototype.hasOwnProperty.call(this.params, x)
            }

            get(x) {
                if (this.has(x)) {
                    const y = this.params[x];
                    return Array.isArray(y) ? y[0] : y
                }
                return null
            }

            getAll(x) {
                if (this.has(x)) {
                    const y = this.params[x];
                    return Array.isArray(y) ? y : [y]
                }
                return []
            }

            get keys() {
                return Object.keys(this.params)
            }
        }

        function gt(A) {
            return new jt(A)
        }

        const dt = "ngNavigationCancelingError";

        function wt(A) {
            const x = Error("NavigationCancelingError: " + A);
            return x[dt] = !0, x
        }

        function Qt(A, x, y) {
            const L = y.path.split("/");
            if (L.length > A.length || "full" === y.pathMatch && (x.hasChildren() || L.length < A.length)) return null;
            const ue = {};
            for (let Fe = 0; Fe < L.length; Fe++) {
                const ft = L[Fe], At = A[Fe];
                if (ft.startsWith(":")) ue[ft.substring(1)] = At; else if (ft !== At.path) return null
            }
            return {consumed: A.slice(0, L.length), posParams: ue}
        }

        function un(A, x) {
            const y = A ? Object.keys(A) : void 0, L = x ? Object.keys(x) : void 0;
            if (!y || !L || y.length != L.length) return !1;
            let ue;
            for (let Fe = 0; Fe < y.length; Fe++) if (ue = y[Fe], !Pn(A[ue], x[ue])) return !1;
            return !0
        }

        function Pn(A, x) {
            if (Array.isArray(A) && Array.isArray(x)) {
                if (A.length !== x.length) return !1;
                const y = [...A].sort(), L = [...x].sort();
                return y.every((ue, Fe) => L[Fe] === ue)
            }
            return A === x
        }

        function mn(A) {
            return Array.prototype.concat.apply([], A)
        }

        function Mn(A) {
            return A.length > 0 ? A[A.length - 1] : null
        }

        function En(A, x) {
            for (const y in A) A.hasOwnProperty(y) && x(A[y], y)
        }

        function Sn(A) {
            return (0, r.CqO)(A) ? A : (0, r.QGY)(A) ? (0, yt.D)(Promise.resolve(A)) : (0, he.of)(A)
        }

        const Un = {
            exact: function nr(A, x, y) {
                if (!_r(A.segments, x.segments) || !rr(A.segments, x.segments, y) || A.numberOfChildren !== x.numberOfChildren) return !1;
                for (const L in x.children) if (!A.children[L] || !nr(A.children[L], x.children[L], y)) return !1;
                return !0
            }, subset: gr
        }, nn = {
            exact: function tr(A, x) {
                return un(A, x)
            }, subset: function Er(A, x) {
                return Object.keys(x).length <= Object.keys(A).length && Object.keys(x).every(y => Pn(A[y], x[y]))
            }, ignored: () => !0
        };

        function _n(A, x, y) {
            return Un[y.paths](A.root, x.root, y.matrixParams) && nn[y.queryParams](A.queryParams, x.queryParams) && !("exact" === y.fragment && A.fragment !== x.fragment)
        }

        function gr(A, x, y) {
            return Ir(A, x, x.segments, y)
        }

        function Ir(A, x, y, L) {
            if (A.segments.length > y.length) {
                const ue = A.segments.slice(0, y.length);
                return !(!_r(ue, y) || x.hasChildren() || !rr(ue, y, L))
            }
            if (A.segments.length === y.length) {
                if (!_r(A.segments, y) || !rr(A.segments, y, L)) return !1;
                for (const ue in x.children) if (!A.children[ue] || !gr(A.children[ue], x.children[ue], L)) return !1;
                return !0
            }
            {
                const ue = y.slice(0, A.segments.length), Fe = y.slice(A.segments.length);
                return !!(_r(A.segments, ue) && rr(A.segments, ue, L) && A.children[ht]) && Ir(A.children[ht], x, Fe, L)
            }
        }

        function rr(A, x, y) {
            return x.every((L, ue) => nn[y](A[ue].parameters, L.parameters))
        }

        class br {
            constructor(x, y, L) {
                this.root = x, this.queryParams = y, this.fragment = L
            }

            get queryParamMap() {
                return this._queryParamMap || (this._queryParamMap = gt(this.queryParams)), this._queryParamMap
            }

            toString() {
                return Ot.serialize(this)
            }
        }

        class Vn {
            constructor(x, y) {
                this.segments = x, this.children = y, this.parent = null, En(y, (L, ue) => L.parent = this)
            }

            hasChildren() {
                return this.numberOfChildren > 0
            }

            get numberOfChildren() {
                return Object.keys(this.children).length
            }

            toString() {
                return Ke(this)
            }
        }

        class $n {
            constructor(x, y) {
                this.path = x, this.parameters = y
            }

            get parameterMap() {
                return this._parameterMap || (this._parameterMap = gt(this.parameters)), this._parameterMap
            }

            toString() {
                return Zn(this)
            }
        }

        function _r(A, x) {
            return A.length === x.length && A.every((y, L) => y.path === x[L].path)
        }

        class We {
        }

        class Et {
            parse(x) {
                const y = new ki(x);
                return new br(y.parseRootSegment(), y.parseQueryParams(), y.parseFragment())
            }

            serialize(x) {
                const y = `/${at(x.root, !0)}`, L = function xr(A) {
                    const x = Object.keys(A).map(y => {
                        const L = A[y];
                        return Array.isArray(L) ? L.map(ue => `${Kt(y)}=${Kt(ue)}`).join("&") : `${Kt(y)}=${Kt(L)}`
                    }).filter(y => !!y);
                    return x.length ? `?${x.join("&")}` : ""
                }(x.queryParams);
                return `${y}${L}${"string" == typeof x.fragment ? `#${function qt(A) {
                    return encodeURI(A)
                }(x.fragment)}` : ""}`
            }
        }

        const Ot = new Et;

        function Ke(A) {
            return A.segments.map(x => Zn(x)).join("/")
        }

        function at(A, x) {
            if (!A.hasChildren()) return Ke(A);
            if (x) {
                const y = A.children[ht] ? at(A.children[ht], !1) : "", L = [];
                return En(A.children, (ue, Fe) => {
                    Fe !== ht && L.push(`${Fe}:${at(ue, !1)}`)
                }), L.length > 0 ? `${y}(${L.join("//")})` : y
            }
            {
                const y = function Pe(A, x) {
                    let y = [];
                    return En(A.children, (L, ue) => {
                        ue === ht && (y = y.concat(x(L, ue)))
                    }), En(A.children, (L, ue) => {
                        ue !== ht && (y = y.concat(x(L, ue)))
                    }), y
                }(A, (L, ue) => ue === ht ? [at(A.children[ht], !1)] : [`${ue}:${at(L, !1)}`]);
                return 1 === Object.keys(A.children).length && null != A.children[ht] ? `${Ke(A)}/${y[0]}` : `${Ke(A)}/(${y.join("//")})`
            }
        }

        function Ct(A) {
            return encodeURIComponent(A).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
        }

        function Kt(A) {
            return Ct(A).replace(/%3B/gi, ";")
        }

        function Zt(A) {
            return Ct(A).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
        }

        function hn(A) {
            return decodeURIComponent(A)
        }

        function Bn(A) {
            return hn(A.replace(/\+/g, "%20"))
        }

        function Zn(A) {
            return `${Zt(A.path)}${function lr(A) {
                return Object.keys(A).map(x => `;${Zt(x)}=${Zt(A[x])}`).join("")
            }(A.parameters)}`
        }

        const $r = /^[^\/()?;=#]+/;

        function Nr(A) {
            const x = A.match($r);
            return x ? x[0] : ""
        }

        const li = /^[^=?&#]+/, hi = /^[^&#]+/;

        class ki {
            constructor(x) {
                this.url = x, this.remaining = x
            }

            parseRootSegment() {
                return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Vn([], {}) : new Vn([], this.parseChildren())
            }

            parseQueryParams() {
                const x = {};
                if (this.consumeOptional("?")) do {
                    this.parseQueryParam(x)
                } while (this.consumeOptional("&"));
                return x
            }

            parseFragment() {
                return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
            }

            parseChildren() {
                if ("" === this.remaining) return {};
                this.consumeOptional("/");
                const x = [];
                for (this.peekStartsWith("(") || x.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), x.push(this.parseSegment());
                let y = {};
                this.peekStartsWith("/(") && (this.capture("/"), y = this.parseParens(!0));
                let L = {};
                return this.peekStartsWith("(") && (L = this.parseParens(!1)), (x.length > 0 || Object.keys(y).length > 0) && (L[ht] = new Vn(x, y)), L
            }

            parseSegment() {
                const x = Nr(this.remaining);
                if ("" === x && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);
                return this.capture(x), new $n(hn(x), this.parseMatrixParams())
            }

            parseMatrixParams() {
                const x = {};
                for (; this.consumeOptional(";");) this.parseParam(x);
                return x
            }

            parseParam(x) {
                const y = Nr(this.remaining);
                if (!y) return;
                this.capture(y);
                let L = "";
                if (this.consumeOptional("=")) {
                    const ue = Nr(this.remaining);
                    ue && (L = ue, this.capture(L))
                }
                x[hn(y)] = hn(L)
            }

            parseQueryParam(x) {
                const y = function Ci(A) {
                    const x = A.match(li);
                    return x ? x[0] : ""
                }(this.remaining);
                if (!y) return;
                this.capture(y);
                let L = "";
                if (this.consumeOptional("=")) {
                    const ft = function $i(A) {
                        const x = A.match(hi);
                        return x ? x[0] : ""
                    }(this.remaining);
                    ft && (L = ft, this.capture(L))
                }
                const ue = Bn(y), Fe = Bn(L);
                if (x.hasOwnProperty(ue)) {
                    let ft = x[ue];
                    Array.isArray(ft) || (ft = [ft], x[ue] = ft), ft.push(Fe)
                } else x[ue] = Fe
            }

            parseParens(x) {
                const y = {};
                for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
                    const L = Nr(this.remaining), ue = this.remaining[L.length];
                    if ("/" !== ue && ")" !== ue && ";" !== ue) throw new Error(`Cannot parse url '${this.url}'`);
                    let Fe;
                    L.indexOf(":") > -1 ? (Fe = L.substr(0, L.indexOf(":")), this.capture(Fe), this.capture(":")) : x && (Fe = ht);
                    const ft = this.parseChildren();
                    y[Fe] = 1 === Object.keys(ft).length ? ft[ht] : new Vn([], ft), this.consumeOptional("//")
                }
                return y
            }

            peekStartsWith(x) {
                return this.remaining.startsWith(x)
            }

            consumeOptional(x) {
                return !!this.peekStartsWith(x) && (this.remaining = this.remaining.substring(x.length), !0)
            }

            capture(x) {
                if (!this.consumeOptional(x)) throw new Error(`Expected "${x}".`)
            }
        }

        class Pi {
            constructor(x) {
                this._root = x
            }

            get root() {
                return this._root.value
            }

            parent(x) {
                const y = this.pathFromRoot(x);
                return y.length > 1 ? y[y.length - 2] : null
            }

            children(x) {
                const y = Fi(x, this._root);
                return y ? y.children.map(L => L.value) : []
            }

            firstChild(x) {
                const y = Fi(x, this._root);
                return y && y.children.length > 0 ? y.children[0].value : null
            }

            siblings(x) {
                const y = Oi(x, this._root);
                return y.length < 2 ? [] : y[y.length - 2].children.map(ue => ue.value).filter(ue => ue !== x)
            }

            pathFromRoot(x) {
                return Oi(x, this._root).map(y => y.value)
            }
        }

        function Fi(A, x) {
            if (A === x.value) return x;
            for (const y of x.children) {
                const L = Fi(A, y);
                if (L) return L
            }
            return null
        }

        function Oi(A, x) {
            if (A === x.value) return [x];
            for (const y of x.children) {
                const L = Oi(A, y);
                if (L.length) return L.unshift(x), L
            }
            return []
        }

        class Qr {
            constructor(x, y) {
                this.value = x, this.children = y
            }

            toString() {
                return `TreeNode(${this.value})`
            }
        }

        function ci(A) {
            const x = {};
            return A && A.children.forEach(y => x[y.value.outlet] = y), x
        }

        class Vi extends Pi {
            constructor(x, y) {
                super(x), this.snapshot = y, gi(this, x)
            }

            toString() {
                return this.snapshot.toString()
            }
        }

        function pi(A, x) {
            const y = function Wi(A, x) {
                    const ft = new wi([], {}, {}, "", {}, ht, x, null, A.root, -1, {});
                    return new ui("", new Qr(ft, []))
                }(A, x), L = new Ee.X([new $n("", {})]), ue = new Ee.X({}), Fe = new Ee.X({}), ft = new Ee.X({}),
                At = new Ee.X(""), en = new ei(L, ue, ft, At, Fe, ht, x, y.root);
            return en.snapshot = y.root, new Vi(new Qr(en, []), y)
        }

        class ei {
            constructor(x, y, L, ue, Fe, ft, At, en) {
                this.url = x, this.params = y, this.queryParams = L, this.fragment = ue, this.data = Fe, this.outlet = ft, this.component = At, this._futureSnapshot = en
            }

            get routeConfig() {
                return this._futureSnapshot.routeConfig
            }

            get root() {
                return this._routerState.root
            }

            get parent() {
                return this._routerState.parent(this)
            }

            get firstChild() {
                return this._routerState.firstChild(this)
            }

            get children() {
                return this._routerState.children(this)
            }

            get pathFromRoot() {
                return this._routerState.pathFromRoot(this)
            }

            get paramMap() {
                return this._paramMap || (this._paramMap = this.params.pipe((0, tt.U)(x => gt(x)))), this._paramMap
            }

            get queryParamMap() {
                return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, tt.U)(x => gt(x)))), this._queryParamMap
            }

            toString() {
                return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
            }
        }

        function xi(A, x = "emptyOnly") {
            const y = A.pathFromRoot;
            let L = 0;
            if ("always" !== x) for (L = y.length - 1; L >= 1;) {
                const ue = y[L], Fe = y[L - 1];
                if (ue.routeConfig && "" === ue.routeConfig.path) L--; else {
                    if (Fe.component) break;
                    L--
                }
            }
            return function Ui(A) {
                return A.reduce((x, y) => ({
                    params: Object.assign(Object.assign({}, x.params), y.params),
                    data: Object.assign(Object.assign({}, x.data), y.data),
                    resolve: Object.assign(Object.assign({}, x.resolve), y._resolvedData)
                }), {params: {}, data: {}, resolve: {}})
            }(y.slice(L))
        }

        class wi {
            constructor(x, y, L, ue, Fe, ft, At, en, zn, Cr, Kn) {
                this.url = x, this.params = y, this.queryParams = L, this.fragment = ue, this.data = Fe, this.outlet = ft, this.component = At, this.routeConfig = en, this._urlSegment = zn, this._lastPathIndex = Cr, this._resolve = Kn
            }

            get root() {
                return this._routerState.root
            }

            get parent() {
                return this._routerState.parent(this)
            }

            get firstChild() {
                return this._routerState.firstChild(this)
            }

            get children() {
                return this._routerState.children(this)
            }

            get pathFromRoot() {
                return this._routerState.pathFromRoot(this)
            }

            get paramMap() {
                return this._paramMap || (this._paramMap = gt(this.params)), this._paramMap
            }

            get queryParamMap() {
                return this._queryParamMap || (this._queryParamMap = gt(this.queryParams)), this._queryParamMap
            }

            toString() {
                return `Route(url:'${this.url.map(L => L.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')`
            }
        }

        class ui extends Pi {
            constructor(x, y) {
                super(y), this.url = x, gi(this, y)
            }

            toString() {
                return Si(this._root)
            }
        }

        function gi(A, x) {
            x.value._routerState = A, x.children.forEach(y => gi(A, y))
        }

        function Si(A) {
            const x = A.children.length > 0 ? ` { ${A.children.map(Si).join(", ")} } ` : "";
            return `${A.value}${x}`
        }

        function mi(A) {
            if (A.snapshot) {
                const x = A.snapshot, y = A._futureSnapshot;
                A.snapshot = y, un(x.queryParams, y.queryParams) || A.queryParams.next(y.queryParams), x.fragment !== y.fragment && A.fragment.next(y.fragment), un(x.params, y.params) || A.params.next(y.params), function sn(A, x) {
                    if (A.length !== x.length) return !1;
                    for (let y = 0; y < A.length; ++y) if (!un(A[y], x[y])) return !1;
                    return !0
                }(x.url, y.url) || A.url.next(y.url), un(x.data, y.data) || A.data.next(y.data)
            } else A.snapshot = A._futureSnapshot, A.data.next(A._futureSnapshot.data)
        }

        function Xr(A, x) {
            const y = un(A.params, x.params) && function Br(A, x) {
                return _r(A, x) && A.every((y, L) => un(y.parameters, x[L].parameters))
            }(A.url, x.url);
            return y && !(!A.parent != !x.parent) && (!A.parent || Xr(A.parent, x.parent))
        }

        function Hr(A, x, y) {
            if (y && A.shouldReuseRoute(x.value, y.value.snapshot)) {
                const L = y.value;
                L._futureSnapshot = x.value;
                const ue = function si(A, x, y) {
                    return x.children.map(L => {
                        for (const ue of y.children) if (A.shouldReuseRoute(L.value, ue.value.snapshot)) return Hr(A, L, ue);
                        return Hr(A, L)
                    })
                }(A, x, y);
                return new Qr(L, ue)
            }
            {
                if (A.shouldAttach(x.value)) {
                    const Fe = A.retrieve(x.value);
                    if (null !== Fe) {
                        const ft = Fe.route;
                        return ft.value._futureSnapshot = x.value, ft.children = x.children.map(At => Hr(A, At)), ft
                    }
                }
                const L = function vi(A) {
                    return new ei(new Ee.X(A.url), new Ee.X(A.params), new Ee.X(A.queryParams), new Ee.X(A.fragment), new Ee.X(A.data), A.outlet, A.component, A)
                }(x.value), ue = x.children.map(Fe => Hr(A, Fe));
                return new Qr(L, ue)
            }
        }

        function ni(A) {
            return "object" == typeof A && null != A && !A.outlets && !A.segmentPath
        }

        function oi(A) {
            return "object" == typeof A && null != A && A.outlets
        }

        function Ei(A, x, y, L, ue) {
            let Fe = {};
            if (L && En(L, (At, en) => {
                Fe[en] = Array.isArray(At) ? At.map(zn => `${zn}`) : `${At}`
            }), A === x) return new br(y, Fe, ue);
            const ft = ai(A, x, y);
            return new br(ft, Fe, ue)
        }

        function ai(A, x, y) {
            const L = {};
            return En(A.children, (ue, Fe) => {
                L[Fe] = ue === x ? y : ai(ue, x, y)
            }), new Vn(A.segments, L)
        }

        class ri {
            constructor(x, y, L) {
                if (this.isAbsolute = x, this.numberOfDoubleDots = y, this.commands = L, x && L.length > 0 && ni(L[0])) throw new Error("Root segment cannot have matrix parameters");
                const ue = L.find(oi);
                if (ue && ue !== Mn(L)) throw new Error("{outlets:{}} has to be the last command")
            }

            toRoot() {
                return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0]
            }
        }

        class Wr {
            constructor(x, y, L) {
                this.segmentGroup = x, this.processChildren = y, this.index = L
            }
        }

        function _i(A, x, y) {
            if (A || (A = new Vn([], {})), 0 === A.segments.length && A.hasChildren()) return J(A, x, y);
            const L = function be(A, x, y) {
                let L = 0, ue = x;
                const Fe = {match: !1, pathIndex: 0, commandIndex: 0};
                for (; ue < A.segments.length;) {
                    if (L >= y.length) return Fe;
                    const ft = A.segments[ue], At = y[L];
                    if (oi(At)) break;
                    const en = `${At}`, zn = L < y.length - 1 ? y[L + 1] : null;
                    if (ue > 0 && void 0 === en) break;
                    if (en && zn && "object" == typeof zn && void 0 === zn.outlets) {
                        if (!Yt(en, zn, ft)) return Fe;
                        L += 2
                    } else {
                        if (!Yt(en, {}, ft)) return Fe;
                        L++
                    }
                    ue++
                }
                return {match: !0, pathIndex: ue, commandIndex: L}
            }(A, x, y), ue = y.slice(L.commandIndex);
            if (L.match && L.pathIndex < A.segments.length) {
                const Fe = new Vn(A.segments.slice(0, L.pathIndex), {});
                return Fe.children[ht] = new Vn(A.segments.slice(L.pathIndex), A.children), J(Fe, 0, ue)
            }
            return L.match && 0 === ue.length ? new Vn(A.segments, {}) : L.match && !A.hasChildren() ? Y(A, x, y) : L.match ? J(A, 0, ue) : Y(A, x, y)
        }

        function J(A, x, y) {
            if (0 === y.length) return new Vn(A.segments, {});
            {
                const L = function Zi(A) {
                    return oi(A[0]) ? A[0].outlets : {[ht]: A}
                }(y), ue = {};
                return En(L, (Fe, ft) => {
                    "string" == typeof Fe && (Fe = [Fe]), null !== Fe && (ue[ft] = _i(A.children[ft], x, Fe))
                }), En(A.children, (Fe, ft) => {
                    void 0 === L[ft] && (ue[ft] = Fe)
                }), new Vn(A.segments, ue)
            }
        }

        function Y(A, x, y) {
            const L = A.segments.slice(0, x);
            let ue = 0;
            for (; ue < y.length;) {
                const Fe = y[ue];
                if (oi(Fe)) {
                    const en = Ve(Fe.outlets);
                    return new Vn(L, en)
                }
                if (0 === ue && ni(y[0])) {
                    L.push(new $n(A.segments[x].path, mt(y[0]))), ue++;
                    continue
                }
                const ft = oi(Fe) ? Fe.outlets[ht] : `${Fe}`, At = ue < y.length - 1 ? y[ue + 1] : null;
                ft && At && ni(At) ? (L.push(new $n(ft, mt(At))), ue += 2) : (L.push(new $n(ft, {})), ue++)
            }
            return new Vn(L, {})
        }

        function Ve(A) {
            const x = {};
            return En(A, (y, L) => {
                "string" == typeof y && (y = [y]), null !== y && (x[L] = Y(new Vn([], {}), 0, y))
            }), x
        }

        function mt(A) {
            const x = {};
            return En(A, (y, L) => x[L] = `${y}`), x
        }

        function Yt(A, x, y) {
            return A == y.path && un(x, y.parameters)
        }

        class vn {
            constructor(x, y, L, ue) {
                this.routeReuseStrategy = x, this.futureState = y, this.currState = L, this.forwardEvent = ue
            }

            activate(x) {
                const y = this.futureState._root, L = this.currState ? this.currState._root : null;
                this.deactivateChildRoutes(y, L, x), mi(this.futureState.root), this.activateChildRoutes(y, L, x)
            }

            deactivateChildRoutes(x, y, L) {
                const ue = ci(y);
                x.children.forEach(Fe => {
                    const ft = Fe.value.outlet;
                    this.deactivateRoutes(Fe, ue[ft], L), delete ue[ft]
                }), En(ue, (Fe, ft) => {
                    this.deactivateRouteAndItsChildren(Fe, L)
                })
            }

            deactivateRoutes(x, y, L) {
                const ue = x.value, Fe = y ? y.value : null;
                if (ue === Fe) if (ue.component) {
                    const ft = L.getContext(ue.outlet);
                    ft && this.deactivateChildRoutes(x, y, ft.children)
                } else this.deactivateChildRoutes(x, y, L); else Fe && this.deactivateRouteAndItsChildren(y, L)
            }

            deactivateRouteAndItsChildren(x, y) {
                x.value.component && this.routeReuseStrategy.shouldDetach(x.value.snapshot) ? this.detachAndStoreRouteSubtree(x, y) : this.deactivateRouteAndOutlet(x, y)
            }

            detachAndStoreRouteSubtree(x, y) {
                const L = y.getContext(x.value.outlet), ue = L && x.value.component ? L.children : y, Fe = ci(x);
                for (const ft of Object.keys(Fe)) this.deactivateRouteAndItsChildren(Fe[ft], ue);
                if (L && L.outlet) {
                    const ft = L.outlet.detach(), At = L.children.onOutletDeactivated();
                    this.routeReuseStrategy.store(x.value.snapshot, {componentRef: ft, route: x, contexts: At})
                }
            }

            deactivateRouteAndOutlet(x, y) {
                const L = y.getContext(x.value.outlet), ue = L && x.value.component ? L.children : y, Fe = ci(x);
                for (const ft of Object.keys(Fe)) this.deactivateRouteAndItsChildren(Fe[ft], ue);
                L && L.outlet && (L.outlet.deactivate(), L.children.onOutletDeactivated(), L.attachRef = null, L.resolver = null, L.route = null)
            }

            activateChildRoutes(x, y, L) {
                const ue = ci(y);
                x.children.forEach(Fe => {
                    this.activateRoutes(Fe, ue[Fe.value.outlet], L), this.forwardEvent(new vt(Fe.value.snapshot))
                }), x.children.length && this.forwardEvent(new Dr(x.value.snapshot))
            }

            activateRoutes(x, y, L) {
                const ue = x.value, Fe = y ? y.value : null;
                if (mi(ue), ue === Fe) if (ue.component) {
                    const ft = L.getOrCreateContext(ue.outlet);
                    this.activateChildRoutes(x, y, ft.children)
                } else this.activateChildRoutes(x, y, L); else if (ue.component) {
                    const ft = L.getOrCreateContext(ue.outlet);
                    if (this.routeReuseStrategy.shouldAttach(ue.snapshot)) {
                        const At = this.routeReuseStrategy.retrieve(ue.snapshot);
                        this.routeReuseStrategy.store(ue.snapshot, null), ft.children.onOutletReAttached(At.contexts), ft.attachRef = At.componentRef, ft.route = At.route.value, ft.outlet && ft.outlet.attach(At.componentRef, At.route.value), mi(At.route.value), this.activateChildRoutes(x, null, ft.children)
                    } else {
                        const At = function vr(A) {
                            for (let x = A.parent; x; x = x.parent) {
                                const y = x.routeConfig;
                                if (y && y._loadedConfig) return y._loadedConfig;
                                if (y && y.component) return null
                            }
                            return null
                        }(ue.snapshot), en = At ? At.module.componentFactoryResolver : null;
                        ft.attachRef = null, ft.route = ue, ft.resolver = en, ft.outlet && ft.outlet.activateWith(ue, en), this.activateChildRoutes(x, null, ft.children)
                    }
                } else this.activateChildRoutes(x, null, L)
            }
        }

        class wr {
            constructor(x, y) {
                this.routes = x, this.module = y
            }
        }

        function hr(A) {
            return "function" == typeof A
        }

        function Tr(A) {
            return A instanceof br
        }

        const Gr = Symbol("INITIAL_VALUE");

        function jr() {
            return (0, Dt.w)(A => function X(...A) {
                let x, y;
                return (0, D.K)(A[A.length - 1]) && (y = A.pop()), "function" == typeof A[A.length - 1] && (x = A.pop()), 1 === A.length && (0, ie.k)(A[0]) && (A = A[0]), (0, me.n)(A, y).lift(new M(x))
            }(A.map(x => x.pipe(g(1), function P(...A) {
                const x = A[A.length - 1];
                return (0, D.K)(x) ? (A.pop(), y => it(A, y, x)) : y => it(A, y)
            }(Gr)))).pipe(B((x, y) => {
                let L = !1;
                return y.reduce((ue, Fe, ft) => ue !== Gr ? ue : (Fe === Gr && (L = !0), L || !1 !== Fe && ft !== y.length - 1 && !Tr(Fe) ? ue : Fe), x)
            }, Gr), (0, Le.h)(x => x !== Gr), (0, tt.U)(x => Tr(x) ? x : !0 === x), g(1)))
        }

        class re {
            constructor() {
                this.outlet = null, this.route = null, this.resolver = null, this.children = new z, this.attachRef = null
            }
        }

        class z {
            constructor() {
                this.contexts = new Map
            }

            onChildOutletCreated(x, y) {
                const L = this.getOrCreateContext(x);
                L.outlet = y, this.contexts.set(x, L)
            }

            onChildOutletDestroyed(x) {
                const y = this.getContext(x);
                y && (y.outlet = null, y.attachRef = null)
            }

            onOutletDeactivated() {
                const x = this.contexts;
                return this.contexts = new Map, x
            }

            onOutletReAttached(x) {
                this.contexts = x
            }

            getOrCreateContext(x) {
                let y = this.getContext(x);
                return y || (y = new re, this.contexts.set(x, y)), y
            }

            getContext(x) {
                return this.contexts.get(x) || null
            }
        }

        let V = (() => {
            class A {
                constructor(y, L, ue, Fe, ft) {
                    this.parentContexts = y, this.location = L, this.resolver = ue, this.changeDetector = ft, this.activated = null, this._activatedRoute = null, this.activateEvents = new r.vpe, this.deactivateEvents = new r.vpe, this.attachEvents = new r.vpe, this.detachEvents = new r.vpe, this.name = Fe || ht, y.onChildOutletCreated(this.name, this)
                }

                ngOnDestroy() {
                    this.parentContexts.onChildOutletDestroyed(this.name)
                }

                ngOnInit() {
                    if (!this.activated) {
                        const y = this.parentContexts.getContext(this.name);
                        y && y.route && (y.attachRef ? this.attach(y.attachRef, y.route) : this.activateWith(y.route, y.resolver || null))
                    }
                }

                get isActivated() {
                    return !!this.activated
                }

                get component() {
                    if (!this.activated) throw new Error("Outlet is not activated");
                    return this.activated.instance
                }

                get activatedRoute() {
                    if (!this.activated) throw new Error("Outlet is not activated");
                    return this._activatedRoute
                }

                get activatedRouteData() {
                    return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
                }

                detach() {
                    if (!this.activated) throw new Error("Outlet is not activated");
                    this.location.detach();
                    const y = this.activated;
                    return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(y.instance), y
                }

                attach(y, L) {
                    this.activated = y, this._activatedRoute = L, this.location.insert(y.hostView), this.attachEvents.emit(y.instance)
                }

                deactivate() {
                    if (this.activated) {
                        const y = this.component;
                        this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(y)
                    }
                }

                activateWith(y, L) {
                    if (this.isActivated) throw new Error("Cannot activate an already activated outlet");
                    this._activatedRoute = y;
                    const ft = (L = L || this.resolver).resolveComponentFactory(y._futureSnapshot.routeConfig.component),
                        At = this.parentContexts.getOrCreateContext(this.name).children,
                        en = new _e(y, At, this.location.injector);
                    this.activated = this.location.createComponent(ft, this.location.length, en), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance)
                }
            }

            return A.\u0275fac = function (y) {
                return new (y || A)(r.Y36(z), r.Y36(r.s_b), r.Y36(r._Vd), r.$8M("name"), r.Y36(r.sBO))
            }, A.\u0275dir = r.lG2({
                type: A,
                selectors: [["router-outlet"]],
                outputs: {
                    activateEvents: "activate",
                    deactivateEvents: "deactivate",
                    attachEvents: "attach",
                    detachEvents: "detach"
                },
                exportAs: ["outlet"]
            }), A
        })();

        class _e {
            constructor(x, y, L) {
                this.route = x, this.childContexts = y, this.parent = L
            }

            get(x, y) {
                return x === ei ? this.route : x === z ? this.childContexts : this.parent.get(x, y)
            }
        }

        let h = (() => {
            class A {
            }

            return A.\u0275fac = function (y) {
                return new (y || A)
            }, A.\u0275cmp = r.Xpm({
                type: A,
                selectors: [["ng-component"]],
                decls: 1,
                vars: 0,
                template: function (y, L) {
                    1 & y && r._UZ(0, "router-outlet")
                },
                directives: [V],
                encapsulation: 2
            }), A
        })();

        function G(A, x = "") {
            for (let y = 0; y < A.length; y++) {
                const L = A[y];
                m(L, K(x, L))
            }
        }

        function m(A, x) {
            A.children && G(A.children, x)
        }

        function K(A, x) {
            return x ? A || x.path ? A && !x.path ? `${A}/` : !A && x.path ? x.path : `${A}/${x.path}` : "" : A
        }

        function Re(A) {
            const x = A.children && A.children.map(Re),
                y = x ? Object.assign(Object.assign({}, A), {children: x}) : Object.assign({}, A);
            return !y.component && (x || y.loadChildren) && y.outlet && y.outlet !== ht && (y.component = h), y
        }

        function kt(A) {
            return A.outlet || ht
        }

        function Dn(A, x) {
            const y = A.filter(L => kt(L) === x);
            return y.push(...A.filter(L => kt(L) !== x)), y
        }

        const Lt = {
            matched: !1,
            consumedSegments: [],
            remainingSegments: [],
            parameters: {},
            positionalParamSegments: {}
        };

        function In(A, x, y) {
            var L;
            if ("" === x.path) return "full" === x.pathMatch && (A.hasChildren() || y.length > 0) ? Object.assign({}, Lt) : {
                matched: !0,
                consumedSegments: [],
                remainingSegments: y,
                parameters: {},
                positionalParamSegments: {}
            };
            const Fe = (x.matcher || Qt)(y, A, x);
            if (!Fe) return Object.assign({}, Lt);
            const ft = {};
            En(Fe.posParams, (en, zn) => {
                ft[zn] = en.path
            });
            const At = Fe.consumed.length > 0 ? Object.assign(Object.assign({}, ft), Fe.consumed[Fe.consumed.length - 1].parameters) : ft;
            return {
                matched: !0,
                consumedSegments: Fe.consumed,
                remainingSegments: y.slice(Fe.consumed.length),
                parameters: At,
                positionalParamSegments: null !== (L = Fe.posParams) && void 0 !== L ? L : {}
            }
        }

        function mr(A, x, y, L, ue = "corrected") {
            if (y.length > 0 && function Vr(A, x, y) {
                return y.some(L => Zr(A, x, L) && kt(L) !== ht)
            }(A, y, L)) {
                const ft = new Vn(x, function Mr(A, x, y, L) {
                    const ue = {};
                    ue[ht] = L, L._sourceSegment = A, L._segmentIndexShift = x.length;
                    for (const Fe of y) if ("" === Fe.path && kt(Fe) !== ht) {
                        const ft = new Vn([], {});
                        ft._sourceSegment = A, ft._segmentIndexShift = x.length, ue[kt(Fe)] = ft
                    }
                    return ue
                }(A, x, L, new Vn(y, A.children)));
                return ft._sourceSegment = A, ft._segmentIndexShift = x.length, {segmentGroup: ft, slicedSegments: []}
            }
            if (0 === y.length && function Kr(A, x, y) {
                return y.some(L => Zr(A, x, L))
            }(A, y, L)) {
                const ft = new Vn(A.segments, function dr(A, x, y, L, ue, Fe) {
                    const ft = {};
                    for (const At of L) if (Zr(A, y, At) && !ue[kt(At)]) {
                        const en = new Vn([], {});
                        en._sourceSegment = A, en._segmentIndexShift = "legacy" === Fe ? A.segments.length : x.length, ft[kt(At)] = en
                    }
                    return Object.assign(Object.assign({}, ue), ft)
                }(A, x, y, L, A.children, ue));
                return ft._sourceSegment = A, ft._segmentIndexShift = x.length, {segmentGroup: ft, slicedSegments: y}
            }
            const Fe = new Vn(A.segments, A.children);
            return Fe._sourceSegment = A, Fe._segmentIndexShift = x.length, {segmentGroup: Fe, slicedSegments: y}
        }

        function Zr(A, x, y) {
            return (!(A.hasChildren() || x.length > 0) || "full" !== y.pathMatch) && "" === y.path
        }

        function Ai(A, x, y, L) {
            return !!(kt(A) === L || L !== ht && Zr(x, y, A)) && ("**" === A.path || In(x, A, y).matched)
        }

        function Hi(A, x, y) {
            return 0 === x.length && !A.children[y]
        }

        class bs {
            constructor(x) {
                this.segmentGroup = x || null
            }
        }

        class p {
            constructor(x) {
                this.urlTree = x
            }
        }

        function s(A) {
            return F(new bs(A))
        }

        function _(A) {
            return F(new p(A))
        }

        class De {
            constructor(x, y, L, ue, Fe) {
                this.configLoader = y, this.urlSerializer = L, this.urlTree = ue, this.config = Fe, this.allowRedirects = !0, this.ngModule = x.get(r.h0i)
            }

            apply() {
                const x = mr(this.urlTree.root, [], [], this.config).segmentGroup, y = new Vn(x.segments, x.children);
                return this.expandSegmentGroup(this.ngModule, this.config, y, ht).pipe((0, tt.U)(Fe => this.createUrlTree(Oe(Fe), this.urlTree.queryParams, this.urlTree.fragment))).pipe(ze(Fe => {
                    if (Fe instanceof p) return this.allowRedirects = !1, this.match(Fe.urlTree);
                    throw Fe instanceof bs ? this.noMatchError(Fe) : Fe
                }))
            }

            match(x) {
                return this.expandSegmentGroup(this.ngModule, this.config, x.root, ht).pipe((0, tt.U)(ue => this.createUrlTree(Oe(ue), x.queryParams, x.fragment))).pipe(ze(ue => {
                    throw ue instanceof bs ? this.noMatchError(ue) : ue
                }))
            }

            noMatchError(x) {
                return new Error(`Cannot match any routes. URL Segment: '${x.segmentGroup}'`)
            }

            createUrlTree(x, y, L) {
                const ue = x.segments.length > 0 ? new Vn([], {[ht]: x}) : x;
                return new br(ue, y, L)
            }

            expandSegmentGroup(x, y, L, ue) {
                return 0 === L.segments.length && L.hasChildren() ? this.expandChildren(x, y, L).pipe((0, tt.U)(Fe => new Vn([], Fe))) : this.expandSegment(x, L, y, L.segments, ue, !0)
            }

            expandChildren(x, y, L) {
                const ue = [];
                for (const Fe of Object.keys(L.children)) "primary" === Fe ? ue.unshift(Fe) : ue.push(Fe);
                return (0, yt.D)(ue).pipe((0, Ft.b)(Fe => {
                    const ft = L.children[Fe], At = Dn(y, Fe);
                    return this.expandSegmentGroup(x, At, ft, Fe).pipe((0, tt.U)(en => ({segment: en, outlet: Fe})))
                }), B((Fe, ft) => (Fe[ft.outlet] = ft.segment, Fe), {}), function Nn(A, x) {
                    const y = arguments.length >= 2;
                    return L => L.pipe(A ? (0, Le.h)((ue, Fe) => A(ue, Fe, L)) : wn.y, ut(1), y ? Xt(x) : _t(() => new Ie))
                }())
            }

            expandSegment(x, y, L, ue, Fe, ft) {
                return (0, yt.D)(L).pipe((0, Ft.b)(At => this.expandSegmentAgainstRoute(x, y, L, At, ue, Fe, ft).pipe(ze(zn => {
                    if (zn instanceof bs) return (0, he.of)(null);
                    throw zn
                }))), On(At => !!At), ze((At, en) => {
                    if (At instanceof Ie || "EmptyError" === At.name) return Hi(y, ue, Fe) ? (0, he.of)(new Vn([], {})) : s(y);
                    throw At
                }))
            }

            expandSegmentAgainstRoute(x, y, L, ue, Fe, ft, At) {
                return Ai(ue, y, Fe, ft) ? void 0 === ue.redirectTo ? this.matchSegmentAgainstRoute(x, y, ue, Fe, ft) : At && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(x, y, L, ue, Fe, ft) : s(y) : s(y)
            }

            expandSegmentAgainstRouteUsingRedirect(x, y, L, ue, Fe, ft) {
                return "**" === ue.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(x, L, ue, ft) : this.expandRegularSegmentAgainstRouteUsingRedirect(x, y, L, ue, Fe, ft)
            }

            expandWildCardWithParamsAgainstRouteUsingRedirect(x, y, L, ue) {
                const Fe = this.applyRedirectCommands([], L.redirectTo, {});
                return L.redirectTo.startsWith("/") ? _(Fe) : this.lineralizeSegments(L, Fe).pipe((0, zt.zg)(ft => {
                    const At = new Vn(ft, {});
                    return this.expandSegment(x, At, y, ft, ue, !1)
                }))
            }

            expandRegularSegmentAgainstRouteUsingRedirect(x, y, L, ue, Fe, ft) {
                const {
                    matched: At,
                    consumedSegments: en,
                    remainingSegments: zn,
                    positionalParamSegments: Cr
                } = In(y, ue, Fe);
                if (!At) return s(y);
                const Kn = this.applyRedirectCommands(en, ue.redirectTo, Cr);
                return ue.redirectTo.startsWith("/") ? _(Kn) : this.lineralizeSegments(ue, Kn).pipe((0, zt.zg)(Fr => this.expandSegment(x, y, L, Fr.concat(zn), ft, !1)))
            }

            matchSegmentAgainstRoute(x, y, L, ue, Fe) {
                if ("**" === L.path) return L.loadChildren ? (L._loadedConfig ? (0, he.of)(L._loadedConfig) : this.configLoader.load(x.injector, L)).pipe((0, tt.U)(Kn => (L._loadedConfig = Kn, new Vn(ue, {})))) : (0, he.of)(new Vn(ue, {}));
                const {matched: ft, consumedSegments: At, remainingSegments: en} = In(y, L, ue);
                return ft ? this.getChildConfig(x, L, ue).pipe((0, zt.zg)(Cr => {
                    const Kn = Cr.module, Fr = Cr.routes, {segmentGroup: cr, slicedSegments: Li} = mr(y, At, en, Fr),
                        zi = new Vn(cr.segments, cr.children);
                    if (0 === Li.length && zi.hasChildren()) return this.expandChildren(Kn, Fr, zi).pipe((0, tt.U)(qi => new Vn(At, qi)));
                    if (0 === Fr.length && 0 === Li.length) return (0, he.of)(new Vn(At, {}));
                    const va = kt(L) === Fe;
                    return this.expandSegment(Kn, zi, Fr, Li, va ? ht : Fe, !0).pipe((0, tt.U)(yi => new Vn(At.concat(yi.segments), yi.children)))
                })) : s(y)
            }

            getChildConfig(x, y, L) {
                return y.children ? (0, he.of)(new wr(y.children, x)) : y.loadChildren ? void 0 !== y._loadedConfig ? (0, he.of)(y._loadedConfig) : this.runCanLoadGuards(x.injector, y, L).pipe((0, zt.zg)(ue => ue ? this.configLoader.load(x.injector, y).pipe((0, tt.U)(Fe => (y._loadedConfig = Fe, Fe))) : function fe(A) {
                    return F(wt(`Cannot load children because the guard of the route "path: '${A.path}'" returned false`))
                }(y))) : (0, he.of)(new wr([], x))
            }

            runCanLoadGuards(x, y, L) {
                const ue = y.canLoad;
                if (!ue || 0 === ue.length) return (0, he.of)(!0);
                const Fe = ue.map(ft => {
                    const At = x.get(ft);
                    let en;
                    if (function yr(A) {
                        return A && hr(A.canLoad)
                    }(At)) en = At.canLoad(y, L); else {
                        if (!hr(At)) throw new Error("Invalid CanLoad guard");
                        en = At(y, L)
                    }
                    return Sn(en)
                });
                return (0, he.of)(Fe).pipe(jr(), U(ft => {
                    if (!Tr(ft)) return;
                    const At = wt(`Redirecting to "${this.urlSerializer.serialize(ft)}"`);
                    throw At.url = ft, At
                }), (0, tt.U)(ft => !0 === ft))
            }

            lineralizeSegments(x, y) {
                let L = [], ue = y.root;
                for (; ;) {
                    if (L = L.concat(ue.segments), 0 === ue.numberOfChildren) return (0, he.of)(L);
                    if (ue.numberOfChildren > 1 || !ue.children[ht]) return F(new Error(`Only absolute redirects can have named outlets. redirectTo: '${x.redirectTo}'`));
                    ue = ue.children[ht]
                }
            }

            applyRedirectCommands(x, y, L) {
                return this.applyRedirectCreatreUrlTree(y, this.urlSerializer.parse(y), x, L)
            }

            applyRedirectCreatreUrlTree(x, y, L, ue) {
                const Fe = this.createSegmentGroup(x, y.root, L, ue);
                return new br(Fe, this.createQueryParams(y.queryParams, this.urlTree.queryParams), y.fragment)
            }

            createQueryParams(x, y) {
                const L = {};
                return En(x, (ue, Fe) => {
                    if ("string" == typeof ue && ue.startsWith(":")) {
                        const At = ue.substring(1);
                        L[Fe] = y[At]
                    } else L[Fe] = ue
                }), L
            }

            createSegmentGroup(x, y, L, ue) {
                const Fe = this.createSegments(x, y.segments, L, ue);
                let ft = {};
                return En(y.children, (At, en) => {
                    ft[en] = this.createSegmentGroup(x, At, L, ue)
                }), new Vn(Fe, ft)
            }

            createSegments(x, y, L, ue) {
                return y.map(Fe => Fe.path.startsWith(":") ? this.findPosParam(x, Fe, ue) : this.findOrReturn(Fe, L))
            }

            findPosParam(x, y, L) {
                const ue = L[y.path.substring(1)];
                if (!ue) throw new Error(`Cannot redirect to '${x}'. Cannot find '${y.path}'.`);
                return ue
            }

            findOrReturn(x, y) {
                let L = 0;
                for (const ue of y) {
                    if (ue.path === x.path) return y.splice(L), ue;
                    L++
                }
                return x
            }
        }

        function Oe(A) {
            const x = {};
            for (const L of Object.keys(A.children)) {
                const Fe = Oe(A.children[L]);
                (Fe.segments.length > 0 || Fe.hasChildren()) && (x[L] = Fe)
            }
            return function He(A) {
                if (1 === A.numberOfChildren && A.children[ht]) {
                    const x = A.children[ht];
                    return new Vn(A.segments.concat(x.segments), x.children)
                }
                return A
            }(new Vn(A.segments, x))
        }

        class ke {
            constructor(x) {
                this.path = x, this.route = this.path[this.path.length - 1]
            }
        }

        class Ae {
            constructor(x, y) {
                this.component = x, this.route = y
            }
        }

        function we(A, x, y) {
            const L = A._root;
            return qe(L, x ? x._root : null, y, [L.value])
        }

        function pt(A, x, y) {
            const L = function Tt(A) {
                if (!A) return null;
                for (let x = A.parent; x; x = x.parent) {
                    const y = x.routeConfig;
                    if (y && y._loadedConfig) return y._loadedConfig
                }
                return null
            }(x);
            return (L ? L.module.injector : y).get(A)
        }

        function qe(A, x, y, L, ue = {canDeactivateChecks: [], canActivateChecks: []}) {
            const Fe = ci(x);
            return A.children.forEach(ft => {
                (function ot(A, x, y, L, ue = {canDeactivateChecks: [], canActivateChecks: []}) {
                    const Fe = A.value, ft = x ? x.value : null, At = y ? y.getContext(A.value.outlet) : null;
                    if (ft && Fe.routeConfig === ft.routeConfig) {
                        const en = function Nt(A, x, y) {
                            if ("function" == typeof y) return y(A, x);
                            switch (y) {
                                case"pathParamsChange":
                                    return !_r(A.url, x.url);
                                case"pathParamsOrQueryParamsChange":
                                    return !_r(A.url, x.url) || !un(A.queryParams, x.queryParams);
                                case"always":
                                    return !0;
                                case"paramsOrQueryParamsChange":
                                    return !Xr(A, x) || !un(A.queryParams, x.queryParams);
                                default:
                                    return !Xr(A, x)
                            }
                        }(ft, Fe, Fe.routeConfig.runGuardsAndResolvers);
                        en ? ue.canActivateChecks.push(new ke(L)) : (Fe.data = ft.data, Fe._resolvedData = ft._resolvedData), qe(A, x, Fe.component ? At ? At.children : null : y, L, ue), en && At && At.outlet && At.outlet.isActivated && ue.canDeactivateChecks.push(new Ae(At.outlet.component, ft))
                    } else ft && bt(x, At, ue), ue.canActivateChecks.push(new ke(L)), qe(A, null, Fe.component ? At ? At.children : null : y, L, ue)
                })(ft, Fe[ft.value.outlet], y, L.concat([ft.value]), ue), delete Fe[ft.value.outlet]
            }), En(Fe, (ft, At) => bt(ft, y.getContext(At), ue)), ue
        }

        function bt(A, x, y) {
            const L = ci(A), ue = A.value;
            En(L, (Fe, ft) => {
                bt(Fe, ue.component ? x ? x.children.getContext(ft) : null : x, y)
            }), y.canDeactivateChecks.push(new Ae(ue.component && x && x.outlet && x.outlet.isActivated ? x.outlet.component : null, ue))
        }

        class C {
        }

        function ee(A) {
            return new Ne.y(x => x.error(A))
        }

        class ct {
            constructor(x, y, L, ue, Fe, ft) {
                this.rootComponentType = x, this.config = y, this.urlTree = L, this.url = ue, this.paramsInheritanceStrategy = Fe, this.relativeLinkResolution = ft
            }

            recognize() {
                const x = mr(this.urlTree.root, [], [], this.config.filter(ft => void 0 === ft.redirectTo), this.relativeLinkResolution).segmentGroup,
                    y = this.processSegmentGroup(this.config, x, ht);
                if (null === y) return null;
                const L = new wi([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, ht, this.rootComponentType, null, this.urlTree.root, -1, {}),
                    ue = new Qr(L, y), Fe = new ui(this.url, ue);
                return this.inheritParamsAndData(Fe._root), Fe
            }

            inheritParamsAndData(x) {
                const y = x.value, L = xi(y, this.paramsInheritanceStrategy);
                y.params = Object.freeze(L.params), y.data = Object.freeze(L.data), x.children.forEach(ue => this.inheritParamsAndData(ue))
            }

            processSegmentGroup(x, y, L) {
                return 0 === y.segments.length && y.hasChildren() ? this.processChildren(x, y) : this.processSegment(x, y, y.segments, L)
            }

            processChildren(x, y) {
                const L = [];
                for (const Fe of Object.keys(y.children)) {
                    const ft = y.children[Fe], At = Dn(x, Fe), en = this.processSegmentGroup(At, ft, Fe);
                    if (null === en) return null;
                    L.push(...en)
                }
                const ue = Wt(L);
                return function xt(A) {
                    A.sort((x, y) => x.value.outlet === ht ? -1 : y.value.outlet === ht ? 1 : x.value.outlet.localeCompare(y.value.outlet))
                }(ue), ue
            }

            processSegment(x, y, L, ue) {
                for (const Fe of x) {
                    const ft = this.processSegmentAgainstRoute(Fe, y, L, ue);
                    if (null !== ft) return ft
                }
                return Hi(y, L, ue) ? [] : null
            }

            processSegmentAgainstRoute(x, y, L, ue) {
                if (x.redirectTo || !Ai(x, y, L, ue)) return null;
                let Fe, ft = [], At = [];
                if ("**" === x.path) {
                    const cr = L.length > 0 ? Mn(L).parameters : {};
                    Fe = new wi(L, cr, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, kr(x), kt(x), x.component, x, Ln(y), er(y) + L.length, qr(x))
                } else {
                    const cr = In(y, x, L);
                    if (!cr.matched) return null;
                    ft = cr.consumedSegments, At = cr.remainingSegments, Fe = new wi(ft, cr.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, kr(x), kt(x), x.component, x, Ln(y), er(y) + ft.length, qr(x))
                }
                const en = function st(A) {
                    return A.children ? A.children : A.loadChildren ? A._loadedConfig.routes : []
                }(x), {
                    segmentGroup: zn,
                    slicedSegments: Cr
                } = mr(y, ft, At, en.filter(cr => void 0 === cr.redirectTo), this.relativeLinkResolution);
                if (0 === Cr.length && zn.hasChildren()) {
                    const cr = this.processChildren(en, zn);
                    return null === cr ? null : [new Qr(Fe, cr)]
                }
                if (0 === en.length && 0 === Cr.length) return [new Qr(Fe, [])];
                const Kn = kt(x) === ue, Fr = this.processSegment(en, zn, Cr, Kn ? ht : ue);
                return null === Fr ? null : [new Qr(Fe, Fr)]
            }
        }

        function Vt(A) {
            const x = A.value.routeConfig;
            return x && "" === x.path && void 0 === x.redirectTo
        }

        function Wt(A) {
            const x = [], y = new Set;
            for (const L of A) {
                if (!Vt(L)) {
                    x.push(L);
                    continue
                }
                const ue = x.find(Fe => L.value.routeConfig === Fe.value.routeConfig);
                void 0 !== ue ? (ue.children.push(...L.children), y.add(ue)) : x.push(L)
            }
            for (const L of y) {
                const ue = Wt(L.children);
                x.push(new Qr(L.value, ue))
            }
            return x.filter(L => !y.has(L))
        }

        function Ln(A) {
            let x = A;
            for (; x._sourceSegment;) x = x._sourceSegment;
            return x
        }

        function er(A) {
            let x = A, y = x._segmentIndexShift ? x._segmentIndexShift : 0;
            for (; x._sourceSegment;) x = x._sourceSegment, y += x._segmentIndexShift ? x._segmentIndexShift : 0;
            return y - 1
        }

        function kr(A) {
            return A.data || {}
        }

        function qr(A) {
            return A.resolve || {}
        }

        function Yr(A) {
            return [...Object.keys(A), ...Object.getOwnPropertySymbols(A)]
        }

        function Cs(A) {
            return (0, Dt.w)(x => {
                const y = A(x);
                return y ? (0, yt.D)(y).pipe((0, tt.U)(() => x)) : (0, he.of)(x)
            })
        }

        class Ss {
        }

        class as extends class Ns {
            shouldDetach(x) {
                return !1
            }

            store(x, y) {
            }

            shouldAttach(x) {
                return !1
            }

            retrieve(x) {
                return null
            }

            shouldReuseRoute(x, y) {
                return x.routeConfig === y.routeConfig
            }
        } {
        }

        const ls = new r.OlP("ROUTES");

        class cs {
            constructor(x, y, L, ue) {
                this.injector = x, this.compiler = y, this.onLoadStartListener = L, this.onLoadEndListener = ue
            }

            load(x, y) {
                if (y._loader$) return y._loader$;
                this.onLoadStartListener && this.onLoadStartListener(y);
                const ue = this.loadModuleFactory(y.loadChildren).pipe((0, tt.U)(Fe => {
                    this.onLoadEndListener && this.onLoadEndListener(y);
                    const ft = Fe.create(x);
                    return new wr(mn(ft.injector.get(ls, void 0, r.XFs.Self | r.XFs.Optional)).map(Re), ft)
                }), ze(Fe => {
                    throw y._loader$ = void 0, Fe
                }));
                return y._loader$ = new ce.c(ue, () => new I.xQ).pipe((0, dn.x)()), y._loader$
            }

            loadModuleFactory(x) {
                return Sn(x()).pipe((0, zt.zg)(y => y instanceof r.YKP ? (0, he.of)(y) : (0, yt.D)(this.compiler.compileModuleAsync(y))))
            }
        }

        class ca {
            shouldProcessUrl(x) {
                return !0
            }

            extract(x) {
                return x
            }

            merge(x, y) {
                return x
            }
        }

        function ua(A) {
            throw A
        }

        function Ds(A, x, y) {
            return x.parse("/")
        }

        function da(A, x) {
            return (0, he.of)(null)
        }

        const Ts = {paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact"},
            Do = {paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset"};
        let di = (() => {
            class A {
                constructor(y, L, ue, Fe, ft, At, en) {
                    this.rootComponentType = y, this.urlSerializer = L, this.rootContexts = ue, this.location = Fe, this.config = en, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new I.xQ, this.errorHandler = ua, this.malformedUriErrorHandler = Ds, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = {
                        beforePreactivation: da,
                        afterPreactivation: da
                    }, this.urlHandlingStrategy = new ca, this.routeReuseStrategy = new as, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = ft.get(r.h0i), this.console = ft.get(r.c2e);
                    const Kn = ft.get(r.R0b);
                    this.isNgZoneEnabled = Kn instanceof r.R0b && r.R0b.isInAngularZone(), this.resetConfig(en), this.currentUrlTree = function ar() {
                        return new br(new Vn([], {}), {}, null)
                    }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new cs(ft, At, Fr => this.triggerEvent(new Qn(Fr)), Fr => this.triggerEvent(new Wn(Fr))), this.routerState = pi(this.currentUrlTree, this.rootComponentType), this.transitions = new Ee.X({
                        id: 0,
                        targetPageId: 0,
                        currentUrlTree: this.currentUrlTree,
                        currentRawUrl: this.currentUrlTree,
                        extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
                        urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
                        rawUrl: this.currentUrlTree,
                        extras: {},
                        resolve: null,
                        reject: null,
                        promise: Promise.resolve(!0),
                        source: "imperative",
                        restoredState: null,
                        currentSnapshot: this.routerState.snapshot,
                        targetSnapshot: null,
                        currentRouterState: this.routerState,
                        targetRouterState: null,
                        guards: {canActivateChecks: [], canDeactivateChecks: []},
                        guardsResult: null
                    }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations()
                }

                get browserPageId() {
                    var y;
                    return null === (y = this.location.getState()) || void 0 === y ? void 0 : y.\u0275routerPageId
                }

                setupNavigations(y) {
                    const L = this.events;
                    return y.pipe((0, Le.h)(ue => 0 !== ue.id), (0, tt.U)(ue => Object.assign(Object.assign({}, ue), {extractedUrl: this.urlHandlingStrategy.extract(ue.rawUrl)})), (0, Dt.w)(ue => {
                        let Fe = !1, ft = !1;
                        return (0, he.of)(ue).pipe(U(At => {
                            this.currentNavigation = {
                                id: At.id,
                                initialUrl: At.currentRawUrl,
                                extractedUrl: At.extractedUrl,
                                trigger: At.source,
                                extras: At.extras,
                                previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), {previousNavigation: null}) : null
                            }
                        }), (0, Dt.w)(At => {
                            const en = this.browserUrlTree.toString(),
                                zn = !this.navigated || At.extractedUrl.toString() !== en || en !== this.currentUrlTree.toString();
                            if (("reload" === this.onSameUrlNavigation || zn) && this.urlHandlingStrategy.shouldProcessUrl(At.rawUrl)) return To(At.source) && (this.browserUrlTree = At.extractedUrl), (0, he.of)(At).pipe((0, Dt.w)(Kn => {
                                const Fr = this.transitions.getValue();
                                return L.next(new bn(Kn.id, this.serializeUrl(Kn.extractedUrl), Kn.source, Kn.restoredState)), Fr !== this.transitions.getValue() ? Ce : Promise.resolve(Kn)
                            }), function je(A, x, y, L) {
                                return (0, Dt.w)(ue => function le(A, x, y, L, ue) {
                                    return new De(A, x, y, L, ue).apply()
                                }(A, x, y, ue.extractedUrl, L).pipe((0, tt.U)(Fe => Object.assign(Object.assign({}, ue), {urlAfterRedirects: Fe}))))
                            }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), U(Kn => {
                                this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), {finalUrl: Kn.urlAfterRedirects})
                            }), function sr(A, x, y, L, ue) {
                                return (0, zt.zg)(Fe => function se(A, x, y, L, ue = "emptyOnly", Fe = "legacy") {
                                    try {
                                        const ft = new ct(A, x, y, L, ue, Fe).recognize();
                                        return null === ft ? ee(new C) : (0, he.of)(ft)
                                    } catch (ft) {
                                        return ee(ft)
                                    }
                                }(A, x, Fe.urlAfterRedirects, y(Fe.urlAfterRedirects), L, ue).pipe((0, tt.U)(ft => Object.assign(Object.assign({}, Fe), {targetSnapshot: ft}))))
                            }(this.rootComponentType, this.config, Kn => this.serializeUrl(Kn), this.paramsInheritanceStrategy, this.relativeLinkResolution), U(Kn => {
                                if ("eager" === this.urlUpdateStrategy) {
                                    if (!Kn.extras.skipLocationChange) {
                                        const cr = this.urlHandlingStrategy.merge(Kn.urlAfterRedirects, Kn.rawUrl);
                                        this.setBrowserUrl(cr, Kn)
                                    }
                                    this.browserUrlTree = Kn.urlAfterRedirects
                                }
                                const Fr = new Hn(Kn.id, this.serializeUrl(Kn.extractedUrl), this.serializeUrl(Kn.urlAfterRedirects), Kn.targetSnapshot);
                                L.next(Fr)
                            }));
                            if (zn && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
                                const {id: Fr, extractedUrl: cr, source: Li, restoredState: zi, extras: va} = At,
                                    ya = new bn(Fr, this.serializeUrl(cr), Li, zi);
                                L.next(ya);
                                const yi = pi(cr, this.rootComponentType).snapshot;
                                return (0, he.of)(Object.assign(Object.assign({}, At), {
                                    targetSnapshot: yi,
                                    urlAfterRedirects: cr,
                                    extras: Object.assign(Object.assign({}, va), {
                                        skipLocationChange: !1,
                                        replaceUrl: !1
                                    })
                                }))
                            }
                            return this.rawUrlTree = At.rawUrl, At.resolve(null), Ce
                        }), Cs(At => {
                            const {
                                targetSnapshot: en,
                                id: zn,
                                extractedUrl: Cr,
                                rawUrl: Kn,
                                extras: {skipLocationChange: Fr, replaceUrl: cr}
                            } = At;
                            return this.hooks.beforePreactivation(en, {
                                navigationId: zn,
                                appliedUrlTree: Cr,
                                rawUrlTree: Kn,
                                skipLocationChange: !!Fr,
                                replaceUrl: !!cr
                            })
                        }), U(At => {
                            const en = new jn(At.id, this.serializeUrl(At.extractedUrl), this.serializeUrl(At.urlAfterRedirects), At.targetSnapshot);
                            this.triggerEvent(en)
                        }), (0, tt.U)(At => Object.assign(Object.assign({}, At), {guards: we(At.targetSnapshot, At.currentSnapshot, this.rootContexts)})), function Rt(A, x) {
                            return (0, zt.zg)(y => {
                                const {
                                    targetSnapshot: L,
                                    currentSnapshot: ue,
                                    guards: {canActivateChecks: Fe, canDeactivateChecks: ft}
                                } = y;
                                return 0 === ft.length && 0 === Fe.length ? (0, he.of)(Object.assign(Object.assign({}, y), {guardsResult: !0})) : function An(A, x, y, L) {
                                    return (0, yt.D)(A).pipe((0, zt.zg)(ue => function d(A, x, y, L, ue) {
                                        const Fe = x && x.routeConfig ? x.routeConfig.canDeactivate : null;
                                        if (!Fe || 0 === Fe.length) return (0, he.of)(!0);
                                        const ft = Fe.map(At => {
                                            const en = pt(At, x, ue);
                                            let zn;
                                            if (function Pr(A) {
                                                return A && hr(A.canDeactivate)
                                            }(en)) zn = Sn(en.canDeactivate(A, x, y, L)); else {
                                                if (!hr(en)) throw new Error("Invalid CanDeactivate guard");
                                                zn = Sn(en(A, x, y, L))
                                            }
                                            return zn.pipe(On())
                                        });
                                        return (0, he.of)(ft).pipe(jr())
                                    }(ue.component, ue.route, y, x, L)), On(ue => !0 !== ue, !0))
                                }(ft, L, ue, A).pipe((0, zt.zg)(At => At && function ir(A) {
                                    return "boolean" == typeof A
                                }(At) ? function on(A, x, y, L) {
                                    return (0, yt.D)(x).pipe((0, Ft.b)(ue => it(function N(A, x) {
                                        return null !== A && x && x(new Xn(A)), (0, he.of)(!0)
                                    }(ue.route.parent, L), function Cn(A, x) {
                                        return null !== A && x && x(new It(A)), (0, he.of)(!0)
                                    }(ue.route, L), function u(A, x, y) {
                                        const L = x[x.length - 1],
                                            Fe = x.slice(0, x.length - 1).reverse().map(ft => function nt(A) {
                                                const x = A.routeConfig ? A.routeConfig.canActivateChild : null;
                                                return x && 0 !== x.length ? {node: A, guards: x} : null
                                            }(ft)).filter(ft => null !== ft).map(ft => Xe(() => {
                                                const At = ft.guards.map(en => {
                                                    const zn = pt(en, ft.node, y);
                                                    let Cr;
                                                    if (function Or(A) {
                                                        return A && hr(A.canActivateChild)
                                                    }(zn)) Cr = Sn(zn.canActivateChild(L, A)); else {
                                                        if (!hr(zn)) throw new Error("Invalid CanActivateChild guard");
                                                        Cr = Sn(zn(L, A))
                                                    }
                                                    return Cr.pipe(On())
                                                });
                                                return (0, he.of)(At).pipe(jr())
                                            }));
                                        return (0, he.of)(Fe).pipe(jr())
                                    }(A, ue.path, y), function o(A, x, y) {
                                        const L = x.routeConfig ? x.routeConfig.canActivate : null;
                                        if (!L || 0 === L.length) return (0, he.of)(!0);
                                        const ue = L.map(Fe => Xe(() => {
                                            const ft = pt(Fe, x, y);
                                            let At;
                                            if (function Ar(A) {
                                                return A && hr(A.canActivate)
                                            }(ft)) At = Sn(ft.canActivate(x, A)); else {
                                                if (!hr(ft)) throw new Error("Invalid CanActivate guard");
                                                At = Sn(ft(x, A))
                                            }
                                            return At.pipe(On())
                                        }));
                                        return (0, he.of)(ue).pipe(jr())
                                    }(A, ue.route, y))), On(ue => !0 !== ue, !0))
                                }(L, Fe, A, x) : (0, he.of)(At)), (0, tt.U)(At => Object.assign(Object.assign({}, y), {guardsResult: At})))
                            })
                        }(this.ngModule.injector, At => this.triggerEvent(At)), U(At => {
                            if (Tr(At.guardsResult)) {
                                const zn = wt(`Redirecting to "${this.serializeUrl(At.guardsResult)}"`);
                                throw zn.url = At.guardsResult, zn
                            }
                            const en = new fr(At.id, this.serializeUrl(At.extractedUrl), this.serializeUrl(At.urlAfterRedirects), At.targetSnapshot, !!At.guardsResult);
                            this.triggerEvent(en)
                        }), (0, Le.h)(At => !!At.guardsResult || (this.restoreHistory(At), this.cancelNavigationTransition(At, ""), !1)), Cs(At => {
                            if (At.guards.canActivateChecks.length) return (0, he.of)(At).pipe(U(en => {
                                const zn = new qn(en.id, this.serializeUrl(en.extractedUrl), this.serializeUrl(en.urlAfterRedirects), en.targetSnapshot);
                                this.triggerEvent(zn)
                            }), (0, Dt.w)(en => {
                                let zn = !1;
                                return (0, he.of)(en).pipe(function ur(A, x) {
                                    return (0, zt.zg)(y => {
                                        const {targetSnapshot: L, guards: {canActivateChecks: ue}} = y;
                                        if (!ue.length) return (0, he.of)(y);
                                        let Fe = 0;
                                        return (0, yt.D)(ue).pipe((0, Ft.b)(ft => function Rr(A, x, y, L) {
                                            return function Ur(A, x, y, L) {
                                                const ue = Yr(A);
                                                if (0 === ue.length) return (0, he.of)({});
                                                const Fe = {};
                                                return (0, yt.D)(ue).pipe((0, zt.zg)(ft => function Ki(A, x, y, L) {
                                                    const ue = pt(A, x, L);
                                                    return Sn(ue.resolve ? ue.resolve(x, y) : ue(x, y))
                                                }(A[ft], x, y, L).pipe(U(At => {
                                                    Fe[ft] = At
                                                }))), ut(1), (0, zt.zg)(() => Yr(Fe).length === ue.length ? (0, he.of)(Fe) : Ce))
                                            }(A._resolve, A, x, L).pipe((0, tt.U)(Fe => (A._resolvedData = Fe, A.data = Object.assign(Object.assign({}, A.data), xi(A, y).resolve), null)))
                                        }(ft.route, L, A, x)), U(() => Fe++), ut(1), (0, zt.zg)(ft => Fe === ue.length ? (0, he.of)(y) : Ce))
                                    })
                                }(this.paramsInheritanceStrategy, this.ngModule.injector), U({
                                    next: () => zn = !0,
                                    complete: () => {
                                        zn || (this.restoreHistory(en), this.cancelNavigationTransition(en, "At least one route resolver didn't emit any value."))
                                    }
                                }))
                            }), U(en => {
                                const zn = new Yn(en.id, this.serializeUrl(en.extractedUrl), this.serializeUrl(en.urlAfterRedirects), en.targetSnapshot);
                                this.triggerEvent(zn)
                            }))
                        }), Cs(At => {
                            const {
                                targetSnapshot: en,
                                id: zn,
                                extractedUrl: Cr,
                                rawUrl: Kn,
                                extras: {skipLocationChange: Fr, replaceUrl: cr}
                            } = At;
                            return this.hooks.afterPreactivation(en, {
                                navigationId: zn,
                                appliedUrlTree: Cr,
                                rawUrlTree: Kn,
                                skipLocationChange: !!Fr,
                                replaceUrl: !!cr
                            })
                        }), (0, tt.U)(At => {
                            const en = function ti(A, x, y) {
                                const L = Hr(A, x._root, y ? y._root : void 0);
                                return new Vi(L, x)
                            }(this.routeReuseStrategy, At.targetSnapshot, At.currentRouterState);
                            return Object.assign(Object.assign({}, At), {targetRouterState: en})
                        }), U(At => {
                            this.currentUrlTree = At.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(At.urlAfterRedirects, At.rawUrl), this.routerState = At.targetRouterState, "deferred" === this.urlUpdateStrategy && (At.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, At), this.browserUrlTree = At.urlAfterRedirects)
                        }), ((A, x, y) => (0, tt.U)(L => (new vn(x, L.targetRouterState, L.currentRouterState, y).activate(A), L)))(this.rootContexts, this.routeReuseStrategy, At => this.triggerEvent(At)), U({
                            next() {
                                Fe = !0
                            }, complete() {
                                Fe = !0
                            }
                        }), function ye(A) {
                            return x => x.lift(new Te(A))
                        }(() => {
                            var At;
                            Fe || ft || this.cancelNavigationTransition(ue, `Navigation ID ${ue.id} is not equal to the current navigation id ${this.navigationId}`), (null === (At = this.currentNavigation) || void 0 === At ? void 0 : At.id) === ue.id && (this.currentNavigation = null)
                        }), ze(At => {
                            if (ft = !0, function Ut(A) {
                                return A && A[dt]
                            }(At)) {
                                const en = Tr(At.url);
                                en || (this.navigated = !0, this.restoreHistory(ue, !0));
                                const zn = new rn(ue.id, this.serializeUrl(ue.extractedUrl), At.message);
                                L.next(zn), en ? setTimeout(() => {
                                    const Cr = this.urlHandlingStrategy.merge(At.url, this.rawUrlTree), Kn = {
                                        skipLocationChange: ue.extras.skipLocationChange,
                                        replaceUrl: "eager" === this.urlUpdateStrategy || To(ue.source)
                                    };
                                    this.scheduleNavigation(Cr, "imperative", null, Kn, {
                                        resolve: ue.resolve,
                                        reject: ue.reject,
                                        promise: ue.promise
                                    })
                                }, 0) : ue.resolve(!1)
                            } else {
                                this.restoreHistory(ue, !0);
                                const en = new gn(ue.id, this.serializeUrl(ue.extractedUrl), At);
                                L.next(en);
                                try {
                                    ue.resolve(this.errorHandler(At))
                                } catch (zn) {
                                    ue.reject(zn)
                                }
                            }
                            return Ce
                        }))
                    }))
                }

                resetRootComponentType(y) {
                    this.rootComponentType = y, this.routerState.root.component = this.rootComponentType
                }

                setTransition(y) {
                    this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), y))
                }

                initialNavigation() {
                    this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), {replaceUrl: !0})
                }

                setUpLocationChangeListener() {
                    this.locationSubscription || (this.locationSubscription = this.location.subscribe(y => {
                        const L = "popstate" === y.type ? "popstate" : "hashchange";
                        "popstate" === L && setTimeout(() => {
                            var ue;
                            const Fe = {replaceUrl: !0},
                                ft = (null === (ue = y.state) || void 0 === ue ? void 0 : ue.navigationId) ? y.state : null;
                            if (ft) {
                                const en = Object.assign({}, ft);
                                delete en.navigationId, delete en.\u0275routerPageId, 0 !== Object.keys(en).length && (Fe.state = en)
                            }
                            const At = this.parseUrl(y.url);
                            this.scheduleNavigation(At, L, ft, Fe)
                        }, 0)
                    }))
                }

                get url() {
                    return this.serializeUrl(this.currentUrlTree)
                }

                getCurrentNavigation() {
                    return this.currentNavigation
                }

                triggerEvent(y) {
                    this.events.next(y)
                }

                resetConfig(y) {
                    G(y), this.config = y.map(Re), this.navigated = !1, this.lastSuccessfulId = -1
                }

                ngOnDestroy() {
                    this.dispose()
                }

                dispose() {
                    this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0
                }

                createUrlTree(y, L = {}) {
                    const {
                        relativeTo: ue,
                        queryParams: Fe,
                        fragment: ft,
                        queryParamsHandling: At,
                        preserveFragment: en
                    } = L, zn = ue || this.routerState.root, Cr = en ? this.currentUrlTree.fragment : ft;
                    let Kn = null;
                    switch (At) {
                        case"merge":
                            Kn = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), Fe);
                            break;
                        case"preserve":
                            Kn = this.currentUrlTree.queryParams;
                            break;
                        default:
                            Kn = Fe || null
                    }
                    return null !== Kn && (Kn = this.removeEmptyProps(Kn)), function Di(A, x, y, L, ue) {
                        if (0 === y.length) return Ei(x.root, x.root, x.root, L, ue);
                        const Fe = function zr(A) {
                            if ("string" == typeof A[0] && 1 === A.length && "/" === A[0]) return new ri(!0, 0, A);
                            let x = 0, y = !1;
                            const L = A.reduce((ue, Fe, ft) => {
                                if ("object" == typeof Fe && null != Fe) {
                                    if (Fe.outlets) {
                                        const At = {};
                                        return En(Fe.outlets, (en, zn) => {
                                            At[zn] = "string" == typeof en ? en.split("/") : en
                                        }), [...ue, {outlets: At}]
                                    }
                                    if (Fe.segmentPath) return [...ue, Fe.segmentPath]
                                }
                                return "string" != typeof Fe ? [...ue, Fe] : 0 === ft ? (Fe.split("/").forEach((At, en) => {
                                    0 == en && "." === At || (0 == en && "" === At ? y = !0 : ".." === At ? x++ : "" != At && ue.push(At))
                                }), ue) : [...ue, Fe]
                            }, []);
                            return new ri(y, x, L)
                        }(y);
                        if (Fe.toRoot()) return Ei(x.root, x.root, new Vn([], {}), L, ue);
                        const ft = function kn(A, x, y) {
                                if (A.isAbsolute) return new Wr(x.root, !0, 0);
                                if (-1 === y.snapshot._lastPathIndex) {
                                    const Fe = y.snapshot._urlSegment;
                                    return new Wr(Fe, Fe === x.root, 0)
                                }
                                const L = ni(A.commands[0]) ? 0 : 1;
                                return function Ti(A, x, y) {
                                    let L = A, ue = x, Fe = y;
                                    for (; Fe > ue;) {
                                        if (Fe -= ue, L = L.parent, !L) throw new Error("Invalid number of '../'");
                                        ue = L.segments.length
                                    }
                                    return new Wr(L, !1, ue - Fe)
                                }(y.snapshot._urlSegment, y.snapshot._lastPathIndex + L, A.numberOfDoubleDots)
                            }(Fe, x, A),
                            At = ft.processChildren ? J(ft.segmentGroup, ft.index, Fe.commands) : _i(ft.segmentGroup, ft.index, Fe.commands);
                        return Ei(x.root, ft.segmentGroup, At, L, ue)
                    }(zn, this.currentUrlTree, y, Kn, null != Cr ? Cr : null)
                }

                navigateByUrl(y, L = {skipLocationChange: !1}) {
                    const ue = Tr(y) ? y : this.parseUrl(y), Fe = this.urlHandlingStrategy.merge(ue, this.rawUrlTree);
                    return this.scheduleNavigation(Fe, "imperative", null, L)
                }

                navigate(y, L = {skipLocationChange: !1}) {
                    return function Cu(A) {
                        for (let x = 0; x < A.length; x++) {
                            const y = A[x];
                            if (null == y) throw new Error(`The requested path contains ${y} segment at index ${x}`)
                        }
                    }(y), this.navigateByUrl(this.createUrlTree(y, L), L)
                }

                serializeUrl(y) {
                    return this.urlSerializer.serialize(y)
                }

                parseUrl(y) {
                    let L;
                    try {
                        L = this.urlSerializer.parse(y)
                    } catch (ue) {
                        L = this.malformedUriErrorHandler(ue, this.urlSerializer, y)
                    }
                    return L
                }

                isActive(y, L) {
                    let ue;
                    if (ue = !0 === L ? Object.assign({}, Ts) : !1 === L ? Object.assign({}, Do) : L, Tr(y)) return _n(this.currentUrlTree, y, ue);
                    const Fe = this.parseUrl(y);
                    return _n(this.currentUrlTree, Fe, ue)
                }

                removeEmptyProps(y) {
                    return Object.keys(y).reduce((L, ue) => {
                        const Fe = y[ue];
                        return null != Fe && (L[ue] = Fe), L
                    }, {})
                }

                processNavigations() {
                    this.navigations.subscribe(y => {
                        this.navigated = !0, this.lastSuccessfulId = y.id, this.currentPageId = y.targetPageId, this.events.next(new fn(y.id, this.serializeUrl(y.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, y.resolve(!0)
                    }, y => {
                        this.console.warn(`Unhandled Navigation Error: ${y}`)
                    })
                }

                scheduleNavigation(y, L, ue, Fe, ft) {
                    var At, en;
                    if (this.disposed) return Promise.resolve(!1);
                    let zn, Cr, Kn;
                    ft ? (zn = ft.resolve, Cr = ft.reject, Kn = ft.promise) : Kn = new Promise((Li, zi) => {
                        zn = Li, Cr = zi
                    });
                    const Fr = ++this.navigationId;
                    let cr;
                    return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (ue = this.location.getState()), cr = ue && ue.\u0275routerPageId ? ue.\u0275routerPageId : Fe.replaceUrl || Fe.skipLocationChange ? null !== (At = this.browserPageId) && void 0 !== At ? At : 0 : (null !== (en = this.browserPageId) && void 0 !== en ? en : 0) + 1) : cr = 0, this.setTransition({
                        id: Fr,
                        targetPageId: cr,
                        source: L,
                        restoredState: ue,
                        currentUrlTree: this.currentUrlTree,
                        currentRawUrl: this.rawUrlTree,
                        rawUrl: y,
                        extras: Fe,
                        resolve: zn,
                        reject: Cr,
                        promise: Kn,
                        currentSnapshot: this.routerState.snapshot,
                        currentRouterState: this.routerState
                    }), Kn.catch(Li => Promise.reject(Li))
                }

                setBrowserUrl(y, L) {
                    const ue = this.urlSerializer.serialize(y),
                        Fe = Object.assign(Object.assign({}, L.extras.state), this.generateNgRouterState(L.id, L.targetPageId));
                    this.location.isCurrentPathEqualTo(ue) || L.extras.replaceUrl ? this.location.replaceState(ue, "", Fe) : this.location.go(ue, "", Fe)
                }

                restoreHistory(y, L = !1) {
                    var ue, Fe;
                    if ("computed" === this.canceledNavigationResolution) {
                        const ft = this.currentPageId - y.targetPageId;
                        "popstate" !== y.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (ue = this.currentNavigation) || void 0 === ue ? void 0 : ue.finalUrl) || 0 === ft ? this.currentUrlTree === (null === (Fe = this.currentNavigation) || void 0 === Fe ? void 0 : Fe.finalUrl) && 0 === ft && (this.resetState(y), this.browserUrlTree = y.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(ft)
                    } else "replace" === this.canceledNavigationResolution && (L && this.resetState(y), this.resetUrlToCurrentUrlTree())
                }

                resetState(y) {
                    this.routerState = y.currentRouterState, this.currentUrlTree = y.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, y.rawUrl)
                }

                resetUrlToCurrentUrlTree() {
                    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
                }

                cancelNavigationTransition(y, L) {
                    const ue = new rn(y.id, this.serializeUrl(y.extractedUrl), L);
                    this.triggerEvent(ue), y.resolve(!1)
                }

                generateNgRouterState(y, L) {
                    return "computed" === this.canceledNavigationResolution ? {
                        navigationId: y,
                        \u0275routerPageId: L
                    } : {navigationId: y}
                }
            }

            return A.\u0275fac = function (y) {
                r.$Z()
            }, A.\u0275prov = r.Yz7({token: A, factory: A.\u0275fac}), A
        })();

        function To(A) {
            return "imperative" !== A
        }

        let ks = (() => {
            class A {
                constructor(y, L, ue, Fe, ft) {
                    this.router = y, this.route = L, this.tabIndexAttribute = ue, this.renderer = Fe, this.el = ft, this.commands = null, this.onChanges = new I.xQ, this.setTabIndexIfNotOnNativeEl("0")
                }

                setTabIndexIfNotOnNativeEl(y) {
                    if (null != this.tabIndexAttribute) return;
                    const L = this.renderer, ue = this.el.nativeElement;
                    null !== y ? L.setAttribute(ue, "tabindex", y) : L.removeAttribute(ue, "tabindex")
                }

                ngOnChanges(y) {
                    this.onChanges.next(this)
                }

                set routerLink(y) {
                    null != y ? (this.commands = Array.isArray(y) ? y : [y], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null))
                }

                onClick() {
                    if (null === this.urlTree) return !0;
                    const y = {
                        skipLocationChange: As(this.skipLocationChange),
                        replaceUrl: As(this.replaceUrl),
                        state: this.state
                    };
                    return this.router.navigateByUrl(this.urlTree, y), !0
                }

                get urlTree() {
                    return null === this.commands ? null : this.router.createUrlTree(this.commands, {
                        relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route,
                        queryParams: this.queryParams,
                        fragment: this.fragment,
                        queryParamsHandling: this.queryParamsHandling,
                        preserveFragment: As(this.preserveFragment)
                    })
                }
            }

            return A.\u0275fac = function (y) {
                return new (y || A)(r.Y36(di), r.Y36(ei), r.$8M("tabindex"), r.Y36(r.Qsj), r.Y36(r.SBq))
            }, A.\u0275dir = r.lG2({
                type: A,
                selectors: [["", "routerLink", "", 5, "a", 5, "area"]],
                hostBindings: function (y, L) {
                    1 & y && r.NdJ("click", function () {
                        return L.onClick()
                    })
                },
                inputs: {
                    queryParams: "queryParams",
                    fragment: "fragment",
                    queryParamsHandling: "queryParamsHandling",
                    preserveFragment: "preserveFragment",
                    skipLocationChange: "skipLocationChange",
                    replaceUrl: "replaceUrl",
                    state: "state",
                    relativeTo: "relativeTo",
                    routerLink: "routerLink"
                },
                features: [r.TTD]
            }), A
        })();

        function As(A) {
            return "" === A || !!A
        }

        class Ws {
        }

        class Ls {
            preload(x, y) {
                return y().pipe(ze(() => (0, he.of)(null)))
            }
        }

        class Bs {
            preload(x, y) {
                return (0, he.of)(null)
            }
        }

        let fa = (() => {
            class A {
                constructor(y, L, ue, Fe) {
                    this.router = y, this.injector = ue, this.preloadingStrategy = Fe, this.loader = new cs(ue, L, en => y.triggerEvent(new Qn(en)), en => y.triggerEvent(new Wn(en)))
                }

                setUpPreloading() {
                    this.subscription = this.router.events.pipe((0, Le.h)(y => y instanceof fn), (0, Ft.b)(() => this.preload())).subscribe(() => {
                    })
                }

                preload() {
                    const y = this.injector.get(r.h0i);
                    return this.processRoutes(y, this.router.config)
                }

                ngOnDestroy() {
                    this.subscription && this.subscription.unsubscribe()
                }

                processRoutes(y, L) {
                    const ue = [];
                    for (const Fe of L) if (Fe.loadChildren && !Fe.canLoad && Fe._loadedConfig) {
                        const ft = Fe._loadedConfig;
                        ue.push(this.processRoutes(ft.module, ft.routes))
                    } else Fe.loadChildren && !Fe.canLoad ? ue.push(this.preloadConfig(y, Fe)) : Fe.children && ue.push(this.processRoutes(y, Fe.children));
                    return (0, yt.D)(ue).pipe((0, xe.J)(), (0, tt.U)(Fe => {
                    }))
                }

                preloadConfig(y, L) {
                    return this.preloadingStrategy.preload(L, () => (L._loadedConfig ? (0, he.of)(L._loadedConfig) : this.loader.load(y.injector, L)).pipe((0, zt.zg)(Fe => (L._loadedConfig = Fe, this.processRoutes(Fe.module, Fe.routes)))))
                }
            }

            return A.\u0275fac = function (y) {
                return new (y || A)(r.LFG(di), r.LFG(r.Sil), r.LFG(r.zs3), r.LFG(Ws))
            }, A.\u0275prov = r.Yz7({token: A, factory: A.\u0275fac}), A
        })(), Ks = (() => {
            class A {
                constructor(y, L, ue = {}) {
                    this.router = y, this.viewportScroller = L, this.options = ue, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, ue.scrollPositionRestoration = ue.scrollPositionRestoration || "disabled", ue.anchorScrolling = ue.anchorScrolling || "disabled"
                }

                init() {
                    "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents()
                }

                createScrollEvents() {
                    return this.router.events.subscribe(y => {
                        y instanceof bn ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = y.navigationTrigger, this.restoredId = y.restoredState ? y.restoredState.navigationId : 0) : y instanceof fn && (this.lastId = y.id, this.scheduleScrollEvent(y, this.router.parseUrl(y.urlAfterRedirects).fragment))
                    })
                }

                consumeScrollEvents() {
                    return this.router.events.subscribe(y => {
                        y instanceof Qe && (y.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(y.position) : y.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(y.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0]))
                    })
                }

                scheduleScrollEvent(y, L) {
                    this.router.triggerEvent(new Qe(y, "popstate" === this.lastSource ? this.store[this.restoredId] : null, L))
                }

                ngOnDestroy() {
                    this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe()
                }
            }

            return A.\u0275fac = function (y) {
                r.$Z()
            }, A.\u0275prov = r.Yz7({token: A, factory: A.\u0275fac}), A
        })();
        const ds = new r.OlP("ROUTER_CONFIGURATION"), Io = new r.OlP("ROUTER_FORROOT_GUARD"),
            ll = [Bt.Ye, {provide: We, useClass: Et}, {
                provide: di, useFactory: function Ms(A, x, y, L, ue, Fe, ft = {}, At, en) {
                    const zn = new di(null, A, x, y, L, ue, mn(Fe));
                    return At && (zn.urlHandlingStrategy = At), en && (zn.routeReuseStrategy = en), function pa(A, x) {
                        A.errorHandler && (x.errorHandler = A.errorHandler), A.malformedUriErrorHandler && (x.malformedUriErrorHandler = A.malformedUriErrorHandler), A.onSameUrlNavigation && (x.onSameUrlNavigation = A.onSameUrlNavigation), A.paramsInheritanceStrategy && (x.paramsInheritanceStrategy = A.paramsInheritanceStrategy), A.relativeLinkResolution && (x.relativeLinkResolution = A.relativeLinkResolution), A.urlUpdateStrategy && (x.urlUpdateStrategy = A.urlUpdateStrategy), A.canceledNavigationResolution && (x.canceledNavigationResolution = A.canceledNavigationResolution)
                    }(ft, zn), ft.enableTracing && zn.events.subscribe(Cr => {
                        var Kn, Fr;
                        null === (Kn = console.group) || void 0 === Kn || Kn.call(console, `Router Event: ${Cr.constructor.name}`), console.log(Cr.toString()), console.log(Cr), null === (Fr = console.groupEnd) || void 0 === Fr || Fr.call(console)
                    }), zn
                }, deps: [We, z, Bt.Ye, r.zs3, r.Sil, ls, ds, [class us {
                }, new r.FiY], [Ss, new r.FiY]]
            }, z, {
                provide: ei, useFactory: function Oo(A) {
                    return A.routerState.root
                }, deps: [di]
            }, fa, Bs, Ls, {provide: ds, useValue: {enableTracing: !1}}];

        function cl() {
            return new r.PXZ("Router", di)
        }

        let qs = (() => {
            class A {
                constructor(y, L) {
                }

                static forRoot(y, L) {
                    return {
                        ngModule: A,
                        providers: [ll, Po(y), {
                            provide: Io,
                            useFactory: ha,
                            deps: [[di, new r.FiY, new r.tp0]]
                        }, {provide: ds, useValue: L || {}}, {
                            provide: Bt.S$,
                            useFactory: ul,
                            deps: [Bt.lw, [new r.tBr(Bt.mr), new r.FiY], ds]
                        }, {provide: Ks, useFactory: $s, deps: [di, Bt.EM, ds]}, {
                            provide: Ws,
                            useExisting: L && L.preloadingStrategy ? L.preloadingStrategy : Bs
                        }, {provide: r.PXZ, multi: !0, useFactory: cl}, [Vs, {
                            provide: r.ip1,
                            multi: !0,
                            useFactory: Is,
                            deps: [Vs]
                        }, {provide: xs, useFactory: Ps, deps: [Vs]}, {provide: r.tb, multi: !0, useExisting: xs}]]
                    }
                }

                static forChild(y) {
                    return {ngModule: A, providers: [Po(y)]}
                }
            }

            return A.\u0275fac = function (y) {
                return new (y || A)(r.LFG(Io, 8), r.LFG(di, 8))
            }, A.\u0275mod = r.oAB({type: A}), A.\u0275inj = r.cJS({}), A
        })();

        function $s(A, x, y) {
            return y.scrollOffset && x.setOffset(y.scrollOffset), new Ks(A, x, y)
        }

        function ul(A, x, y = {}) {
            return y.useHash ? new Bt.Do(A, x) : new Bt.b0(A, x)
        }

        function ha(A) {
            return "guarded"
        }

        function Po(A) {
            return [{provide: r.deG, multi: !0, useValue: A}, {provide: ls, multi: !0, useValue: A}]
        }

        let Vs = (() => {
            class A {
                constructor(y) {
                    this.injector = y, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new I.xQ
                }

                appInitializer() {
                    return this.injector.get(Bt.V_, Promise.resolve(null)).then(() => {
                        if (this.destroyed) return Promise.resolve(!0);
                        let L = null;
                        const ue = new Promise(At => L = At), Fe = this.injector.get(di), ft = this.injector.get(ds);
                        return "disabled" === ft.initialNavigation ? (Fe.setUpLocationChangeListener(), L(!0)) : "enabled" === ft.initialNavigation || "enabledBlocking" === ft.initialNavigation ? (Fe.hooks.afterPreactivation = () => this.initNavigation ? (0, he.of)(null) : (this.initNavigation = !0, L(!0), this.resultOfPreactivationDone), Fe.initialNavigation()) : L(!0), ue
                    })
                }

                bootstrapListener(y) {
                    const L = this.injector.get(ds), ue = this.injector.get(fa), Fe = this.injector.get(Ks),
                        ft = this.injector.get(di), At = this.injector.get(r.z2F);
                    y === At.components[0] && (("enabledNonBlocking" === L.initialNavigation || void 0 === L.initialNavigation) && ft.initialNavigation(), ue.setUpPreloading(), Fe.init(), ft.resetRootComponentType(At.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete())
                }

                ngOnDestroy() {
                    this.destroyed = !0
                }
            }

            return A.\u0275fac = function (y) {
                return new (y || A)(r.LFG(r.zs3))
            }, A.\u0275prov = r.Yz7({token: A, factory: A.\u0275fac}), A
        })();

        function Is(A) {
            return A.appInitializer.bind(A)
        }

        function Ps(A) {
            return A.bootstrapListener.bind(A)
        }

        const xs = new r.OlP("Router Initializer")
    }, 9485: (Jt, lt, R) => {
        "use strict";
        R.d(lt, {nF: () => Je, kz: () => q, YC: () => ze});
        var r = R(6435), D = R(9808), ie = R(6540), te = R(5529), j = R(1086);
        const W = ["prevElRef"], Q = ["nextElRef"], Ne = ["scrollbarElRef"], ve = ["paginationElRef"];

        function me(Le, ut) {
            1 & Le && (r.ynx(0), r._UZ(1, "div", 6, 7)(3, "div", 8, 9), r.BQk())
        }

        function ae(Le, ut) {
            1 & Le && r._UZ(0, "div", 10, 11)
        }

        function X(Le, ut) {
            1 & Le && r._UZ(0, "div", 12, 13)
        }

        function M(Le, ut) {
        }

        function H(Le, ut) {
            1 & Le && r.YNc(0, M, 0, 0, "ng-template")
        }

        function F(Le, ut) {
        }

        function oe(Le, ut) {
            1 & Le && r.YNc(0, F, 0, 0, "ng-template")
        }

        function ge(Le, ut) {
        }

        function Ie(Le, ut) {
            1 & Le && r.YNc(0, ge, 0, 0, "ng-template")
        }

        function he(Le, ut) {
        }

        const xe = function (Le) {
            return {$implicit: Le}
        };

        function Ue(Le, ut) {
            if (1 & Le && (r.TgZ(0, "div", 3), r.YNc(1, he, 0, 0, "ng-template", 18), r.qZA()), 2 & Le) {
                const Ye = r.oxw().$implicit, Mt = r.oxw(2);
                r.Q6J("ngClass", Mt.zoomContainerClass), r.xp6(1), r.Q6J("ngTemplateOutlet", Ye.template)("ngTemplateOutletContext", r.VKq(3, xe, Ye.slideData))
            }
        }

        function it(Le, ut) {
        }

        function yt(Le, ut) {
            if (1 & Le && (r.ynx(0), r.YNc(1, it, 0, 0, "ng-template", 18), r.BQk()), 2 & Le) {
                const Ye = r.oxw().$implicit;
                r.xp6(1), r.Q6J("ngTemplateOutlet", Ye.template)("ngTemplateOutletContext", r.VKq(2, xe, Ye.slideData))
            }
        }

        function Ce(Le, ut) {
            if (1 & Le && (r.TgZ(0, "div", 15), r.YNc(1, Ue, 2, 5, "div", 16), r.YNc(2, yt, 2, 4, "ng-container", 17), r.qZA()), 2 & Le) {
                const Ye = ut.$implicit, Mt = r.oxw().key, _t = r.oxw();
                r.Akn(_t.style), r.Q6J("ngClass", (Ye.class ? Ye.class + " " : "") + _t.slideClass + ("" !== Mt ? " " + _t.slideDuplicateClass : ""))("ngSwitch", Ye.zoom), r.uIk("data-swiper-slide-index", Ye.virtualIndex ? Ye.virtualIndex : Ye.slideIndex)("data-swiper-autoplay", Ye.autoplayDelay), r.xp6(1), r.Q6J("ngSwitchCase", !0)
            }
        }

        function $e(Le, ut) {
            1 & Le && (r.YNc(0, Ce, 3, 7, "div", 14), r.ALo(1, "async")), 2 & Le && r.Q6J("ngForOf", r.lcZ(1, 1, ut.loopSlides))
        }

        const rt = [[["", "slot", "container-start"]], [["", "slot", "wrapper-start"]], [["", "slot", "wrapper-end"]], [["", "slot", "container-end"]]],
            Xe = function (Le) {
                return {loopSlides: Le, key: "prepend"}
            }, Ee = function (Le) {
                return {loopSlides: Le, key: ""}
            }, ce = function (Le) {
                return {loopSlides: Le, key: "append"}
            }, I = ["[slot=container-start]", "[slot=wrapper-start]", "[slot=wrapper-end]", "[slot=container-end]"],
            l = ["init", "enabled", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "on"];

        function f(Le) {
            return "object" == typeof Le && null !== Le && Le.constructor && "Object" === Object.prototype.toString.call(Le).slice(8, -1)
        }

        function g(Le) {
            return void 0 !== Le && "boolean" != typeof Le && !0 === Le.enabled
        }

        function v(Le, ut, Ye) {
            return !0 === P(Le) && ut && !ut.el || !("boolean" != typeof ut && ut.el !== (null == Ye ? void 0 : Ye.nativeElement) && ("string" == typeof ut.el || "object" == typeof ut.el))
        }

        function w(Le, ut) {
            const Ye = ["__proto__", "constructor", "prototype"];
            Object.keys(ut).filter(Mt => Ye.indexOf(Mt) < 0).forEach(Mt => {
                void 0 !== Le[Mt] ? Le[Mt] && !ut[Mt] || (f(ut[Mt]) && f(Le[Mt]) && Object.keys(ut[Mt]).length > 0 ? ut[Mt].__swiper__ ? Le[Mt] = ut[Mt] : w(Le[Mt], ut[Mt]) : Le[Mt] = ut[Mt]) : Le[Mt] = ut[Mt]
            })
        }

        function P(Le) {
            return null != Le && "false" != `${Le}`
        }

        const B = ["pagination", "navigation", "scrollbar", "virtual"];

        function O(Le, ut = {}) {
            return f(Le) ? Le : !0 === P(Le) && ut
        }

        function Z(Le = {}) {
            const ut = {on: {}}, Ye = {};
            w(ut, ie.ZP.defaults), w(ut, ie.ZP.extendedDefaults), ut._emitClasses = !0, ut.init = !1;
            const Mt = {}, _t = l.map(Pt => Pt.replace(/_/, ""));
            return Object.keys(Le).forEach(Pt => {
                const Gt = Pt.replace(/^_/, "");
                _t.indexOf(Gt) >= 0 ? f(Le[Pt]) ? (ut[Gt] = {}, Ye[Gt] = {}, w(ut[Gt], Le[Pt]), w(Ye[Gt], Le[Pt])) : (ut[Gt] = Le[Pt], Ye[Gt] = Le[Pt]) : Mt[Gt] = Le[Pt]
            }), ["navigation", "pagination", "scrollbar"].forEach(Pt => {
                !0 === ut[Pt] && (ut[Pt] = {}), !1 === ut[Pt] && delete ut[Pt]
            }), {params: ut, passedParams: Ye, rest: Mt}
        }

        l.map(Le => Le.replace(/_/, ""));
        let ze = (() => {
            class Le {
                constructor(Ye) {
                    this.template = Ye, this.class = "", this.autoplayDelay = null, this.slideData = {
                        isActive: !1,
                        isPrev: !1,
                        isNext: !1,
                        isVisible: !1,
                        isDuplicate: !1
                    }
                }

                set ngClass(Ye) {
                    this.class = [this.class || "", Ye].join(" ")
                }

                set zoom(Ye) {
                    this._zoom = P(Ye)
                }

                get zoom() {
                    return this._zoom
                }

                get classNames() {
                    return this._classNames
                }

                set classNames(Ye) {
                    this._classNames !== Ye && (this._classNames = Ye, this.slideData = {
                        isActive: this._hasClass(["swiper-slide-active", "swiper-slide-duplicate-active"]),
                        isVisible: this._hasClass(["swiper-slide-visible"]),
                        isDuplicate: this._hasClass(["swiper-slide-duplicate"]),
                        isPrev: this._hasClass(["swiper-slide-prev", "swiper-slide-duplicate-prev"]),
                        isNext: this._hasClass(["swiper-slide-next", "swiper-slide-duplicate-next"])
                    })
                }

                _hasClass(Ye) {
                    return Ye.some(Mt => this._classNames.indexOf(Mt) >= 0)
                }
            }

            return Le.\u0275fac = function (Ye) {
                return new (Ye || Le)(r.Y36(r.Rgc))
            }, Le.\u0275dir = r.lG2({
                type: Le,
                selectors: [["ng-template", "swiperSlide", ""]],
                inputs: {
                    virtualIndex: "virtualIndex",
                    class: "class",
                    ngClass: "ngClass",
                    autoplayDelay: ["data-swiper-autoplay", "autoplayDelay"],
                    zoom: "zoom"
                }
            }), Le
        })(), Je = (() => {
            class Le {
                constructor(Ye, Mt, _t, Pt) {
                    this._ngZone = Ye, this.elementRef = Mt, this._changeDetectorRef = _t, this._platformId = Pt, this.slideClass = "swiper-slide", this.wrapperClass = "swiper-wrapper", this.showNavigation = !0, this.showPagination = !0, this.showScrollbar = !0, this.s__beforeBreakpoint = new r.vpe, this.s__containerClasses = new r.vpe, this.s__slideClass = new r.vpe, this.s__swiper = new r.vpe, this.s_activeIndexChange = new r.vpe, this.s_afterInit = new r.vpe, this.s_autoplay = new r.vpe, this.s_autoplayStart = new r.vpe, this.s_autoplayStop = new r.vpe, this.s_autoplayPause = new r.vpe, this.s_autoplayResume = new r.vpe, this.s_beforeDestroy = new r.vpe, this.s_beforeInit = new r.vpe, this.s_beforeLoopFix = new r.vpe, this.s_beforeResize = new r.vpe, this.s_beforeSlideChangeStart = new r.vpe, this.s_beforeTransitionStart = new r.vpe, this.s_breakpoint = new r.vpe, this.s_changeDirection = new r.vpe, this.s_click = new r.vpe, this.s_doubleTap = new r.vpe, this.s_doubleClick = new r.vpe, this.s_destroy = new r.vpe, this.s_fromEdge = new r.vpe, this.s_hashChange = new r.vpe, this.s_hashSet = new r.vpe, this.s_imagesReady = new r.vpe, this.s_init = new r.vpe, this.s_keyPress = new r.vpe, this.s_lazyImageLoad = new r.vpe, this.s_lazyImageReady = new r.vpe, this.s_loopFix = new r.vpe, this.s_momentumBounce = new r.vpe, this.s_navigationHide = new r.vpe, this.s_navigationShow = new r.vpe, this.s_navigationPrev = new r.vpe, this.s_navigationNext = new r.vpe, this.s_observerUpdate = new r.vpe, this.s_orientationchange = new r.vpe, this.s_paginationHide = new r.vpe, this.s_paginationRender = new r.vpe, this.s_paginationShow = new r.vpe, this.s_paginationUpdate = new r.vpe, this.s_progress = new r.vpe, this.s_reachBeginning = new r.vpe, this.s_reachEnd = new r.vpe, this.s_realIndexChange = new r.vpe, this.s_resize = new r.vpe, this.s_scroll = new r.vpe, this.s_scrollbarDragEnd = new r.vpe, this.s_scrollbarDragMove = new r.vpe, this.s_scrollbarDragStart = new r.vpe, this.s_setTransition = new r.vpe, this.s_setTranslate = new r.vpe, this.s_slideChange = new r.vpe, this.s_slideChangeTransitionEnd = new r.vpe, this.s_slideChangeTransitionStart = new r.vpe, this.s_slideNextTransitionEnd = new r.vpe, this.s_slideNextTransitionStart = new r.vpe, this.s_slidePrevTransitionEnd = new r.vpe, this.s_slidePrevTransitionStart = new r.vpe, this.s_slideResetTransitionStart = new r.vpe, this.s_slideResetTransitionEnd = new r.vpe, this.s_sliderMove = new r.vpe, this.s_sliderFirstMove = new r.vpe, this.s_slidesLengthChange = new r.vpe, this.s_slidesGridLengthChange = new r.vpe, this.s_snapGridLengthChange = new r.vpe, this.s_snapIndexChange = new r.vpe, this.s_tap = new r.vpe, this.s_toEdge = new r.vpe, this.s_touchEnd = new r.vpe, this.s_touchMove = new r.vpe, this.s_touchMoveOpposite = new r.vpe, this.s_touchStart = new r.vpe, this.s_transitionEnd = new r.vpe, this.s_transitionStart = new r.vpe, this.s_update = new r.vpe, this.s_zoomChange = new r.vpe, this.s_swiper = new r.vpe, this.s_lock = new r.vpe, this.s_unlock = new r.vpe, this._activeSlides = new te.xQ, this.containerClasses = "swiper", this.slidesChanges = Gt => {
                        this.slides = Gt.map((yn, Xt) => (yn.slideIndex = Xt, yn.classNames = this.slideClass || "", yn)), this.loop && !this.loopedSlides && this.calcLoopedSlides(), this.virtual ? this.swiperRef && this.swiperRef.virtual && this._ngZone.runOutsideAngular(() => {
                            this.swiperRef.virtual.slides = this.slides, this.swiperRef.virtual.update(!0)
                        }) : this.loopedSlides && (this.prependSlides = (0, j.of)(this.slides.slice(this.slides.length - this.loopedSlides)), this.appendSlides = (0, j.of)(this.slides.slice(0, this.loopedSlides))), this._changeDetectorRef.detectChanges()
                    }, this.style = null, this.updateVirtualSlides = Gt => {
                        !this.swiperRef || this.currentVirtualData && this.currentVirtualData.from === Gt.from && this.currentVirtualData.to === Gt.to && this.currentVirtualData.offset === Gt.offset || (this.style = this.swiperRef.isHorizontal() ? {[this.swiperRef.rtlTranslate ? "right" : "left"]: `${Gt.offset}px`} : {top: `${Gt.offset}px`}, this.currentVirtualData = Gt, this._activeSlides.next(Gt.slides), this._ngZone.run(() => {
                            this._changeDetectorRef.detectChanges()
                        }), this._ngZone.runOutsideAngular(() => {
                            this.swiperRef.updateSlides(), this.swiperRef.updateProgress(), this.swiperRef.updateSlidesClasses(), g(this.swiperRef.params.lazy) && this.swiperRef.lazy.load(), this.swiperRef.virtual.update(!0)
                        }))
                    }
                }

                set navigation(Ye) {
                    var Mt, _t, Pt;
                    const Gt = "boolean" != typeof this._navigation && "" !== this._navigation ? null === (Mt = this._navigation) || void 0 === Mt ? void 0 : Mt.nextEl : null,
                        yn = "boolean" != typeof this._navigation && "" !== this._navigation ? null === (_t = this._navigation) || void 0 === _t ? void 0 : _t.prevEl : null;
                    this._navigation = O(Ye, {
                        nextEl: Gt || null,
                        prevEl: yn || null
                    }), this.showNavigation = !(!0 !== P(Ye) || this._navigation && "boolean" != typeof this._navigation && this._navigation.prevEl !== (null === (Pt = this._prevElRef) || void 0 === Pt ? void 0 : Pt.nativeElement) && (null !== this._navigation.prevEl || null !== this._navigation.nextEl) && ("string" == typeof this._navigation.nextEl || "string" == typeof this._navigation.prevEl || "object" == typeof this._navigation.nextEl || "object" == typeof this._navigation.prevEl))
                }

                get navigation() {
                    return this._navigation
                }

                set pagination(Ye) {
                    var Mt;
                    const _t = "boolean" != typeof this._pagination && "" !== this._pagination ? null === (Mt = this._pagination) || void 0 === Mt ? void 0 : Mt.el : null;
                    this._pagination = O(Ye, {el: _t || null}), this.showPagination = v(Ye, this._pagination, this._paginationElRef)
                }

                get pagination() {
                    return this._pagination
                }

                set scrollbar(Ye) {
                    var Mt;
                    const _t = "boolean" != typeof this._scrollbar && "" !== this._scrollbar ? null === (Mt = this._scrollbar) || void 0 === Mt ? void 0 : Mt.el : null;
                    this._scrollbar = O(Ye, {el: _t || null}), this.showScrollbar = v(Ye, this._scrollbar, this._scrollbarElRef)
                }

                get scrollbar() {
                    return this._scrollbar
                }

                set virtual(Ye) {
                    this._virtual = O(Ye)
                }

                get virtual() {
                    return this._virtual
                }

                set config(Ye) {
                    this.updateSwiper(Ye);
                    const {params: Mt} = Z(Ye);
                    Object.assign(this, Mt)
                }

                set prevElRef(Ye) {
                    this._prevElRef = Ye, this._setElement(Ye, this.navigation, "navigation", "prevEl")
                }

                set nextElRef(Ye) {
                    this._nextElRef = Ye, this._setElement(Ye, this.navigation, "navigation", "nextEl")
                }

                set scrollbarElRef(Ye) {
                    this._scrollbarElRef = Ye, this._setElement(Ye, this.scrollbar, "scrollbar")
                }

                set paginationElRef(Ye) {
                    this._paginationElRef = Ye, this._setElement(Ye, this.pagination, "pagination")
                }

                get activeSlides() {
                    return this.virtual ? this._activeSlides : (0, j.of)(this.slides)
                }

                get zoomContainerClass() {
                    return this.zoom && "boolean" != typeof this.zoom ? this.zoom.containerClass : "swiper-zoom-container"
                }

                _setElement(Ye, Mt, _t, Pt = "el") {
                    if (!Mt || !Ye) return;
                    if (Ye.nativeElement) {
                        if (Mt[Pt] === Ye.nativeElement) return;
                        Mt[Pt] = Ye.nativeElement
                    }
                    const Gt = {};
                    Gt[_t] = !0, this.updateInitSwiper(Gt)
                }

                ngOnInit() {
                    const {params: Ye} = Z(this);
                    Object.assign(this, Ye)
                }

                ngAfterViewInit() {
                    this.childrenSlidesInit(), this.initSwiper(), this._changeDetectorRef.detectChanges(), setTimeout(() => {
                        this.s_swiper.emit(this.swiperRef)
                    })
                }

                childrenSlidesInit() {
                    this.slidesChanges(this.slidesEl), this.slidesEl.changes.subscribe(this.slidesChanges)
                }

                get isSwiperActive() {
                    return this.swiperRef && !this.swiperRef.destroyed
                }

                initSwiper() {
                    const {params: Ye} = Z(this);
                    Object.assign(this, Ye), this._ngZone.runOutsideAngular(() => {
                        Ye.init = !1, Ye.virtual || (Ye.observer = !0), Ye.onAny = (Xt, ...xn) => {
                            const Fn = this["s_" + Xt];
                            Fn && Fn.emit([...xn])
                        }, Object.assign(Ye.on, {
                            _containerClasses: (Xt, xn) => {
                                setTimeout(() => {
                                    this.containerClasses = xn
                                })
                            }, _slideClasses: (Xt, xn) => {
                                xn.forEach(({slideEl: Fn, classNames: wn}, Nn) => {
                                    const On = Fn.getAttribute("data-swiper-slide-index"), Me = On ? parseInt(On) : Nn;
                                    if (this.virtual) {
                                        const ne = this.slides.find(U => U.virtualIndex && U.virtualIndex === Me);
                                        if (ne) return void (ne.classNames = wn)
                                    }
                                    this.slides[Me] && (this.slides[Me].classNames = wn)
                                }), this._changeDetectorRef.detectChanges()
                            }
                        });
                        const Gt = new ie.ZP(Ye);
                        Gt.loopCreate = () => {
                        }, Gt.loopDestroy = () => {
                        }, Ye.loop && (Gt.loopedSlides = this.loopedSlides);
                        const yn = g(Gt.params.virtual);
                        if (Gt.virtual && yn) {
                            Gt.virtual.slides = this.slides;
                            const Xt = {
                                cache: !1,
                                slides: this.slides,
                                renderExternal: this.updateVirtualSlides,
                                renderExternalUpdate: !1
                            };
                            w(Gt.params.virtual, Xt), w(Gt.originalParams.virtual, Xt)
                        }
                        if ((0, D.NF)(this._platformId)) {
                            this.swiperRef = Gt.init(this.elementRef.nativeElement);
                            const Xt = g(this.swiperRef.params.virtual);
                            this.swiperRef.virtual && Xt && this.swiperRef.virtual.update(!0), this._changeDetectorRef.detectChanges()
                        }
                    })
                }

                ngOnChanges(Ye) {
                    this.updateSwiper(Ye), this._changeDetectorRef.detectChanges()
                }

                updateInitSwiper(Ye) {
                    !Ye || !this.swiperRef || this.swiperRef.destroyed || this._ngZone.runOutsideAngular(() => {
                        const {pagination: _t, navigation: Pt, scrollbar: Gt, thumbs: Xt} = this.swiperRef;
                        Ye.pagination && (this.pagination && "boolean" != typeof this.pagination && this.pagination.el && _t && !_t.el ? (this.updateParameter("pagination", this.pagination), _t.init(), _t.render(), _t.update()) : (_t.destroy(), _t.el = null)), Ye.scrollbar && (this.scrollbar && "boolean" != typeof this.scrollbar && this.scrollbar.el && Gt && !Gt.el ? (this.updateParameter("scrollbar", this.scrollbar), Gt.init(), Gt.updateSize(), Gt.setTranslate()) : (Gt.destroy(), Gt.el = null)), Ye.navigation && (this.navigation && "boolean" != typeof this.navigation && this.navigation.prevEl && this.navigation.nextEl && Pt && !Pt.prevEl && !Pt.nextEl ? (this.updateParameter("navigation", this.navigation), Pt.init(), Pt.update()) : Pt.prevEl && Pt.nextEl && (Pt.destroy(), Pt.nextEl = null, Pt.prevEl = null)), Ye.thumbs && this.thumbs && this.thumbs.swiper && (this.updateParameter("thumbs", this.thumbs), Xt.init() && Xt.update(!0)), Ye.controller && this.controller && this.controller.control && (this.swiperRef.controller.control = this.controller.control), this.swiperRef.update()
                    })
                }

                updateSwiper(Ye) {
                    this._ngZone.runOutsideAngular(() => {
                        var Mt, _t;
                        if (!Ye.config && Ye && this.swiperRef && !this.swiperRef.destroyed) {
                            for (const Pt in Ye) {
                                if (B.indexOf(Pt) >= 0) continue;
                                const Gt = null !== (_t = null === (Mt = Ye[Pt]) || void 0 === Mt ? void 0 : Mt.currentValue) && void 0 !== _t ? _t : Ye[Pt];
                                this.updateParameter(Pt, Gt)
                            }
                            Ye.allowSlideNext && (this.swiperRef.allowSlideNext = this.allowSlideNext), Ye.allowSlidePrev && (this.swiperRef.allowSlidePrev = this.allowSlidePrev), Ye.direction && this.swiperRef.changeDirection(this.direction, !1), Ye.breakpoints && (this.loop && !this.loopedSlides && this.calcLoopedSlides(), this.swiperRef.currentBreakpoint = null, this.swiperRef.setBreakpoint()), (Ye.thumbs || Ye.controller) && this.updateInitSwiper(Ye), this.swiperRef.update()
                        }
                    })
                }

                calcLoopedSlides() {
                    if (!this.loop) return !1;
                    let Ye = this.slidesPerView;
                    if (this.breakpoints) {
                        const _t = ie.ZP.prototype.getBreakpoint(this.breakpoints),
                            Pt = _t in this.breakpoints ? this.breakpoints[_t] : void 0;
                        Pt && Pt.slidesPerView && (Ye = Pt.slidesPerView)
                    }
                    if ("auto" === Ye) return this.loopedSlides = this.slides.length, this.slides.length;
                    let Mt = this.loopedSlides || Ye;
                    return !!Mt && (this.loopAdditionalSlides && (Mt += this.loopAdditionalSlides), Mt > this.slides.length && (Mt = this.slides.length), this.loopedSlides = Mt, !0)
                }

                updateParameter(Ye, Mt) {
                    if (!this.swiperRef || this.swiperRef.destroyed) return;
                    const _t = Ye.replace(/^_/, ""), Pt = f(this.swiperRef.params[_t]);
                    "enabled" !== _t ? Pt && f(Mt) ? w(this.swiperRef.params[_t], Mt) : this.swiperRef.params[_t] = Mt : !0 === Mt ? this.swiperRef.enable() : !1 === Mt && this.swiperRef.disable()
                }

                ngOnDestroy() {
                    this._ngZone.runOutsideAngular(() => {
                        var Ye;
                        null === (Ye = this.swiperRef) || void 0 === Ye || Ye.destroy(!0, !1)
                    })
                }
            }

            return Le.\u0275fac = function (Ye) {
                return new (Ye || Le)(r.Y36(r.R0b), r.Y36(r.SBq), r.Y36(r.sBO), r.Y36(r.Lbi))
            }, Le.\u0275cmp = r.Xpm({
                type: Le,
                selectors: [["swiper"], ["", "swiper", ""]],
                contentQueries: function (Ye, Mt, _t) {
                    if (1 & Ye && r.Suo(_t, ze, 4), 2 & Ye) {
                        let Pt;
                        r.iGM(Pt = r.CRH()) && (Mt.slidesEl = Pt)
                    }
                },
                viewQuery: function (Ye, Mt) {
                    if (1 & Ye && (r.Gf(W, 5), r.Gf(Q, 5), r.Gf(Ne, 5), r.Gf(ve, 5)), 2 & Ye) {
                        let _t;
                        r.iGM(_t = r.CRH()) && (Mt.prevElRef = _t.first), r.iGM(_t = r.CRH()) && (Mt.nextElRef = _t.first), r.iGM(_t = r.CRH()) && (Mt.scrollbarElRef = _t.first), r.iGM(_t = r.CRH()) && (Mt.paginationElRef = _t.first)
                    }
                },
                hostVars: 2,
                hostBindings: function (Ye, Mt) {
                    2 & Ye && r.Tol(Mt.containerClasses)
                },
                inputs: {
                    enabled: "enabled",
                    on: "on",
                    direction: "direction",
                    touchEventsTarget: "touchEventsTarget",
                    initialSlide: "initialSlide",
                    speed: "speed",
                    cssMode: "cssMode",
                    updateOnWindowResize: "updateOnWindowResize",
                    resizeObserver: "resizeObserver",
                    nested: "nested",
                    focusableElements: "focusableElements",
                    width: "width",
                    height: "height",
                    preventInteractionOnTransition: "preventInteractionOnTransition",
                    userAgent: "userAgent",
                    url: "url",
                    edgeSwipeDetection: "edgeSwipeDetection",
                    edgeSwipeThreshold: "edgeSwipeThreshold",
                    freeMode: "freeMode",
                    autoHeight: "autoHeight",
                    setWrapperSize: "setWrapperSize",
                    virtualTranslate: "virtualTranslate",
                    effect: "effect",
                    breakpoints: "breakpoints",
                    spaceBetween: "spaceBetween",
                    slidesPerView: "slidesPerView",
                    maxBackfaceHiddenSlides: "maxBackfaceHiddenSlides",
                    grid: "grid",
                    slidesPerGroup: "slidesPerGroup",
                    slidesPerGroupSkip: "slidesPerGroupSkip",
                    centeredSlides: "centeredSlides",
                    centeredSlidesBounds: "centeredSlidesBounds",
                    slidesOffsetBefore: "slidesOffsetBefore",
                    slidesOffsetAfter: "slidesOffsetAfter",
                    normalizeSlideIndex: "normalizeSlideIndex",
                    centerInsufficientSlides: "centerInsufficientSlides",
                    watchOverflow: "watchOverflow",
                    roundLengths: "roundLengths",
                    touchRatio: "touchRatio",
                    touchAngle: "touchAngle",
                    simulateTouch: "simulateTouch",
                    shortSwipes: "shortSwipes",
                    longSwipes: "longSwipes",
                    longSwipesRatio: "longSwipesRatio",
                    longSwipesMs: "longSwipesMs",
                    followFinger: "followFinger",
                    allowTouchMove: "allowTouchMove",
                    threshold: "threshold",
                    touchMoveStopPropagation: "touchMoveStopPropagation",
                    touchStartPreventDefault: "touchStartPreventDefault",
                    touchStartForcePreventDefault: "touchStartForcePreventDefault",
                    touchReleaseOnEdges: "touchReleaseOnEdges",
                    uniqueNavElements: "uniqueNavElements",
                    resistance: "resistance",
                    resistanceRatio: "resistanceRatio",
                    watchSlidesProgress: "watchSlidesProgress",
                    grabCursor: "grabCursor",
                    preventClicks: "preventClicks",
                    preventClicksPropagation: "preventClicksPropagation",
                    slideToClickedSlide: "slideToClickedSlide",
                    preloadImages: "preloadImages",
                    updateOnImagesReady: "updateOnImagesReady",
                    loop: "loop",
                    loopAdditionalSlides: "loopAdditionalSlides",
                    loopedSlides: "loopedSlides",
                    loopedSlidesLimit: "loopedSlidesLimit",
                    loopFillGroupWithBlank: "loopFillGroupWithBlank",
                    loopPreventsSlide: "loopPreventsSlide",
                    rewind: "rewind",
                    allowSlidePrev: "allowSlidePrev",
                    allowSlideNext: "allowSlideNext",
                    swipeHandler: "swipeHandler",
                    noSwiping: "noSwiping",
                    noSwipingClass: "noSwipingClass",
                    noSwipingSelector: "noSwipingSelector",
                    passiveListeners: "passiveListeners",
                    containerModifierClass: "containerModifierClass",
                    slideClass: "slideClass",
                    slideBlankClass: "slideBlankClass",
                    slideActiveClass: "slideActiveClass",
                    slideDuplicateActiveClass: "slideDuplicateActiveClass",
                    slideVisibleClass: "slideVisibleClass",
                    slideDuplicateClass: "slideDuplicateClass",
                    slideNextClass: "slideNextClass",
                    slideDuplicateNextClass: "slideDuplicateNextClass",
                    slidePrevClass: "slidePrevClass",
                    slideDuplicatePrevClass: "slideDuplicatePrevClass",
                    wrapperClass: "wrapperClass",
                    runCallbacksOnInit: "runCallbacksOnInit",
                    observeParents: "observeParents",
                    observeSlideChildren: "observeSlideChildren",
                    a11y: "a11y",
                    autoplay: "autoplay",
                    controller: "controller",
                    coverflowEffect: "coverflowEffect",
                    cubeEffect: "cubeEffect",
                    fadeEffect: "fadeEffect",
                    flipEffect: "flipEffect",
                    creativeEffect: "creativeEffect",
                    cardsEffect: "cardsEffect",
                    hashNavigation: "hashNavigation",
                    history: "history",
                    keyboard: "keyboard",
                    lazy: "lazy",
                    mousewheel: "mousewheel",
                    parallax: "parallax",
                    thumbs: "thumbs",
                    zoom: "zoom",
                    class: "class",
                    id: "id",
                    navigation: "navigation",
                    pagination: "pagination",
                    scrollbar: "scrollbar",
                    virtual: "virtual",
                    config: "config"
                },
                outputs: {
                    s__beforeBreakpoint: "_beforeBreakpoint",
                    s__containerClasses: "_containerClasses",
                    s__slideClass: "_slideClass",
                    s__swiper: "_swiper",
                    s_activeIndexChange: "activeIndexChange",
                    s_afterInit: "afterInit",
                    s_autoplay: "autoplay",
                    s_autoplayStart: "autoplayStart",
                    s_autoplayStop: "autoplayStop",
                    s_autoplayPause: "autoplayPause",
                    s_autoplayResume: "autoplayResume",
                    s_beforeDestroy: "beforeDestroy",
                    s_beforeInit: "beforeInit",
                    s_beforeLoopFix: "beforeLoopFix",
                    s_beforeResize: "beforeResize",
                    s_beforeSlideChangeStart: "beforeSlideChangeStart",
                    s_beforeTransitionStart: "beforeTransitionStart",
                    s_breakpoint: "breakpoint",
                    s_changeDirection: "changeDirection",
                    s_click: "click",
                    s_doubleTap: "doubleTap",
                    s_doubleClick: "doubleClick",
                    s_destroy: "destroy",
                    s_fromEdge: "fromEdge",
                    s_hashChange: "hashChange",
                    s_hashSet: "hashSet",
                    s_imagesReady: "imagesReady",
                    s_init: "init",
                    s_keyPress: "keyPress",
                    s_lazyImageLoad: "lazyImageLoad",
                    s_lazyImageReady: "lazyImageReady",
                    s_loopFix: "loopFix",
                    s_momentumBounce: "momentumBounce",
                    s_navigationHide: "navigationHide",
                    s_navigationShow: "navigationShow",
                    s_navigationPrev: "navigationPrev",
                    s_navigationNext: "navigationNext",
                    s_observerUpdate: "observerUpdate",
                    s_orientationchange: "orientationchange",
                    s_paginationHide: "paginationHide",
                    s_paginationRender: "paginationRender",
                    s_paginationShow: "paginationShow",
                    s_paginationUpdate: "paginationUpdate",
                    s_progress: "progress",
                    s_reachBeginning: "reachBeginning",
                    s_reachEnd: "reachEnd",
                    s_realIndexChange: "realIndexChange",
                    s_resize: "resize",
                    s_scroll: "scroll",
                    s_scrollbarDragEnd: "scrollbarDragEnd",
                    s_scrollbarDragMove: "scrollbarDragMove",
                    s_scrollbarDragStart: "scrollbarDragStart",
                    s_setTransition: "setTransition",
                    s_setTranslate: "setTranslate",
                    s_slideChange: "slideChange",
                    s_slideChangeTransitionEnd: "slideChangeTransitionEnd",
                    s_slideChangeTransitionStart: "slideChangeTransitionStart",
                    s_slideNextTransitionEnd: "slideNextTransitionEnd",
                    s_slideNextTransitionStart: "slideNextTransitionStart",
                    s_slidePrevTransitionEnd: "slidePrevTransitionEnd",
                    s_slidePrevTransitionStart: "slidePrevTransitionStart",
                    s_slideResetTransitionStart: "slideResetTransitionStart",
                    s_slideResetTransitionEnd: "slideResetTransitionEnd",
                    s_sliderMove: "sliderMove",
                    s_sliderFirstMove: "sliderFirstMove",
                    s_slidesLengthChange: "slidesLengthChange",
                    s_slidesGridLengthChange: "slidesGridLengthChange",
                    s_snapGridLengthChange: "snapGridLengthChange",
                    s_snapIndexChange: "snapIndexChange",
                    s_tap: "tap",
                    s_toEdge: "toEdge",
                    s_touchEnd: "touchEnd",
                    s_touchMove: "touchMove",
                    s_touchMoveOpposite: "touchMoveOpposite",
                    s_touchStart: "touchStart",
                    s_transitionEnd: "transitionEnd",
                    s_transitionStart: "transitionStart",
                    s_update: "update",
                    s_zoomChange: "zoomChange",
                    s_swiper: "swiper",
                    s_lock: "lock",
                    s_unlock: "unlock"
                },
                features: [r.TTD],
                ngContentSelectors: I,
                decls: 13,
                vars: 17,
                consts: [[4, "ngIf"], ["class", "swiper-scrollbar", 4, "ngIf"], ["class", "swiper-pagination", 4, "ngIf"], [3, "ngClass"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["slidesTemplate", ""], [1, "swiper-button-prev"], ["prevElRef", ""], [1, "swiper-button-next"], ["nextElRef", ""], [1, "swiper-scrollbar"], ["scrollbarElRef", ""], [1, "swiper-pagination"], ["paginationElRef", ""], [3, "ngClass", "style", "ngSwitch", 4, "ngFor", "ngForOf"], [3, "ngClass", "ngSwitch"], [3, "ngClass", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
                template: function (Ye, Mt) {
                    if (1 & Ye && (r.F$t(rt), r.Hsn(0), r.YNc(1, me, 5, 0, "ng-container", 0), r.YNc(2, ae, 2, 0, "div", 1), r.YNc(3, X, 2, 0, "div", 2), r.TgZ(4, "div", 3), r.Hsn(5, 1), r.YNc(6, H, 1, 0, null, 4), r.YNc(7, oe, 1, 0, null, 4), r.YNc(8, Ie, 1, 0, null, 4), r.Hsn(9, 2), r.qZA(), r.Hsn(10, 3), r.YNc(11, $e, 2, 3, "ng-template", null, 5, r.W1O)), 2 & Ye) {
                        const _t = r.MAs(12);
                        r.xp6(1), r.Q6J("ngIf", Mt.navigation && Mt.showNavigation), r.xp6(1), r.Q6J("ngIf", Mt.scrollbar && Mt.showScrollbar), r.xp6(1), r.Q6J("ngIf", Mt.pagination && Mt.showPagination), r.xp6(1), r.Q6J("ngClass", Mt.wrapperClass), r.uIk("id", Mt.id), r.xp6(2), r.Q6J("ngTemplateOutlet", _t)("ngTemplateOutletContext", r.VKq(11, Xe, Mt.prependSlides)), r.xp6(1), r.Q6J("ngTemplateOutlet", _t)("ngTemplateOutletContext", r.VKq(13, Ee, Mt.activeSlides)), r.xp6(1), r.Q6J("ngTemplateOutlet", _t)("ngTemplateOutletContext", r.VKq(15, ce, Mt.appendSlides))
                    }
                },
                directives: [D.O5, D.mk, D.tP, D.sg, D.RF, D.n9, D.ED],
                pipes: [D.Ov],
                styles: ["swiper{display:block}\n"],
                encapsulation: 2,
                changeDetection: 0
            }), Le
        })(), q = (() => {
            class Le {
            }

            return Le.\u0275fac = function (Ye) {
                return new (Ye || Le)
            }, Le.\u0275mod = r.oAB({type: Le}), Le.\u0275inj = r.cJS({imports: [[D.ez]]}), Le
        })()
    }, 6540: (Jt, lt, R) => {
        "use strict";

        function r(p) {
            return null !== p && "object" == typeof p && "constructor" in p && p.constructor === Object
        }

        function D(p = {}, s = {}) {
            Object.keys(s).forEach(_ => {
                void 0 === p[_] ? p[_] = s[_] : r(s[_]) && r(p[_]) && Object.keys(s[_]).length > 0 && D(p[_], s[_])
            })
        }

        R.d(lt, {eZ: () => jr, ZP: () => Gr});
        const ie = {
            body: {},
            addEventListener() {
            },
            removeEventListener() {
            },
            activeElement: {
                blur() {
                }, nodeName: ""
            },
            querySelector: () => null,
            querySelectorAll: () => [],
            getElementById: () => null,
            createEvent: () => ({
                initEvent() {
                }
            }),
            createElement: () => ({
                children: [], childNodes: [], style: {}, setAttribute() {
                }, getElementsByTagName: () => []
            }),
            createElementNS: () => ({}),
            importNode: () => null,
            location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""}
        };

        function te() {
            const p = "undefined" != typeof document ? document : {};
            return D(p, ie), p
        }

        const j = {
            document: ie,
            navigator: {userAgent: ""},
            location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""},
            history: {
                replaceState() {
                }, pushState() {
                }, go() {
                }, back() {
                }
            },
            CustomEvent: function () {
                return this
            },
            addEventListener() {
            },
            removeEventListener() {
            },
            getComputedStyle: () => ({getPropertyValue: () => ""}),
            Image() {
            },
            Date() {
            },
            screen: {},
            setTimeout() {
            },
            clearTimeout() {
            },
            matchMedia: () => ({}),
            requestAnimationFrame: p => "undefined" == typeof setTimeout ? (p(), null) : setTimeout(p, 0),
            cancelAnimationFrame(p) {
                "undefined" != typeof setTimeout && clearTimeout(p)
            }
        };

        function W() {
            const p = "undefined" != typeof window ? window : {};
            return D(p, j), p
        }

        class Ne extends Array {
            constructor(s) {
                "number" == typeof s ? super(s) : (super(...s || []), function Q(p) {
                    const s = p.__proto__;
                    Object.defineProperty(p, "__proto__", {
                        get: () => s, set(_) {
                            s.__proto__ = _
                        }
                    })
                }(this))
            }
        }

        function ve(p = []) {
            const s = [];
            return p.forEach(_ => {
                Array.isArray(_) ? s.push(...ve(_)) : s.push(_)
            }), s
        }

        function me(p, s) {
            return Array.prototype.filter.call(p, s)
        }

        function H(p, s) {
            const _ = W(), T = te();
            let fe = [];
            if (!s && p instanceof Ne) return p;
            if (!p) return new Ne(fe);
            if ("string" == typeof p) {
                const le = p.trim();
                if (le.indexOf("<") >= 0 && le.indexOf(">") >= 0) {
                    let De = "div";
                    0 === le.indexOf("<li") && (De = "ul"), 0 === le.indexOf("<tr") && (De = "tbody"), (0 === le.indexOf("<td") || 0 === le.indexOf("<th")) && (De = "tr"), 0 === le.indexOf("<tbody") && (De = "table"), 0 === le.indexOf("<option") && (De = "select");
                    const He = T.createElement(De);
                    He.innerHTML = le;
                    for (let Oe = 0; Oe < He.childNodes.length; Oe += 1) fe.push(He.childNodes[Oe])
                } else fe = function M(p, s) {
                    if ("string" != typeof p) return [p];
                    const _ = [], T = s.querySelectorAll(p);
                    for (let fe = 0; fe < T.length; fe += 1) _.push(T[fe]);
                    return _
                }(p.trim(), s || T)
            } else if (p.nodeType || p === _ || p === T) fe.push(p); else if (Array.isArray(p)) {
                if (p instanceof Ne) return p;
                fe = p
            }
            return new Ne(function ae(p) {
                const s = [];
                for (let _ = 0; _ < p.length; _ += 1) -1 === s.indexOf(p[_]) && s.push(p[_]);
                return s
            }(fe))
        }

        H.fn = Ne.prototype;
        const rn = "resize scroll".split(" ");

        function gn(p) {
            return function s(..._) {
                if (void 0 === _[0]) {
                    for (let T = 0; T < this.length; T += 1) rn.indexOf(p) < 0 && (p in this[T] ? this[T][p]() : H(this[T]).trigger(p));
                    return this
                }
                return this.on(p, ..._)
            }
        }

        gn("click"), gn("blur"), gn("focus"), gn("focusin"), gn("focusout"), gn("keyup"), gn("keydown"), gn("keypress"), gn("submit"), gn("change"), gn("mousedown"), gn("mousemove"), gn("mouseup"), gn("mouseenter"), gn("mouseleave"), gn("mouseout"), gn("mouseover"), gn("touchstart"), gn("touchend"), gn("touchmove"), gn("resize"), gn("scroll");
        const Mn = {
            addClass: function F(...p) {
                const s = ve(p.map(_ => _.split(" ")));
                return this.forEach(_ => {
                    _.classList.add(...s)
                }), this
            }, removeClass: function oe(...p) {
                const s = ve(p.map(_ => _.split(" ")));
                return this.forEach(_ => {
                    _.classList.remove(...s)
                }), this
            }, hasClass: function Ie(...p) {
                const s = ve(p.map(_ => _.split(" ")));
                return me(this, _ => s.filter(T => _.classList.contains(T)).length > 0).length > 0
            }, toggleClass: function ge(...p) {
                const s = ve(p.map(_ => _.split(" ")));
                this.forEach(_ => {
                    s.forEach(T => {
                        _.classList.toggle(T)
                    })
                })
            }, attr: function he(p, s) {
                if (1 === arguments.length && "string" == typeof p) return this[0] ? this[0].getAttribute(p) : void 0;
                for (let _ = 0; _ < this.length; _ += 1) if (2 === arguments.length) this[_].setAttribute(p, s); else for (const T in p) this[_][T] = p[T], this[_].setAttribute(T, p[T]);
                return this
            }, removeAttr: function xe(p) {
                for (let s = 0; s < this.length; s += 1) this[s].removeAttribute(p);
                return this
            }, transform: function Xe(p) {
                for (let s = 0; s < this.length; s += 1) this[s].style.transform = p;
                return this
            }, transition: function Ee(p) {
                for (let s = 0; s < this.length; s += 1) this[s].style.transitionDuration = "string" != typeof p ? `${p}ms` : p;
                return this
            }, on: function ce(...p) {
                let [s, _, T, fe] = p;

                function le(je) {
                    const ke = je.target;
                    if (!ke) return;
                    const Ae = je.target.dom7EventData || [];
                    if (Ae.indexOf(je) < 0 && Ae.unshift(je), H(ke).is(_)) T.apply(ke, Ae); else {
                        const we = H(ke).parents();
                        for (let nt = 0; nt < we.length; nt += 1) H(we[nt]).is(_) && T.apply(we[nt], Ae)
                    }
                }

                function De(je) {
                    const ke = je && je.target && je.target.dom7EventData || [];
                    ke.indexOf(je) < 0 && ke.unshift(je), T.apply(this, ke)
                }

                "function" == typeof p[1] && ([s, T, fe] = p, _ = void 0), fe || (fe = !1);
                const He = s.split(" ");
                let Oe;
                for (let je = 0; je < this.length; je += 1) {
                    const ke = this[je];
                    if (_) for (Oe = 0; Oe < He.length; Oe += 1) {
                        const Ae = He[Oe];
                        ke.dom7LiveListeners || (ke.dom7LiveListeners = {}), ke.dom7LiveListeners[Ae] || (ke.dom7LiveListeners[Ae] = []), ke.dom7LiveListeners[Ae].push({
                            listener: T,
                            proxyListener: le
                        }), ke.addEventListener(Ae, le, fe)
                    } else for (Oe = 0; Oe < He.length; Oe += 1) {
                        const Ae = He[Oe];
                        ke.dom7Listeners || (ke.dom7Listeners = {}), ke.dom7Listeners[Ae] || (ke.dom7Listeners[Ae] = []), ke.dom7Listeners[Ae].push({
                            listener: T,
                            proxyListener: De
                        }), ke.addEventListener(Ae, De, fe)
                    }
                }
                return this
            }, off: function I(...p) {
                let [s, _, T, fe] = p;
                "function" == typeof p[1] && ([s, T, fe] = p, _ = void 0), fe || (fe = !1);
                const le = s.split(" ");
                for (let De = 0; De < le.length; De += 1) {
                    const He = le[De];
                    for (let Oe = 0; Oe < this.length; Oe += 1) {
                        const je = this[Oe];
                        let ke;
                        if (!_ && je.dom7Listeners ? ke = je.dom7Listeners[He] : _ && je.dom7LiveListeners && (ke = je.dom7LiveListeners[He]), ke && ke.length) for (let Ae = ke.length - 1; Ae >= 0; Ae -= 1) {
                            const we = ke[Ae];
                            T && we.listener === T || T && we.listener && we.listener.dom7proxy && we.listener.dom7proxy === T ? (je.removeEventListener(He, we.proxyListener, fe), ke.splice(Ae, 1)) : T || (je.removeEventListener(He, we.proxyListener, fe), ke.splice(Ae, 1))
                        }
                    }
                }
                return this
            }, trigger: function f(...p) {
                const s = W(), _ = p[0].split(" "), T = p[1];
                for (let fe = 0; fe < _.length; fe += 1) {
                    const le = _[fe];
                    for (let De = 0; De < this.length; De += 1) {
                        const He = this[De];
                        if (s.CustomEvent) {
                            const Oe = new s.CustomEvent(le, {detail: T, bubbles: !0, cancelable: !0});
                            He.dom7EventData = p.filter((je, ke) => ke > 0), He.dispatchEvent(Oe), He.dom7EventData = [], delete He.dom7EventData
                        }
                    }
                }
                return this
            }, transitionEnd: function g(p) {
                const s = this;
                return p && s.on("transitionend", function _(T) {
                    T.target === this && (p.call(this, T), s.off("transitionend", _))
                }), this
            }, outerWidth: function P(p) {
                if (this.length > 0) {
                    if (p) {
                        const s = this.styles();
                        return this[0].offsetWidth + parseFloat(s.getPropertyValue("margin-right")) + parseFloat(s.getPropertyValue("margin-left"))
                    }
                    return this[0].offsetWidth
                }
                return null
            }, outerHeight: function O(p) {
                if (this.length > 0) {
                    if (p) {
                        const s = this.styles();
                        return this[0].offsetHeight + parseFloat(s.getPropertyValue("margin-top")) + parseFloat(s.getPropertyValue("margin-bottom"))
                    }
                    return this[0].offsetHeight
                }
                return null
            }, styles: function Je() {
                const p = W();
                return this[0] ? p.getComputedStyle(this[0], null) : {}
            }, offset: function E() {
                if (this.length > 0) {
                    const p = W(), s = te(), _ = this[0], T = _.getBoundingClientRect(), fe = s.body;
                    return {
                        top: T.top + (_ === p ? p.scrollY : _.scrollTop) - (_.clientTop || fe.clientTop || 0),
                        left: T.left + (_ === p ? p.scrollX : _.scrollLeft) - (_.clientLeft || fe.clientLeft || 0)
                    }
                }
                return null
            }, css: function q(p, s) {
                const _ = W();
                let T;
                if (1 === arguments.length) {
                    if ("string" != typeof p) {
                        for (T = 0; T < this.length; T += 1) for (const fe in p) this[T].style[fe] = p[fe];
                        return this
                    }
                    if (this[0]) return _.getComputedStyle(this[0], null).getPropertyValue(p)
                }
                if (2 === arguments.length && "string" == typeof p) {
                    for (T = 0; T < this.length; T += 1) this[T].style[p] = s;
                    return this
                }
                return this
            }, each: function Le(p) {
                return p ? (this.forEach((s, _) => {
                    p.apply(s, [s, _])
                }), this) : this
            }, html: function Ye(p) {
                if (void 0 === p) return this[0] ? this[0].innerHTML : null;
                for (let s = 0; s < this.length; s += 1) this[s].innerHTML = p;
                return this
            }, text: function Mt(p) {
                if (void 0 === p) return this[0] ? this[0].textContent.trim() : null;
                for (let s = 0; s < this.length; s += 1) this[s].textContent = p;
                return this
            }, is: function _t(p) {
                const s = W(), _ = te(), T = this[0];
                let fe, le;
                if (!T || void 0 === p) return !1;
                if ("string" == typeof p) {
                    if (T.matches) return T.matches(p);
                    if (T.webkitMatchesSelector) return T.webkitMatchesSelector(p);
                    if (T.msMatchesSelector) return T.msMatchesSelector(p);
                    for (fe = H(p), le = 0; le < fe.length; le += 1) if (fe[le] === T) return !0;
                    return !1
                }
                if (p === _) return T === _;
                if (p === s) return T === s;
                if (p.nodeType || p instanceof Ne) {
                    for (fe = p.nodeType ? [p] : p, le = 0; le < fe.length; le += 1) if (fe[le] === T) return !0;
                    return !1
                }
                return !1
            }, index: function Pt() {
                let s, p = this[0];
                if (p) {
                    for (s = 0; null !== (p = p.previousSibling);) 1 === p.nodeType && (s += 1);
                    return s
                }
            }, eq: function Gt(p) {
                if (void 0 === p) return this;
                const s = this.length;
                if (p > s - 1) return H([]);
                if (p < 0) {
                    const _ = s + p;
                    return H(_ < 0 ? [] : [this[_]])
                }
                return H([this[p]])
            }, append: function yn(...p) {
                let s;
                const _ = te();
                for (let T = 0; T < p.length; T += 1) {
                    s = p[T];
                    for (let fe = 0; fe < this.length; fe += 1) if ("string" == typeof s) {
                        const le = _.createElement("div");
                        for (le.innerHTML = s; le.firstChild;) this[fe].appendChild(le.firstChild)
                    } else if (s instanceof Ne) for (let le = 0; le < s.length; le += 1) this[fe].appendChild(s[le]); else this[fe].appendChild(s)
                }
                return this
            }, prepend: function xn(p) {
                const s = te();
                let _, T;
                for (_ = 0; _ < this.length; _ += 1) if ("string" == typeof p) {
                    const fe = s.createElement("div");
                    for (fe.innerHTML = p, T = fe.childNodes.length - 1; T >= 0; T -= 1) this[_].insertBefore(fe.childNodes[T], this[_].childNodes[0])
                } else if (p instanceof Ne) for (T = 0; T < p.length; T += 1) this[_].insertBefore(p[T], this[_].childNodes[0]); else this[_].insertBefore(p, this[_].childNodes[0]);
                return this
            }, next: function On(p) {
                return this.length > 0 ? p ? this[0].nextElementSibling && H(this[0].nextElementSibling).is(p) ? H([this[0].nextElementSibling]) : H([]) : H(this[0].nextElementSibling ? [this[0].nextElementSibling] : []) : H([])
            }, nextAll: function Me(p) {
                const s = [];
                let _ = this[0];
                if (!_) return H([]);
                for (; _.nextElementSibling;) {
                    const T = _.nextElementSibling;
                    p ? H(T).is(p) && s.push(T) : s.push(T), _ = T
                }
                return H(s)
            }, prev: function ne(p) {
                if (this.length > 0) {
                    const s = this[0];
                    return p ? s.previousElementSibling && H(s.previousElementSibling).is(p) ? H([s.previousElementSibling]) : H([]) : H(s.previousElementSibling ? [s.previousElementSibling] : [])
                }
                return H([])
            }, prevAll: function U(p) {
                const s = [];
                let _ = this[0];
                if (!_) return H([]);
                for (; _.previousElementSibling;) {
                    const T = _.previousElementSibling;
                    p ? H(T).is(p) && s.push(T) : s.push(T), _ = T
                }
                return H(s)
            }, parent: function Ze(p) {
                const s = [];
                for (let _ = 0; _ < this.length; _ += 1) null !== this[_].parentNode && (p ? H(this[_].parentNode).is(p) && s.push(this[_].parentNode) : s.push(this[_].parentNode));
                return H(s)
            }, parents: function Ge(p) {
                const s = [];
                for (let _ = 0; _ < this.length; _ += 1) {
                    let T = this[_].parentNode;
                    for (; T;) p ? H(T).is(p) && s.push(T) : s.push(T), T = T.parentNode
                }
                return H(s)
            }, closest: function ye(p) {
                let s = this;
                return void 0 === p ? H([]) : (s.is(p) || (s = s.parents(p).eq(0)), s)
            }, find: function Te(p) {
                const s = [];
                for (let _ = 0; _ < this.length; _ += 1) {
                    const T = this[_].querySelectorAll(p);
                    for (let fe = 0; fe < T.length; fe += 1) s.push(T[fe])
                }
                return H(s)
            }, children: function Be(p) {
                const s = [];
                for (let _ = 0; _ < this.length; _ += 1) {
                    const T = this[_].children;
                    for (let fe = 0; fe < T.length; fe += 1) (!p || H(T[fe]).is(p)) && s.push(T[fe])
                }
                return H(s)
            }, filter: function ut(p) {
                return H(me(this, p))
            }, remove: function tt() {
                for (let p = 0; p < this.length; p += 1) this[p].parentNode && this[p].parentNode.removeChild(this[p]);
                return this
            }
        };
        Object.keys(Mn).forEach(p => {
            Object.defineProperty(H.fn, p, {value: Mn[p], writable: !0})
        });
        const an = H;

        function Sn(p, s) {
            return void 0 === s && (s = 0), setTimeout(p, s)
        }

        function ar() {
            return Date.now()
        }

        function _n(p) {
            return "object" == typeof p && null !== p && p.constructor && "Object" === Object.prototype.toString.call(p).slice(8, -1)
        }

        function tr(p) {
            return "undefined" != typeof window && void 0 !== window.HTMLElement ? p instanceof HTMLElement : p && (1 === p.nodeType || 11 === p.nodeType)
        }

        function nr() {
            const p = Object(arguments.length <= 0 ? void 0 : arguments[0]),
                s = ["__proto__", "constructor", "prototype"];
            for (let _ = 1; _ < arguments.length; _ += 1) {
                const T = _ < 0 || arguments.length <= _ ? void 0 : arguments[_];
                if (null != T && !tr(T)) {
                    const fe = Object.keys(Object(T)).filter(le => s.indexOf(le) < 0);
                    for (let le = 0, De = fe.length; le < De; le += 1) {
                        const He = fe[le], Oe = Object.getOwnPropertyDescriptor(T, He);
                        void 0 !== Oe && Oe.enumerable && (_n(p[He]) && _n(T[He]) ? T[He].__swiper__ ? p[He] = T[He] : nr(p[He], T[He]) : !_n(p[He]) && _n(T[He]) ? (p[He] = {}, T[He].__swiper__ ? p[He] = T[He] : nr(p[He], T[He])) : p[He] = T[He])
                    }
                }
            }
            return p
        }

        function Er(p, s, _) {
            p.style.setProperty(s, _)
        }

        function gr(p) {
            let {swiper: s, targetPosition: _, side: T} = p;
            const fe = W(), le = -s.translate;
            let He, De = null;
            const Oe = s.params.speed;
            s.wrapperEl.style.scrollSnapType = "none", fe.cancelAnimationFrame(s.cssModeFrameID);
            const je = _ > le ? "next" : "prev",
                ke = (we, nt) => "next" === je && we >= nt || "prev" === je && we <= nt, Ae = () => {
                    He = (new Date).getTime(), null === De && (De = He);
                    const we = Math.max(Math.min((He - De) / Oe, 1), 0), nt = .5 - Math.cos(we * Math.PI) / 2;
                    let pt = le + nt * (_ - le);
                    if (ke(pt, _) && (pt = _), s.wrapperEl.scrollTo({[T]: pt}), ke(pt, _)) return s.wrapperEl.style.overflow = "hidden", s.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                        s.wrapperEl.style.overflow = "", s.wrapperEl.scrollTo({[T]: pt})
                    }), void fe.cancelAnimationFrame(s.cssModeFrameID);
                    s.cssModeFrameID = fe.requestAnimationFrame(Ae)
                };
            Ae()
        }

        let Ir, Vn, _r;

        function br() {
            return Ir || (Ir = function rr() {
                const p = W(), s = te();
                return {
                    smoothScroll: s.documentElement && "scrollBehavior" in s.documentElement.style,
                    touch: !!("ontouchstart" in p || p.DocumentTouch && s instanceof p.DocumentTouch),
                    passiveListener: function () {
                        let T = !1;
                        try {
                            const fe = Object.defineProperty({}, "passive", {
                                get() {
                                    T = !0
                                }
                            });
                            p.addEventListener("testPassiveListener", null, fe)
                        } catch (fe) {
                        }
                        return T
                    }(),
                    gestures: "ongesturestart" in p
                }
            }()), Ir
        }

        function Pi(p) {
            let {swiper: s, runCallbacks: _, direction: T, step: fe} = p;
            const {activeIndex: le, previousIndex: De} = s;
            let He = T;
            if (He || (He = le > De ? "next" : le < De ? "prev" : "reset"), s.emit(`transition${fe}`), _ && le !== De) {
                if ("reset" === He) return void s.emit(`slideResetTransition${fe}`);
                s.emit(`slideChangeTransition${fe}`), s.emit("next" === He ? `slideNextTransition${fe}` : `slidePrevTransition${fe}`)
            }
        }

        function vi(p) {
            const s = this, _ = te(), T = W(), fe = s.touchEventsData, {params: le, touches: De, enabled: He} = s;
            if (!He || s.animating && le.preventInteractionOnTransition) return;
            !s.animating && le.cssMode && le.loop && s.loopFix();
            let Oe = p;
            Oe.originalEvent && (Oe = Oe.originalEvent);
            let je = an(Oe.target);
            if ("wrapper" === le.touchEventsTarget && !je.closest(s.wrapperEl).length || (fe.isTouchEvent = "touchstart" === Oe.type, !fe.isTouchEvent && "which" in Oe && 3 === Oe.which) || !fe.isTouchEvent && "button" in Oe && Oe.button > 0 || fe.isTouched && fe.isMoved) return;
            le.noSwipingClass && "" !== le.noSwipingClass && Oe.target && Oe.target.shadowRoot && p.path && p.path[0] && (je = an(p.path[0]));
            const Ae = le.noSwipingSelector ? le.noSwipingSelector : `.${le.noSwipingClass}`;
            if (le.noSwiping && (Oe.target && Oe.target.shadowRoot ? function si(p, s) {
                return void 0 === s && (s = this), function _(T) {
                    if (!T || T === te() || T === W()) return null;
                    T.assignedSlot && (T = T.assignedSlot);
                    const fe = T.closest(p);
                    return fe || T.getRootNode ? fe || _(T.getRootNode().host) : null
                }(s)
            }(Ae, je[0]) : je.closest(Ae)[0])) return void (s.allowClick = !0);
            if (le.swipeHandler && !je.closest(le.swipeHandler)[0]) return;
            De.currentX = "touchstart" === Oe.type ? Oe.targetTouches[0].pageX : Oe.pageX, De.currentY = "touchstart" === Oe.type ? Oe.targetTouches[0].pageY : Oe.pageY;
            const nt = De.currentX, pt = De.currentY, Tt = le.edgeSwipeDetection || le.iOSEdgeSwipeDetection,
                qe = le.edgeSwipeThreshold || le.iOSEdgeSwipeThreshold;
            if (Tt && (nt <= qe || nt >= T.innerWidth - qe)) {
                if ("prevent" !== Tt) return;
                p.preventDefault()
            }
            if (Object.assign(fe, {
                isTouched: !0,
                isMoved: !1,
                allowTouchCallbacks: !0,
                isScrolling: void 0,
                startMoving: void 0
            }), De.startX = nt, De.startY = pt, fe.touchStartTime = ar(), s.allowClick = !0, s.updateSize(), s.swipeDirection = void 0, le.threshold > 0 && (fe.allowThresholdMove = !1), "touchstart" !== Oe.type) {
                let ot = !0;
                je.is(fe.focusableElements) && (ot = !1, "SELECT" === je[0].nodeName && (fe.isTouched = !1)), _.activeElement && an(_.activeElement).is(fe.focusableElements) && _.activeElement !== je[0] && _.activeElement.blur();
                const Nt = ot && s.allowTouchMove && le.touchStartPreventDefault;
                (le.touchStartForcePreventDefault || Nt) && !je[0].isContentEditable && Oe.preventDefault()
            }
            s.params.freeMode && s.params.freeMode.enabled && s.freeMode && s.animating && !le.cssMode && s.freeMode.onTouchStart(), s.emit("touchStart", Oe)
        }

        function Di(p) {
            const s = te(), _ = this, T = _.touchEventsData, {
                params: fe,
                touches: le,
                rtlTranslate: De,
                enabled: He
            } = _;
            if (!He) return;
            let Oe = p;
            if (Oe.originalEvent && (Oe = Oe.originalEvent), !T.isTouched) return void (T.startMoving && T.isScrolling && _.emit("touchMoveOpposite", Oe));
            if (T.isTouchEvent && "touchmove" !== Oe.type) return;
            const je = "touchmove" === Oe.type && Oe.targetTouches && (Oe.targetTouches[0] || Oe.changedTouches[0]),
                ke = "touchmove" === Oe.type ? je.pageX : Oe.pageX, Ae = "touchmove" === Oe.type ? je.pageY : Oe.pageY;
            if (Oe.preventedByNestedSwiper) return le.startX = ke, void (le.startY = Ae);
            if (!_.allowTouchMove) return an(Oe.target).is(T.focusableElements) || (_.allowClick = !1), void (T.isTouched && (Object.assign(le, {
                startX: ke,
                startY: Ae,
                currentX: ke,
                currentY: Ae
            }), T.touchStartTime = ar()));
            if (T.isTouchEvent && fe.touchReleaseOnEdges && !fe.loop) if (_.isVertical()) {
                if (Ae < le.startY && _.translate <= _.maxTranslate() || Ae > le.startY && _.translate >= _.minTranslate()) return T.isTouched = !1, void (T.isMoved = !1)
            } else if (ke < le.startX && _.translate <= _.maxTranslate() || ke > le.startX && _.translate >= _.minTranslate()) return;
            if (T.isTouchEvent && s.activeElement && Oe.target === s.activeElement && an(Oe.target).is(T.focusableElements)) return T.isMoved = !0, void (_.allowClick = !1);
            if (T.allowTouchCallbacks && _.emit("touchMove", Oe), Oe.targetTouches && Oe.targetTouches.length > 1) return;
            le.currentX = ke, le.currentY = Ae;
            const we = le.currentX - le.startX, nt = le.currentY - le.startY;
            if (_.params.threshold && Math.sqrt(Bi(we, 2) + Bi(nt, 2)) < _.params.threshold) return;
            if (void 0 === T.isScrolling) {
                let ot;
                _.isHorizontal() && le.currentY === le.startY || _.isVertical() && le.currentX === le.startX ? T.isScrolling = !1 : we * we + nt * nt >= 25 && (ot = 180 * Math.atan2(Math.abs(nt), Math.abs(we)) / Math.PI, T.isScrolling = _.isHorizontal() ? ot > fe.touchAngle : 90 - ot > fe.touchAngle)
            }
            if (T.isScrolling && _.emit("touchMoveOpposite", Oe), void 0 === T.startMoving && (le.currentX !== le.startX || le.currentY !== le.startY) && (T.startMoving = !0), T.isScrolling) return void (T.isTouched = !1);
            if (!T.startMoving) return;
            _.allowClick = !1, !fe.cssMode && Oe.cancelable && Oe.preventDefault(), fe.touchMoveStopPropagation && !fe.nested && Oe.stopPropagation(), T.isMoved || (fe.loop && !fe.cssMode && _.loopFix(), T.startTranslate = _.getTranslate(), _.setTransition(0), _.animating && _.$wrapperEl.trigger("webkitTransitionEnd transitionend"), T.allowMomentumBounce = !1, fe.grabCursor && (!0 === _.allowSlideNext || !0 === _.allowSlidePrev) && _.setGrabCursor(!0), _.emit("sliderFirstMove", Oe)), _.emit("sliderMove", Oe), T.isMoved = !0;
            let pt = _.isHorizontal() ? we : nt;
            le.diff = pt, pt *= fe.touchRatio, De && (pt = -pt), _.swipeDirection = pt > 0 ? "prev" : "next", T.currentTranslate = pt + T.startTranslate;
            let Tt = !0, qe = fe.resistanceRatio;
            if (fe.touchReleaseOnEdges && (qe = 0), pt > 0 && T.currentTranslate > _.minTranslate() ? (Tt = !1, fe.resistance && (T.currentTranslate = _.minTranslate() - 1 + Bi(-_.minTranslate() + T.startTranslate + pt, qe))) : pt < 0 && T.currentTranslate < _.maxTranslate() && (Tt = !1, fe.resistance && (T.currentTranslate = _.maxTranslate() + 1 - Bi(_.maxTranslate() - T.startTranslate - pt, qe))), Tt && (Oe.preventedByNestedSwiper = !0), !_.allowSlideNext && "next" === _.swipeDirection && T.currentTranslate < T.startTranslate && (T.currentTranslate = T.startTranslate), !_.allowSlidePrev && "prev" === _.swipeDirection && T.currentTranslate > T.startTranslate && (T.currentTranslate = T.startTranslate), !_.allowSlidePrev && !_.allowSlideNext && (T.currentTranslate = T.startTranslate), fe.threshold > 0) {
                if (!(Math.abs(pt) > fe.threshold || T.allowThresholdMove)) return void (T.currentTranslate = T.startTranslate);
                if (!T.allowThresholdMove) return T.allowThresholdMove = !0, le.startX = le.currentX, le.startY = le.currentY, T.currentTranslate = T.startTranslate, void (le.diff = _.isHorizontal() ? le.currentX - le.startX : le.currentY - le.startY)
            }
            !fe.followFinger || fe.cssMode || ((fe.freeMode && fe.freeMode.enabled && _.freeMode || fe.watchSlidesProgress) && (_.updateActiveIndex(), _.updateSlidesClasses()), _.params.freeMode && fe.freeMode.enabled && _.freeMode && _.freeMode.onTouchMove(), _.updateProgress(T.currentTranslate), _.setTranslate(T.currentTranslate))
        }

        function ni(p) {
            const s = this, _ = s.touchEventsData, {
                params: T,
                touches: fe,
                rtlTranslate: le,
                slidesGrid: De,
                enabled: He
            } = s;
            if (!He) return;
            let Oe = p;
            if (Oe.originalEvent && (Oe = Oe.originalEvent), _.allowTouchCallbacks && s.emit("touchEnd", Oe), _.allowTouchCallbacks = !1, !_.isTouched) return _.isMoved && T.grabCursor && s.setGrabCursor(!1), _.isMoved = !1, void (_.startMoving = !1);
            T.grabCursor && _.isMoved && _.isTouched && (!0 === s.allowSlideNext || !0 === s.allowSlidePrev) && s.setGrabCursor(!1);
            const je = ar(), ke = je - _.touchStartTime;
            if (s.allowClick) {
                const Nt = Oe.path || Oe.composedPath && Oe.composedPath();
                s.updateClickedSlide(Nt && Nt[0] || Oe.target), s.emit("tap click", Oe), ke < 300 && je - _.lastClickTime < 300 && s.emit("doubleTap doubleClick", Oe)
            }
            if (_.lastClickTime = ar(), Sn(() => {
                s.destroyed || (s.allowClick = !0)
            }), !_.isTouched || !_.isMoved || !s.swipeDirection || 0 === fe.diff || _.currentTranslate === _.startTranslate) return _.isTouched = !1, _.isMoved = !1, void (_.startMoving = !1);
            let Ae;
            if (_.isTouched = !1, _.isMoved = !1, _.startMoving = !1, Ae = T.followFinger ? le ? s.translate : -s.translate : -_.currentTranslate, T.cssMode) return;
            if (s.params.freeMode && T.freeMode.enabled) return void s.freeMode.onTouchEnd({currentPos: Ae});
            let we = 0, nt = s.slidesSizesGrid[0];
            for (let Nt = 0; Nt < De.length; Nt += Nt < T.slidesPerGroupSkip ? 1 : T.slidesPerGroup) {
                const bt = Nt < T.slidesPerGroupSkip - 1 ? 1 : T.slidesPerGroup;
                void 0 !== De[Nt + bt] ? Ae >= De[Nt] && Ae < De[Nt + bt] && (we = Nt, nt = De[Nt + bt] - De[Nt]) : Ae >= De[Nt] && (we = Nt, nt = De[De.length - 1] - De[De.length - 2])
            }
            let pt = null, Tt = null;
            T.rewind && (s.isBeginning ? Tt = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1 : s.isEnd && (pt = 0));
            const qe = (Ae - De[we]) / nt, ot = we < T.slidesPerGroupSkip - 1 ? 1 : T.slidesPerGroup;
            if (ke > T.longSwipesMs) {
                if (!T.longSwipes) return void s.slideTo(s.activeIndex);
                "next" === s.swipeDirection && s.slideTo(qe >= T.longSwipesRatio ? T.rewind && s.isEnd ? pt : we + ot : we), "prev" === s.swipeDirection && (qe > 1 - T.longSwipesRatio ? s.slideTo(we + ot) : null !== Tt && qe < 0 && Math.abs(qe) > T.longSwipesRatio ? s.slideTo(Tt) : s.slideTo(we))
            } else {
                if (!T.shortSwipes) return void s.slideTo(s.activeIndex);
                !s.navigation || Oe.target !== s.navigation.nextEl && Oe.target !== s.navigation.prevEl ? ("next" === s.swipeDirection && s.slideTo(null !== pt ? pt : we + ot), "prev" === s.swipeDirection && s.slideTo(null !== Tt ? Tt : we)) : s.slideTo(Oe.target === s.navigation.nextEl ? we + ot : we)
            }
        }

        function oi() {
            const p = this, {params: s, el: _} = p;
            if (_ && 0 === _.offsetWidth) return;
            s.breakpoints && p.setBreakpoint();
            const {allowSlideNext: T, allowSlidePrev: fe, snapGrid: le} = p;
            p.allowSlideNext = !0, p.allowSlidePrev = !0, p.updateSize(), p.updateSlides(), p.updateSlidesClasses(), p.slideTo(("auto" === s.slidesPerView || s.slidesPerView > 1) && p.isEnd && !p.isBeginning && !p.params.centeredSlides ? p.slides.length - 1 : p.activeIndex, 0, !1, !0), p.autoplay && p.autoplay.running && p.autoplay.paused && p.autoplay.run(), p.allowSlidePrev = fe, p.allowSlideNext = T, p.params.watchOverflow && le !== p.snapGrid && p.checkOverflow()
        }

        function Ei(p) {
            const s = this;
            !s.enabled || s.allowClick || (s.params.preventClicks && p.preventDefault(), s.params.preventClicksPropagation && s.animating && (p.stopPropagation(), p.stopImmediatePropagation()))
        }

        function ai() {
            const p = this, {wrapperEl: s, rtlTranslate: _, enabled: T} = p;
            if (!T) return;
            let fe;
            p.previousTranslate = p.translate, p.translate = p.isHorizontal() ? -s.scrollLeft : -s.scrollTop, 0 === p.translate && (p.translate = 0), p.updateActiveIndex(), p.updateSlidesClasses();
            const le = p.maxTranslate() - p.minTranslate();
            fe = 0 === le ? 0 : (p.translate - p.minTranslate()) / le, fe !== p.progress && p.updateProgress(_ ? -p.translate : p.translate), p.emit("setTranslate", p.translate, !1)
        }

        let ri = !1;

        function zr() {
        }

        const Wr = (p, s) => {
            const _ = te(), {params: T, touchEvents: fe, el: le, wrapperEl: De, device: He, support: Oe} = p,
                je = !!T.nested, ke = "on" === s ? "addEventListener" : "removeEventListener", Ae = s;
            if (Oe.touch) {
                const we = !("touchstart" !== fe.start || !Oe.passiveListener || !T.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
                le[ke](fe.start, p.onTouchStart, we), le[ke](fe.move, p.onTouchMove, Oe.passiveListener ? {
                    passive: !1,
                    capture: je
                } : je), le[ke](fe.end, p.onTouchEnd, we), fe.cancel && le[ke](fe.cancel, p.onTouchEnd, we)
            } else le[ke](fe.start, p.onTouchStart, !1), _[ke](fe.move, p.onTouchMove, je), _[ke](fe.end, p.onTouchEnd, !1);
            (T.preventClicks || T.preventClicksPropagation) && le[ke]("click", p.onClick, !0), T.cssMode && De[ke]("scroll", p.onScroll), p[Ae](T.updateOnWindowResize ? He.ios || He.android ? "resize orientationchange observerUpdate" : "resize observerUpdate" : "observerUpdate", oi, !0)
        }, _i = (p, s) => p.grid && s.grid && s.grid.rows > 1, Tr = {
            init: !0,
            direction: "horizontal",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !0,
            nested: !1,
            createElements: !1,
            enabled: !0,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: !1,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !0,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 0,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: .85,
            watchSlidesProgress: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopedSlidesLimit: !0,
            loopFillGroupWithBlank: !1,
            loopPreventsSlide: !0,
            rewind: !1,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: !0,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };

        function yr(p, s) {
            return function (T) {
                void 0 === T && (T = {});
                const fe = Object.keys(T)[0], le = T[fe];
                "object" == typeof le && null !== le ? (["navigation", "pagination", "scrollbar"].indexOf(fe) >= 0 && !0 === p[fe] && (p[fe] = {auto: !0}), fe in p && "enabled" in le ? (!0 === p[fe] && (p[fe] = {enabled: !0}), "object" == typeof p[fe] && !("enabled" in p[fe]) && (p[fe].enabled = !0), p[fe] || (p[fe] = {enabled: !1}), nr(s, T)) : nr(s, T)) : nr(s, T)
            }
        }

        const Ar = {
            eventsEmitter: {
                on(p, s, _) {
                    const T = this;
                    if (!T.eventsListeners || T.destroyed || "function" != typeof s) return T;
                    const fe = _ ? "unshift" : "push";
                    return p.split(" ").forEach(le => {
                        T.eventsListeners[le] || (T.eventsListeners[le] = []), T.eventsListeners[le][fe](s)
                    }), T
                }, once(p, s, _) {
                    const T = this;
                    if (!T.eventsListeners || T.destroyed || "function" != typeof s) return T;

                    function fe() {
                        T.off(p, fe), fe.__emitterProxy && delete fe.__emitterProxy;
                        for (var le = arguments.length, De = new Array(le), He = 0; He < le; He++) De[He] = arguments[He];
                        s.apply(T, De)
                    }

                    return fe.__emitterProxy = s, T.on(p, fe, _)
                }, onAny(p, s) {
                    const _ = this;
                    if (!_.eventsListeners || _.destroyed || "function" != typeof p) return _;
                    const T = s ? "unshift" : "push";
                    return _.eventsAnyListeners.indexOf(p) < 0 && _.eventsAnyListeners[T](p), _
                }, offAny(p) {
                    const s = this;
                    if (!s.eventsListeners || s.destroyed || !s.eventsAnyListeners) return s;
                    const _ = s.eventsAnyListeners.indexOf(p);
                    return _ >= 0 && s.eventsAnyListeners.splice(_, 1), s
                }, off(p, s) {
                    const _ = this;
                    return !_.eventsListeners || _.destroyed || !_.eventsListeners || p.split(" ").forEach(T => {
                        void 0 === s ? _.eventsListeners[T] = [] : _.eventsListeners[T] && _.eventsListeners[T].forEach((fe, le) => {
                            (fe === s || fe.__emitterProxy && fe.__emitterProxy === s) && _.eventsListeners[T].splice(le, 1)
                        })
                    }), _
                }, emit() {
                    const p = this;
                    if (!p.eventsListeners || p.destroyed || !p.eventsListeners) return p;
                    let s, _, T;
                    for (var fe = arguments.length, le = new Array(fe), De = 0; De < fe; De++) le[De] = arguments[De];
                    return "string" == typeof le[0] || Array.isArray(le[0]) ? (s = le[0], _ = le.slice(1, le.length), T = p) : (s = le[0].events, _ = le[0].data, T = le[0].context || p), _.unshift(T), (Array.isArray(s) ? s : s.split(" ")).forEach(Oe => {
                        p.eventsAnyListeners && p.eventsAnyListeners.length && p.eventsAnyListeners.forEach(je => {
                            je.apply(T, [Oe, ..._])
                        }), p.eventsListeners && p.eventsListeners[Oe] && p.eventsListeners[Oe].forEach(je => {
                            je.apply(T, _)
                        })
                    }), p
                }
            }, update: {
                updateSize: function at() {
                    const p = this;
                    let s, _;
                    const T = p.$el;
                    s = null != p.params.width ? p.params.width : T[0].clientWidth, _ = null != p.params.height ? p.params.height : T[0].clientHeight, !(0 === s && p.isHorizontal() || 0 === _ && p.isVertical()) && (s = s - parseInt(T.css("padding-left") || 0, 10) - parseInt(T.css("padding-right") || 0, 10), _ = _ - parseInt(T.css("padding-top") || 0, 10) - parseInt(T.css("padding-bottom") || 0, 10), Number.isNaN(s) && (s = 0), Number.isNaN(_) && (_ = 0), Object.assign(p, {
                        width: s,
                        height: _,
                        size: p.isHorizontal() ? s : _
                    }))
                }, updateSlides: function Ct() {
                    const p = this;

                    function s(u) {
                        return p.isHorizontal() ? u : {
                            width: "height",
                            "margin-top": "margin-left",
                            "margin-bottom ": "margin-right",
                            "margin-left": "margin-top",
                            "margin-right": "margin-bottom",
                            "padding-left": "padding-top",
                            "padding-right": "padding-bottom",
                            marginRight: "marginBottom"
                        }[u]
                    }

                    function _(u, d) {
                        return parseFloat(u.getPropertyValue(s(d)) || 0)
                    }

                    const T = p.params, {$wrapperEl: fe, size: le, rtlTranslate: De, wrongRTL: He} = p,
                        Oe = p.virtual && T.virtual.enabled, je = Oe ? p.virtual.slides.length : p.slides.length,
                        ke = fe.children(`.${p.params.slideClass}`), Ae = Oe ? p.virtual.slides.length : ke.length;
                    let we = [];
                    const nt = [], pt = [];
                    let Tt = T.slidesOffsetBefore;
                    "function" == typeof Tt && (Tt = T.slidesOffsetBefore.call(p));
                    let qe = T.slidesOffsetAfter;
                    "function" == typeof qe && (qe = T.slidesOffsetAfter.call(p));
                    const ot = p.snapGrid.length, Nt = p.slidesGrid.length;
                    let bt = T.spaceBetween, Rt = -Tt, An = 0, on = 0;
                    if (void 0 === le) return;
                    "string" == typeof bt && bt.indexOf("%") >= 0 && (bt = parseFloat(bt.replace("%", "")) / 100 * le), p.virtualSize = -bt, ke.css(De ? {
                        marginLeft: "",
                        marginBottom: "",
                        marginTop: ""
                    } : {
                        marginRight: "",
                        marginBottom: "",
                        marginTop: ""
                    }), T.centeredSlides && T.cssMode && (Er(p.wrapperEl, "--swiper-centered-offset-before", ""), Er(p.wrapperEl, "--swiper-centered-offset-after", ""));
                    const Cn = T.grid && T.grid.rows > 1 && p.grid;
                    let N;
                    Cn && p.grid.initSlides(Ae);
                    const o = "auto" === T.slidesPerView && T.breakpoints && Object.keys(T.breakpoints).filter(u => void 0 !== T.breakpoints[u].slidesPerView).length > 0;
                    for (let u = 0; u < Ae; u += 1) {
                        N = 0;
                        const d = ke.eq(u);
                        if (Cn && p.grid.updateSlide(u, d, Ae, s), "none" !== d.css("display")) {
                            if ("auto" === T.slidesPerView) {
                                o && (ke[u].style[s("width")] = "");
                                const C = getComputedStyle(d[0]), ee = d[0].style.transform,
                                    se = d[0].style.webkitTransform;
                                if (ee && (d[0].style.transform = "none"), se && (d[0].style.webkitTransform = "none"), T.roundLengths) N = p.isHorizontal() ? d.outerWidth(!0) : d.outerHeight(!0); else {
                                    const ct = _(C, "width"), xt = _(C, "padding-left"), st = _(C, "padding-right"),
                                        Vt = _(C, "margin-left"), Wt = _(C, "margin-right"),
                                        pn = C.getPropertyValue("box-sizing");
                                    if (pn && "border-box" === pn) N = ct + Vt + Wt; else {
                                        const {clientWidth: Ln, offsetWidth: er} = d[0];
                                        N = ct + xt + st + Vt + Wt + (er - Ln)
                                    }
                                }
                                ee && (d[0].style.transform = ee), se && (d[0].style.webkitTransform = se), T.roundLengths && (N = Math.floor(N))
                            } else N = (le - (T.slidesPerView - 1) * bt) / T.slidesPerView, T.roundLengths && (N = Math.floor(N)), ke[u] && (ke[u].style[s("width")] = `${N}px`);
                            ke[u] && (ke[u].swiperSlideSize = N), pt.push(N), T.centeredSlides ? (Rt = Rt + N / 2 + An / 2 + bt, 0 === An && 0 !== u && (Rt = Rt - le / 2 - bt), 0 === u && (Rt = Rt - le / 2 - bt), Math.abs(Rt) < .001 && (Rt = 0), T.roundLengths && (Rt = Math.floor(Rt)), on % T.slidesPerGroup == 0 && we.push(Rt), nt.push(Rt)) : (T.roundLengths && (Rt = Math.floor(Rt)), (on - Math.min(p.params.slidesPerGroupSkip, on)) % p.params.slidesPerGroup == 0 && we.push(Rt), nt.push(Rt), Rt = Rt + N + bt), p.virtualSize += N + bt, An = N, on += 1
                        }
                    }
                    if (p.virtualSize = Math.max(p.virtualSize, le) + qe, De && He && ("slide" === T.effect || "coverflow" === T.effect) && fe.css({width: `${p.virtualSize + T.spaceBetween}px`}), T.setWrapperSize && fe.css({[s("width")]: `${p.virtualSize + T.spaceBetween}px`}), Cn && p.grid.updateWrapperSize(N, we, s), !T.centeredSlides) {
                        const u = [];
                        for (let d = 0; d < we.length; d += 1) {
                            let C = we[d];
                            T.roundLengths && (C = Math.floor(C)), we[d] <= p.virtualSize - le && u.push(C)
                        }
                        we = u, Math.floor(p.virtualSize - le) - Math.floor(we[we.length - 1]) > 1 && we.push(p.virtualSize - le)
                    }
                    if (0 === we.length && (we = [0]), 0 !== T.spaceBetween) {
                        const u = p.isHorizontal() && De ? "marginLeft" : s("marginRight");
                        ke.filter((d, C) => !T.cssMode || C !== ke.length - 1).css({[u]: `${bt}px`})
                    }
                    if (T.centeredSlides && T.centeredSlidesBounds) {
                        let u = 0;
                        pt.forEach(C => {
                            u += C + (T.spaceBetween ? T.spaceBetween : 0)
                        }), u -= T.spaceBetween;
                        const d = u - le;
                        we = we.map(C => C < 0 ? -Tt : C > d ? d + qe : C)
                    }
                    if (T.centerInsufficientSlides) {
                        let u = 0;
                        if (pt.forEach(d => {
                            u += d + (T.spaceBetween ? T.spaceBetween : 0)
                        }), u -= T.spaceBetween, u < le) {
                            const d = (le - u) / 2;
                            we.forEach((C, ee) => {
                                we[ee] = C - d
                            }), nt.forEach((C, ee) => {
                                nt[ee] = C + d
                            })
                        }
                    }
                    if (Object.assign(p, {
                        slides: ke,
                        snapGrid: we,
                        slidesGrid: nt,
                        slidesSizesGrid: pt
                    }), T.centeredSlides && T.cssMode && !T.centeredSlidesBounds) {
                        Er(p.wrapperEl, "--swiper-centered-offset-before", -we[0] + "px"), Er(p.wrapperEl, "--swiper-centered-offset-after", p.size / 2 - pt[pt.length - 1] / 2 + "px");
                        const u = -p.snapGrid[0], d = -p.slidesGrid[0];
                        p.snapGrid = p.snapGrid.map(C => C + u), p.slidesGrid = p.slidesGrid.map(C => C + d)
                    }
                    if (Ae !== je && p.emit("slidesLengthChange"), we.length !== ot && (p.params.watchOverflow && p.checkOverflow(), p.emit("snapGridLengthChange")), nt.length !== Nt && p.emit("slidesGridLengthChange"), T.watchSlidesProgress && p.updateSlidesOffset(), !(Oe || T.cssMode || "slide" !== T.effect && "fade" !== T.effect)) {
                        const u = `${T.containerModifierClass}backface-hidden`, d = p.$el.hasClass(u);
                        Ae <= T.maxBackfaceHiddenSlides ? d || p.$el.addClass(u) : d && p.$el.removeClass(u)
                    }
                }, updateAutoHeight: function Kt(p) {
                    const s = this, _ = [], T = s.virtual && s.params.virtual.enabled;
                    let le, fe = 0;
                    "number" == typeof p ? s.setTransition(p) : !0 === p && s.setTransition(s.params.speed);
                    const De = He => T ? s.slides.filter(Oe => parseInt(Oe.getAttribute("data-swiper-slide-index"), 10) === He)[0] : s.slides.eq(He)[0];
                    if ("auto" !== s.params.slidesPerView && s.params.slidesPerView > 1) if (s.params.centeredSlides) (s.visibleSlides || an([])).each(He => {
                        _.push(He)
                    }); else for (le = 0; le < Math.ceil(s.params.slidesPerView); le += 1) {
                        const He = s.activeIndex + le;
                        if (He > s.slides.length && !T) break;
                        _.push(De(He))
                    } else _.push(De(s.activeIndex));
                    for (le = 0; le < _.length; le += 1) if (void 0 !== _[le]) {
                        const He = _[le].offsetHeight;
                        fe = He > fe ? He : fe
                    }
                    (fe || 0 === fe) && s.$wrapperEl.css("height", `${fe}px`)
                }, updateSlidesOffset: function qt() {
                    const p = this, s = p.slides;
                    for (let _ = 0; _ < s.length; _ += 1) s[_].swiperSlideOffset = p.isHorizontal() ? s[_].offsetLeft : s[_].offsetTop
                }, updateSlidesProgress: function Zt(p) {
                    void 0 === p && (p = this && this.translate || 0);
                    const s = this, _ = s.params, {slides: T, rtlTranslate: fe, snapGrid: le} = s;
                    if (0 === T.length) return;
                    void 0 === T[0].swiperSlideOffset && s.updateSlidesOffset();
                    let De = -p;
                    fe && (De = p), T.removeClass(_.slideVisibleClass), s.visibleSlidesIndexes = [], s.visibleSlides = [];
                    for (let He = 0; He < T.length; He += 1) {
                        const Oe = T[He];
                        let je = Oe.swiperSlideOffset;
                        _.cssMode && _.centeredSlides && (je -= T[0].swiperSlideOffset);
                        const ke = (De + (_.centeredSlides ? s.minTranslate() : 0) - je) / (Oe.swiperSlideSize + _.spaceBetween),
                            Ae = (De - le[0] + (_.centeredSlides ? s.minTranslate() : 0) - je) / (Oe.swiperSlideSize + _.spaceBetween),
                            we = -(De - je), nt = we + s.slidesSizesGrid[He];
                        (we >= 0 && we < s.size - 1 || nt > 1 && nt <= s.size || we <= 0 && nt >= s.size) && (s.visibleSlides.push(Oe), s.visibleSlidesIndexes.push(He), T.eq(He).addClass(_.slideVisibleClass)), Oe.progress = fe ? -ke : ke, Oe.originalProgress = fe ? -Ae : Ae
                    }
                    s.visibleSlides = an(s.visibleSlides)
                }, updateProgress: function hn(p) {
                    const s = this;
                    if (void 0 === p) {
                        const je = s.rtlTranslate ? -1 : 1;
                        p = s && s.translate && s.translate * je || 0
                    }
                    const _ = s.params, T = s.maxTranslate() - s.minTranslate();
                    let {progress: fe, isBeginning: le, isEnd: De} = s;
                    const He = le, Oe = De;
                    0 === T ? (fe = 0, le = !0, De = !0) : (fe = (p - s.minTranslate()) / T, le = fe <= 0, De = fe >= 1), Object.assign(s, {
                        progress: fe,
                        isBeginning: le,
                        isEnd: De
                    }), (_.watchSlidesProgress || _.centeredSlides && _.autoHeight) && s.updateSlidesProgress(p), le && !He && s.emit("reachBeginning toEdge"), De && !Oe && s.emit("reachEnd toEdge"), (He && !le || Oe && !De) && s.emit("fromEdge"), s.emit("progress", fe)
                }, updateSlidesClasses: function Bn() {
                    const p = this, {slides: s, params: _, $wrapperEl: T, activeIndex: fe, realIndex: le} = p,
                        De = p.virtual && _.virtual.enabled;
                    let He;
                    s.removeClass(`${_.slideActiveClass} ${_.slideNextClass} ${_.slidePrevClass} ${_.slideDuplicateActiveClass} ${_.slideDuplicateNextClass} ${_.slideDuplicatePrevClass}`), He = De ? p.$wrapperEl.find(`.${_.slideClass}[data-swiper-slide-index="${fe}"]`) : s.eq(fe), He.addClass(_.slideActiveClass), _.loop && (He.hasClass(_.slideDuplicateClass) ? T.children(`.${_.slideClass}:not(.${_.slideDuplicateClass})[data-swiper-slide-index="${le}"]`).addClass(_.slideDuplicateActiveClass) : T.children(`.${_.slideClass}.${_.slideDuplicateClass}[data-swiper-slide-index="${le}"]`).addClass(_.slideDuplicateActiveClass));
                    let Oe = He.nextAll(`.${_.slideClass}`).eq(0).addClass(_.slideNextClass);
                    _.loop && 0 === Oe.length && (Oe = s.eq(0), Oe.addClass(_.slideNextClass));
                    let je = He.prevAll(`.${_.slideClass}`).eq(0).addClass(_.slidePrevClass);
                    _.loop && 0 === je.length && (je = s.eq(-1), je.addClass(_.slidePrevClass)), _.loop && (Oe.hasClass(_.slideDuplicateClass) ? T.children(`.${_.slideClass}:not(.${_.slideDuplicateClass})[data-swiper-slide-index="${Oe.attr("data-swiper-slide-index")}"]`).addClass(_.slideDuplicateNextClass) : T.children(`.${_.slideClass}.${_.slideDuplicateClass}[data-swiper-slide-index="${Oe.attr("data-swiper-slide-index")}"]`).addClass(_.slideDuplicateNextClass), je.hasClass(_.slideDuplicateClass) ? T.children(`.${_.slideClass}:not(.${_.slideDuplicateClass})[data-swiper-slide-index="${je.attr("data-swiper-slide-index")}"]`).addClass(_.slideDuplicatePrevClass) : T.children(`.${_.slideClass}.${_.slideDuplicateClass}[data-swiper-slide-index="${je.attr("data-swiper-slide-index")}"]`).addClass(_.slideDuplicatePrevClass)), p.emitSlidesClasses()
                }, updateActiveIndex: function Zn(p) {
                    const s = this, _ = s.rtlTranslate ? s.translate : -s.translate, {
                        slidesGrid: T,
                        snapGrid: fe,
                        params: le,
                        activeIndex: De,
                        realIndex: He,
                        snapIndex: Oe
                    } = s;
                    let ke, je = p;
                    if (void 0 === je) {
                        for (let we = 0; we < T.length; we += 1) void 0 !== T[we + 1] ? _ >= T[we] && _ < T[we + 1] - (T[we + 1] - T[we]) / 2 ? je = we : _ >= T[we] && _ < T[we + 1] && (je = we + 1) : _ >= T[we] && (je = we);
                        le.normalizeSlideIndex && (je < 0 || void 0 === je) && (je = 0)
                    }
                    if (fe.indexOf(_) >= 0) ke = fe.indexOf(_); else {
                        const we = Math.min(le.slidesPerGroupSkip, je);
                        ke = we + Math.floor((je - we) / le.slidesPerGroup)
                    }
                    if (ke >= fe.length && (ke = fe.length - 1), je === De) return void (ke !== Oe && (s.snapIndex = ke, s.emit("snapIndexChange")));
                    const Ae = parseInt(s.slides.eq(je).attr("data-swiper-slide-index") || je, 10);
                    Object.assign(s, {
                        snapIndex: ke,
                        realIndex: Ae,
                        previousIndex: De,
                        activeIndex: je
                    }), s.emit("activeIndexChange"), s.emit("snapIndexChange"), He !== Ae && s.emit("realIndexChange"), (s.initialized || s.params.runCallbacksOnInit) && s.emit("slideChange")
                }, updateClickedSlide: function lr(p) {
                    const s = this, _ = s.params, T = an(p).closest(`.${_.slideClass}`)[0];
                    let le, fe = !1;
                    if (T) for (let De = 0; De < s.slides.length; De += 1) if (s.slides[De] === T) {
                        fe = !0, le = De;
                        break
                    }
                    if (!T || !fe) return s.clickedSlide = void 0, void (s.clickedIndex = void 0);
                    s.clickedSlide = T, s.clickedIndex = s.virtual && s.params.virtual.enabled ? parseInt(an(T).attr("data-swiper-slide-index"), 10) : le, _.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide()
                }
            }, translate: {
                getTranslate: function $r(p) {
                    void 0 === p && (p = this.isHorizontal() ? "x" : "y");
                    const {params: _, rtlTranslate: T, translate: fe, $wrapperEl: le} = this;
                    if (_.virtualTranslate) return T ? -fe : fe;
                    if (_.cssMode) return fe;
                    let De = function nn(p, s) {
                        void 0 === s && (s = "x");
                        const _ = W();
                        let T, fe, le;
                        const De = function Un(p) {
                            const s = W();
                            let _;
                            return s.getComputedStyle && (_ = s.getComputedStyle(p, null)), !_ && p.currentStyle && (_ = p.currentStyle), _ || (_ = p.style), _
                        }(p);
                        return _.WebKitCSSMatrix ? (fe = De.transform || De.webkitTransform, fe.split(",").length > 6 && (fe = fe.split(", ").map(He => He.replace(",", ".")).join(", ")), le = new _.WebKitCSSMatrix("none" === fe ? "" : fe)) : (le = De.MozTransform || De.OTransform || De.MsTransform || De.msTransform || De.transform || De.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), T = le.toString().split(",")), "x" === s && (fe = _.WebKitCSSMatrix ? le.m41 : 16 === T.length ? parseFloat(T[12]) : parseFloat(T[4])), "y" === s && (fe = _.WebKitCSSMatrix ? le.m42 : 16 === T.length ? parseFloat(T[13]) : parseFloat(T[5])), fe || 0
                    }(le[0], p);
                    return T && (De = -De), De || 0
                }, setTranslate: function Nr(p, s) {
                    const _ = this, {rtlTranslate: T, params: fe, $wrapperEl: le, wrapperEl: De, progress: He} = _;
                    let Ae, Oe = 0, je = 0;
                    _.isHorizontal() ? Oe = T ? -p : p : je = p, fe.roundLengths && (Oe = Math.floor(Oe), je = Math.floor(je)), fe.cssMode ? De[_.isHorizontal() ? "scrollLeft" : "scrollTop"] = _.isHorizontal() ? -Oe : -je : fe.virtualTranslate || le.transform(`translate3d(${Oe}px, ${je}px, 0px)`), _.previousTranslate = _.translate, _.translate = _.isHorizontal() ? Oe : je;
                    const we = _.maxTranslate() - _.minTranslate();
                    Ae = 0 === we ? 0 : (p - _.minTranslate()) / we, Ae !== He && _.updateProgress(p), _.emit("setTranslate", _.translate, s)
                }, minTranslate: function li() {
                    return -this.snapGrid[0]
                }, maxTranslate: function Ci() {
                    return -this.snapGrid[this.snapGrid.length - 1]
                }, translateTo: function hi(p, s, _, T, fe) {
                    void 0 === p && (p = 0), void 0 === s && (s = this.params.speed), void 0 === _ && (_ = !0), void 0 === T && (T = !0);
                    const le = this, {params: De, wrapperEl: He} = le;
                    if (le.animating && De.preventInteractionOnTransition) return !1;
                    const Oe = le.minTranslate(), je = le.maxTranslate();
                    let ke;
                    if (ke = T && p > Oe ? Oe : T && p < je ? je : p, le.updateProgress(ke), De.cssMode) {
                        const Ae = le.isHorizontal();
                        if (0 === s) He[Ae ? "scrollLeft" : "scrollTop"] = -ke; else {
                            if (!le.support.smoothScroll) return gr({
                                swiper: le,
                                targetPosition: -ke,
                                side: Ae ? "left" : "top"
                            }), !0;
                            He.scrollTo({[Ae ? "left" : "top"]: -ke, behavior: "smooth"})
                        }
                        return !0
                    }
                    return 0 === s ? (le.setTransition(0), le.setTranslate(ke), _ && (le.emit("beforeTransitionStart", s, fe), le.emit("transitionEnd"))) : (le.setTransition(s), le.setTranslate(ke), _ && (le.emit("beforeTransitionStart", s, fe), le.emit("transitionStart")), le.animating || (le.animating = !0, le.onTranslateToWrapperTransitionEnd || (le.onTranslateToWrapperTransitionEnd = function (we) {
                        !le || le.destroyed || we.target === this && (le.$wrapperEl[0].removeEventListener("transitionend", le.onTranslateToWrapperTransitionEnd), le.$wrapperEl[0].removeEventListener("webkitTransitionEnd", le.onTranslateToWrapperTransitionEnd), le.onTranslateToWrapperTransitionEnd = null, delete le.onTranslateToWrapperTransitionEnd, _ && le.emit("transitionEnd"))
                    }), le.$wrapperEl[0].addEventListener("transitionend", le.onTranslateToWrapperTransitionEnd), le.$wrapperEl[0].addEventListener("webkitTransitionEnd", le.onTranslateToWrapperTransitionEnd))), !0
                }
            }, transition: {
                setTransition: function ki(p, s) {
                    const _ = this;
                    _.params.cssMode || _.$wrapperEl.transition(p), _.emit("setTransition", p, s)
                }, transitionStart: function Fi(p, s) {
                    void 0 === p && (p = !0);
                    const _ = this, {params: T} = _;
                    T.cssMode || (T.autoHeight && _.updateAutoHeight(), Pi({
                        swiper: _,
                        runCallbacks: p,
                        direction: s,
                        step: "Start"
                    }))
                }, transitionEnd: function Oi(p, s) {
                    void 0 === p && (p = !0);
                    const _ = this, {params: T} = _;
                    _.animating = !1, !T.cssMode && (_.setTransition(0), Pi({
                        swiper: _,
                        runCallbacks: p,
                        direction: s,
                        step: "End"
                    }))
                }
            }, slide: {
                slideTo: function ci(p, s, _, T, fe) {
                    if (void 0 === p && (p = 0), void 0 === s && (s = this.params.speed), void 0 === _ && (_ = !0), "number" != typeof p && "string" != typeof p) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof p}] given.`);
                    if ("string" == typeof p) {
                        const bt = parseInt(p, 10);
                        if (!isFinite(bt)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${p}] given.`);
                        p = bt
                    }
                    const le = this;
                    let De = p;
                    De < 0 && (De = 0);
                    const {
                        params: He,
                        snapGrid: Oe,
                        slidesGrid: je,
                        previousIndex: ke,
                        activeIndex: Ae,
                        rtlTranslate: we,
                        wrapperEl: nt,
                        enabled: pt
                    } = le;
                    if (le.animating && He.preventInteractionOnTransition || !pt && !T && !fe) return !1;
                    const Tt = Math.min(le.params.slidesPerGroupSkip, De);
                    let qe = Tt + Math.floor((De - Tt) / le.params.slidesPerGroup);
                    qe >= Oe.length && (qe = Oe.length - 1), (Ae || He.initialSlide || 0) === (ke || 0) && _ && le.emit("beforeSlideChangeStart");
                    const ot = -Oe[qe];
                    if (le.updateProgress(ot), He.normalizeSlideIndex) for (let bt = 0; bt < je.length; bt += 1) {
                        const Rt = -Math.floor(100 * ot), An = Math.floor(100 * je[bt]),
                            on = Math.floor(100 * je[bt + 1]);
                        void 0 !== je[bt + 1] ? Rt >= An && Rt < on - (on - An) / 2 ? De = bt : Rt >= An && Rt < on && (De = bt + 1) : Rt >= An && (De = bt)
                    }
                    if (le.initialized && De !== Ae && (!le.allowSlideNext && ot < le.translate && ot < le.minTranslate() || !le.allowSlidePrev && ot > le.translate && ot > le.maxTranslate() && (Ae || 0) !== De)) return !1;
                    let Nt;
                    if (Nt = De > Ae ? "next" : De < Ae ? "prev" : "reset", we && -ot === le.translate || !we && ot === le.translate) return le.updateActiveIndex(De), He.autoHeight && le.updateAutoHeight(), le.updateSlidesClasses(), "slide" !== He.effect && le.setTranslate(ot), "reset" !== Nt && (le.transitionStart(_, Nt), le.transitionEnd(_, Nt)), !1;
                    if (He.cssMode) {
                        const bt = le.isHorizontal(), Rt = we ? ot : -ot;
                        if (0 === s) {
                            const An = le.virtual && le.params.virtual.enabled;
                            An && (le.wrapperEl.style.scrollSnapType = "none", le._immediateVirtual = !0), nt[bt ? "scrollLeft" : "scrollTop"] = Rt, An && requestAnimationFrame(() => {
                                le.wrapperEl.style.scrollSnapType = "", le._swiperImmediateVirtual = !1
                            })
                        } else {
                            if (!le.support.smoothScroll) return gr({
                                swiper: le,
                                targetPosition: Rt,
                                side: bt ? "left" : "top"
                            }), !0;
                            nt.scrollTo({[bt ? "left" : "top"]: Rt, behavior: "smooth"})
                        }
                        return !0
                    }
                    return le.setTransition(s), le.setTranslate(ot), le.updateActiveIndex(De), le.updateSlidesClasses(), le.emit("beforeTransitionStart", s, T), le.transitionStart(_, Nt), 0 === s ? le.transitionEnd(_, Nt) : le.animating || (le.animating = !0, le.onSlideToWrapperTransitionEnd || (le.onSlideToWrapperTransitionEnd = function (Rt) {
                        !le || le.destroyed || Rt.target === this && (le.$wrapperEl[0].removeEventListener("transitionend", le.onSlideToWrapperTransitionEnd), le.$wrapperEl[0].removeEventListener("webkitTransitionEnd", le.onSlideToWrapperTransitionEnd), le.onSlideToWrapperTransitionEnd = null, delete le.onSlideToWrapperTransitionEnd, le.transitionEnd(_, Nt))
                    }), le.$wrapperEl[0].addEventListener("transitionend", le.onSlideToWrapperTransitionEnd), le.$wrapperEl[0].addEventListener("webkitTransitionEnd", le.onSlideToWrapperTransitionEnd)), !0
                }, slideToLoop: function Vi(p, s, _, T) {
                    if (void 0 === p && (p = 0), void 0 === s && (s = this.params.speed), void 0 === _ && (_ = !0), "string" == typeof p) {
                        const De = parseInt(p, 10);
                        if (!isFinite(De)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${p}] given.`);
                        p = De
                    }
                    let le = p;
                    return this.params.loop && (le += this.loopedSlides), this.slideTo(le, s, _, T)
                }, slideNext: function pi(p, s, _) {
                    void 0 === p && (p = this.params.speed), void 0 === s && (s = !0);
                    const T = this, {animating: fe, enabled: le, params: De} = T;
                    if (!le) return T;
                    let He = De.slidesPerGroup;
                    "auto" === De.slidesPerView && 1 === De.slidesPerGroup && De.slidesPerGroupAuto && (He = Math.max(T.slidesPerViewDynamic("current", !0), 1));
                    const Oe = T.activeIndex < De.slidesPerGroupSkip ? 1 : He;
                    if (De.loop) {
                        if (fe && De.loopPreventsSlide) return !1;
                        T.loopFix(), T._clientLeft = T.$wrapperEl[0].clientLeft
                    }
                    return T.slideTo(De.rewind && T.isEnd ? 0 : T.activeIndex + Oe, p, s, _)
                }, slidePrev: function Wi(p, s, _) {
                    void 0 === p && (p = this.params.speed), void 0 === s && (s = !0);
                    const T = this, {
                        params: fe,
                        animating: le,
                        snapGrid: De,
                        slidesGrid: He,
                        rtlTranslate: Oe,
                        enabled: je
                    } = T;
                    if (!je) return T;
                    if (fe.loop) {
                        if (le && fe.loopPreventsSlide) return !1;
                        T.loopFix(), T._clientLeft = T.$wrapperEl[0].clientLeft
                    }

                    function Ae(qe) {
                        return qe < 0 ? -Math.floor(Math.abs(qe)) : Math.floor(qe)
                    }

                    const we = Ae(Oe ? T.translate : -T.translate), nt = De.map(qe => Ae(qe));
                    let pt = De[nt.indexOf(we) - 1];
                    if (void 0 === pt && fe.cssMode) {
                        let qe;
                        De.forEach((ot, Nt) => {
                            we >= ot && (qe = Nt)
                        }), void 0 !== qe && (pt = De[qe > 0 ? qe - 1 : qe])
                    }
                    let Tt = 0;
                    return void 0 !== pt && (Tt = He.indexOf(pt), Tt < 0 && (Tt = T.activeIndex - 1), "auto" === fe.slidesPerView && 1 === fe.slidesPerGroup && fe.slidesPerGroupAuto && (Tt = Tt - T.slidesPerViewDynamic("previous", !0) + 1, Tt = Math.max(Tt, 0))), T.slideTo(fe.rewind && T.isBeginning ? T.params.virtual && T.params.virtual.enabled && T.virtual ? T.virtual.slides.length - 1 : T.slides.length - 1 : Tt, p, s, _)
                }, slideReset: function ei(p, s, _) {
                    return void 0 === p && (p = this.params.speed), void 0 === s && (s = !0), this.slideTo(this.activeIndex, p, s, _)
                }, slideToClosest: function xi(p, s, _, T) {
                    void 0 === p && (p = this.params.speed), void 0 === s && (s = !0), void 0 === T && (T = .5);
                    const fe = this;
                    let le = fe.activeIndex;
                    const De = Math.min(fe.params.slidesPerGroupSkip, le),
                        He = De + Math.floor((le - De) / fe.params.slidesPerGroup),
                        Oe = fe.rtlTranslate ? fe.translate : -fe.translate;
                    if (Oe >= fe.snapGrid[He]) {
                        const je = fe.snapGrid[He];
                        Oe - je > (fe.snapGrid[He + 1] - je) * T && (le += fe.params.slidesPerGroup)
                    } else {
                        const je = fe.snapGrid[He - 1];
                        Oe - je <= (fe.snapGrid[He] - je) * T && (le -= fe.params.slidesPerGroup)
                    }
                    return le = Math.max(le, 0), le = Math.min(le, fe.slidesGrid.length - 1), fe.slideTo(le, p, s, _)
                }, slideToClickedSlide: function Ui() {
                    const p = this, {params: s, $wrapperEl: _} = p,
                        T = "auto" === s.slidesPerView ? p.slidesPerViewDynamic() : s.slidesPerView;
                    let le, fe = p.clickedIndex;
                    if (s.loop) {
                        if (p.animating) return;
                        le = parseInt(an(p.clickedSlide).attr("data-swiper-slide-index"), 10), s.centeredSlides ? fe < p.loopedSlides - T / 2 || fe > p.slides.length - p.loopedSlides + T / 2 ? (p.loopFix(), fe = _.children(`.${s.slideClass}[data-swiper-slide-index="${le}"]:not(.${s.slideDuplicateClass})`).eq(0).index(), Sn(() => {
                            p.slideTo(fe)
                        })) : p.slideTo(fe) : fe > p.slides.length - T ? (p.loopFix(), fe = _.children(`.${s.slideClass}[data-swiper-slide-index="${le}"]:not(.${s.slideDuplicateClass})`).eq(0).index(), Sn(() => {
                            p.slideTo(fe)
                        })) : p.slideTo(fe)
                    } else p.slideTo(fe)
                }
            }, loop: {
                loopCreate: function ui() {
                    const p = this, s = te(), {params: _, $wrapperEl: T} = p,
                        fe = T.children().length > 0 ? an(T.children()[0].parentNode) : T;
                    fe.children(`.${_.slideClass}.${_.slideDuplicateClass}`).remove();
                    let le = fe.children(`.${_.slideClass}`);
                    if (_.loopFillGroupWithBlank) {
                        const Oe = _.slidesPerGroup - le.length % _.slidesPerGroup;
                        if (Oe !== _.slidesPerGroup) {
                            for (let je = 0; je < Oe; je += 1) {
                                const ke = an(s.createElement("div")).addClass(`${_.slideClass} ${_.slideBlankClass}`);
                                fe.append(ke)
                            }
                            le = fe.children(`.${_.slideClass}`)
                        }
                    }
                    "auto" === _.slidesPerView && !_.loopedSlides && (_.loopedSlides = le.length), p.loopedSlides = Math.ceil(parseFloat(_.loopedSlides || _.slidesPerView, 10)), p.loopedSlides += _.loopAdditionalSlides, p.loopedSlides > le.length && p.params.loopedSlidesLimit && (p.loopedSlides = le.length);
                    const De = [], He = [];
                    le.each((Oe, je) => {
                        an(Oe).attr("data-swiper-slide-index", je)
                    });
                    for (let Oe = 0; Oe < p.loopedSlides; Oe += 1) {
                        const je = Oe - Math.floor(Oe / le.length) * le.length;
                        He.push(le.eq(je)[0]), De.unshift(le.eq(le.length - je - 1)[0])
                    }
                    for (let Oe = 0; Oe < He.length; Oe += 1) fe.append(an(He[Oe].cloneNode(!0)).addClass(_.slideDuplicateClass));
                    for (let Oe = De.length - 1; Oe >= 0; Oe -= 1) fe.prepend(an(De[Oe].cloneNode(!0)).addClass(_.slideDuplicateClass))
                }, loopFix: function gi() {
                    const p = this;
                    p.emit("beforeLoopFix");
                    const {
                        activeIndex: s,
                        slides: _,
                        loopedSlides: T,
                        allowSlidePrev: fe,
                        allowSlideNext: le,
                        snapGrid: De,
                        rtlTranslate: He
                    } = p;
                    let Oe;
                    p.allowSlidePrev = !0, p.allowSlideNext = !0;
                    const ke = -De[s] - p.getTranslate();
                    s < T ? (Oe = _.length - 3 * T + s, Oe += T, p.slideTo(Oe, 0, !1, !0) && 0 !== ke && p.setTranslate((He ? -p.translate : p.translate) - ke)) : s >= _.length - T && (Oe = -_.length + s + T, Oe += T, p.slideTo(Oe, 0, !1, !0) && 0 !== ke && p.setTranslate((He ? -p.translate : p.translate) - ke)), p.allowSlidePrev = fe, p.allowSlideNext = le, p.emit("loopFix")
                }, loopDestroy: function Si() {
                    const {$wrapperEl: s, params: _, slides: T} = this;
                    s.children(`.${_.slideClass}.${_.slideDuplicateClass},.${_.slideClass}.${_.slideBlankClass}`).remove(), T.removeAttr("data-swiper-slide-index")
                }
            }, grabCursor: {
                setGrabCursor: function Xr(p) {
                    const s = this;
                    if (s.support.touch || !s.params.simulateTouch || s.params.watchOverflow && s.isLocked || s.params.cssMode) return;
                    const _ = "container" === s.params.touchEventsTarget ? s.el : s.wrapperEl;
                    _.style.cursor = "move", _.style.cursor = p ? "grabbing" : "grab"
                }, unsetGrabCursor: function ti() {
                    const p = this;
                    p.support.touch || p.params.watchOverflow && p.isLocked || p.params.cssMode || (p["container" === p.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
                }
            }, events: {
                attachEvents: function kn() {
                    const p = this, s = te(), {params: _, support: T} = p;
                    p.onTouchStart = vi.bind(p), p.onTouchMove = Di.bind(p), p.onTouchEnd = ni.bind(p), _.cssMode && (p.onScroll = ai.bind(p)), p.onClick = Ei.bind(p), T.touch && !ri && (s.addEventListener("touchstart", zr), ri = !0), Wr(p, "on")
                }, detachEvents: function Ti() {
                    Wr(this, "off")
                }
            }, breakpoints: {
                setBreakpoint: function J() {
                    const p = this, {activeIndex: s, initialized: _, loopedSlides: T = 0, params: fe, $el: le} = p,
                        De = fe.breakpoints;
                    if (!De || De && 0 === Object.keys(De).length) return;
                    const He = p.getBreakpoint(De, p.params.breakpointsBase, p.el);
                    if (!He || p.currentBreakpoint === He) return;
                    const je = (He in De ? De[He] : void 0) || p.originalParams, ke = _i(p, fe), Ae = _i(p, je),
                        we = fe.enabled;
                    ke && !Ae ? (le.removeClass(`${fe.containerModifierClass}grid ${fe.containerModifierClass}grid-column`), p.emitContainerClasses()) : !ke && Ae && (le.addClass(`${fe.containerModifierClass}grid`), (je.grid.fill && "column" === je.grid.fill || !je.grid.fill && "column" === fe.grid.fill) && le.addClass(`${fe.containerModifierClass}grid-column`), p.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(qe => {
                        const ot = fe[qe] && fe[qe].enabled, Nt = je[qe] && je[qe].enabled;
                        ot && !Nt && p[qe].disable(), !ot && Nt && p[qe].enable()
                    });
                    const nt = je.direction && je.direction !== fe.direction,
                        pt = fe.loop && (je.slidesPerView !== fe.slidesPerView || nt);
                    nt && _ && p.changeDirection(), nr(p.params, je);
                    const Tt = p.params.enabled;
                    Object.assign(p, {
                        allowTouchMove: p.params.allowTouchMove,
                        allowSlideNext: p.params.allowSlideNext,
                        allowSlidePrev: p.params.allowSlidePrev
                    }), we && !Tt ? p.disable() : !we && Tt && p.enable(), p.currentBreakpoint = He, p.emit("_beforeBreakpoint", je), pt && _ && (p.loopDestroy(), p.loopCreate(), p.updateSlides(), p.slideTo(s - T + p.loopedSlides, 0, !1)), p.emit("breakpoint", je)
                }, getBreakpoint: function be(p, s, _) {
                    if (void 0 === s && (s = "window"), !p || "container" === s && !_) return;
                    let T = !1;
                    const fe = W(), le = "window" === s ? fe.innerHeight : _.clientHeight,
                        De = Object.keys(p).map(He => {
                            if ("string" == typeof He && 0 === He.indexOf("@")) {
                                const Oe = parseFloat(He.substr(1));
                                return {value: le * Oe, point: He}
                            }
                            return {value: He, point: He}
                        });
                    De.sort((He, Oe) => parseInt(He.value, 10) - parseInt(Oe.value, 10));
                    for (let He = 0; He < De.length; He += 1) {
                        const {point: Oe, value: je} = De[He];
                        "window" === s ? fe.matchMedia(`(min-width: ${je}px)`).matches && (T = Oe) : je <= _.clientWidth && (T = Oe)
                    }
                    return T || "max"
                }
            }, checkOverflow: {
                checkOverflow: function hr() {
                    const p = this, {isLocked: s, params: _} = p, {slidesOffsetBefore: T} = _;
                    if (T) {
                        const fe = p.slides.length - 1;
                        p.isLocked = p.size > p.slidesGrid[fe] + p.slidesSizesGrid[fe] + 2 * T
                    } else p.isLocked = 1 === p.snapGrid.length;
                    !0 === _.allowSlideNext && (p.allowSlideNext = !p.isLocked), !0 === _.allowSlidePrev && (p.allowSlidePrev = !p.isLocked), s && s !== p.isLocked && (p.isEnd = !1), s !== p.isLocked && p.emit(p.isLocked ? "lock" : "unlock")
                }
            }, classes: {
                addClasses: function mt() {
                    const p = this, {classNames: s, params: _, rtl: T, $el: fe, device: le, support: De} = p,
                        He = function Ve(p, s) {
                            const _ = [];
                            return p.forEach(T => {
                                "object" == typeof T ? Object.keys(T).forEach(fe => {
                                    T[fe] && _.push(s + fe)
                                }) : "string" == typeof T && _.push(s + T)
                            }), _
                        }(["initialized", _.direction, {"pointer-events": !De.touch}, {"free-mode": p.params.freeMode && _.freeMode.enabled}, {autoheight: _.autoHeight}, {rtl: T}, {grid: _.grid && _.grid.rows > 1}, {"grid-column": _.grid && _.grid.rows > 1 && "column" === _.grid.fill}, {android: le.android}, {ios: le.ios}, {"css-mode": _.cssMode}, {centered: _.cssMode && _.centeredSlides}, {"watch-progress": _.watchSlidesProgress}], _.containerModifierClass);
                    s.push(...He), fe.addClass([...s].join(" ")), p.emitContainerClasses()
                }, removeClasses: function Yt() {
                    const {$el: s, classNames: _} = this;
                    s.removeClass(_.join(" ")), this.emitContainerClasses()
                }
            }, images: {
                loadImage: function vn(p, s, _, T, fe, le) {
                    const De = W();
                    let He;

                    function Oe() {
                        le && le()
                    }

                    an(p).parent("picture")[0] || p.complete && fe || !s ? Oe() : (He = new De.Image, He.onload = Oe, He.onerror = Oe, T && (He.sizes = T), _ && (He.srcset = _), s && (He.src = s))
                }, preloadImages: function vr() {
                    const p = this;

                    function s() {
                        null == p || !p || p.destroyed || (void 0 !== p.imagesLoaded && (p.imagesLoaded += 1), p.imagesLoaded === p.imagesToLoad.length && (p.params.updateOnImagesReady && p.update(), p.emit("imagesReady")))
                    }

                    p.imagesToLoad = p.$el.find("img");
                    for (let _ = 0; _ < p.imagesToLoad.length; _ += 1) {
                        const T = p.imagesToLoad[_];
                        p.loadImage(T, T.currentSrc || T.getAttribute("src"), T.srcset || T.getAttribute("srcset"), T.sizes || T.getAttribute("sizes"), !0, s)
                    }
                }
            }
        }, Or = {};

        class Pr {
            constructor() {
                let s, _;
                for (var T = arguments.length, fe = new Array(T), le = 0; le < T; le++) fe[le] = arguments[le];
                if (1 === fe.length && fe[0].constructor && "Object" === Object.prototype.toString.call(fe[0]).slice(8, -1) ? _ = fe[0] : [s, _] = fe, _ || (_ = {}), _ = nr({}, _), s && !_.el && (_.el = s), _.el && an(_.el).length > 1) {
                    const je = [];
                    return an(_.el).each(ke => {
                        const Ae = nr({}, _, {el: ke});
                        je.push(new Pr(Ae))
                    }), je
                }
                const De = this;
                De.__swiper__ = !0, De.support = br(), De.device = function Br(p) {
                    return void 0 === p && (p = {}), Vn || (Vn = function $n(p) {
                        let {userAgent: s} = void 0 === p ? {} : p;
                        const _ = br(), T = W(), fe = T.navigator.platform, le = s || T.navigator.userAgent,
                            De = {ios: !1, android: !1}, He = T.screen.width, Oe = T.screen.height,
                            je = le.match(/(Android);?[\s\/]+([\d.]+)?/);
                        let ke = le.match(/(iPad).*OS\s([\d_]+)/);
                        const Ae = le.match(/(iPod)(.*OS\s([\d_]+))?/),
                            we = !ke && le.match(/(iPhone\sOS|iOS)\s([\d_]+)/), nt = "Win32" === fe;
                        let pt = "MacIntel" === fe;
                        return !ke && pt && _.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${He}x${Oe}`) >= 0 && (ke = le.match(/(Version)\/([\d.]+)/), ke || (ke = [0, 1, "13_0_0"]), pt = !1), je && !nt && (De.os = "android", De.android = !0), (ke || we || Ae) && (De.os = "ios", De.ios = !0), De
                    }(p)), Vn
                }({userAgent: _.userAgent}), De.browser = function We() {
                    return _r || (_r = function Pe() {
                        const p = W();
                        return {
                            isSafari: function s() {
                                const _ = p.navigator.userAgent.toLowerCase();
                                return _.indexOf("safari") >= 0 && _.indexOf("chrome") < 0 && _.indexOf("android") < 0
                            }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(p.navigator.userAgent)
                        }
                    }()), _r
                }(), De.eventsListeners = {}, De.eventsAnyListeners = [], De.modules = [...De.__modules__], _.modules && Array.isArray(_.modules) && De.modules.push(..._.modules);
                const He = {};
                De.modules.forEach(je => {
                    je({
                        swiper: De,
                        extendParams: yr(_, He),
                        on: De.on.bind(De),
                        once: De.once.bind(De),
                        off: De.off.bind(De),
                        emit: De.emit.bind(De)
                    })
                });
                const Oe = nr({}, Tr, He);
                return De.params = nr({}, Oe, Or, _), De.originalParams = nr({}, De.params), De.passedParams = nr({}, _), De.params && De.params.on && Object.keys(De.params.on).forEach(je => {
                    De.on(je, De.params.on[je])
                }), De.params && De.params.onAny && De.onAny(De.params.onAny), De.$ = an, Object.assign(De, {
                    enabled: De.params.enabled,
                    el: s,
                    classNames: [],
                    slides: an(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal: () => "horizontal" === De.params.direction,
                    isVertical: () => "vertical" === De.params.direction,
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: !0,
                    isEnd: !1,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: !1,
                    allowSlideNext: De.params.allowSlideNext,
                    allowSlidePrev: De.params.allowSlidePrev,
                    touchEvents: function () {
                        const ke = ["touchstart", "touchmove", "touchend", "touchcancel"],
                            Ae = ["pointerdown", "pointermove", "pointerup"];
                        return De.touchEventsTouch = {
                            start: ke[0],
                            move: ke[1],
                            end: ke[2],
                            cancel: ke[3]
                        }, De.touchEventsDesktop = {
                            start: Ae[0],
                            move: Ae[1],
                            end: Ae[2]
                        }, De.support.touch || !De.params.simulateTouch ? De.touchEventsTouch : De.touchEventsDesktop
                    }(),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: De.params.focusableElements,
                        lastClickTime: ar(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: !0,
                    allowTouchMove: De.params.allowTouchMove,
                    touches: {startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0},
                    imagesToLoad: [],
                    imagesLoaded: 0
                }), De.emit("_swiper"), De.params.init && De.init(), De
            }

            enable() {
                const s = this;
                s.enabled || (s.enabled = !0, s.params.grabCursor && s.setGrabCursor(), s.emit("enable"))
            }

            disable() {
                const s = this;
                !s.enabled || (s.enabled = !1, s.params.grabCursor && s.unsetGrabCursor(), s.emit("disable"))
            }

            setProgress(s, _) {
                const T = this;
                s = Math.min(Math.max(s, 0), 1);
                const fe = T.minTranslate(), De = (T.maxTranslate() - fe) * s + fe;
                T.translateTo(De, void 0 === _ ? 0 : _), T.updateActiveIndex(), T.updateSlidesClasses()
            }

            emitContainerClasses() {
                const s = this;
                if (!s.params._emitClasses || !s.el) return;
                const _ = s.el.className.split(" ").filter(T => 0 === T.indexOf("swiper") || 0 === T.indexOf(s.params.containerModifierClass));
                s.emit("_containerClasses", _.join(" "))
            }

            getSlideClasses(s) {
                const _ = this;
                return _.destroyed ? "" : s.className.split(" ").filter(T => 0 === T.indexOf("swiper-slide") || 0 === T.indexOf(_.params.slideClass)).join(" ")
            }

            emitSlidesClasses() {
                const s = this;
                if (!s.params._emitClasses || !s.el) return;
                const _ = [];
                s.slides.each(T => {
                    const fe = s.getSlideClasses(T);
                    _.push({slideEl: T, classNames: fe}), s.emit("_slideClass", T, fe)
                }), s.emit("_slideClasses", _)
            }

            slidesPerViewDynamic(s, _) {
                void 0 === s && (s = "current"), void 0 === _ && (_ = !1);
                const {params: fe, slides: le, slidesGrid: De, slidesSizesGrid: He, size: Oe, activeIndex: je} = this;
                let ke = 1;
                if (fe.centeredSlides) {
                    let we, Ae = le[je].swiperSlideSize;
                    for (let nt = je + 1; nt < le.length; nt += 1) le[nt] && !we && (Ae += le[nt].swiperSlideSize, ke += 1, Ae > Oe && (we = !0));
                    for (let nt = je - 1; nt >= 0; nt -= 1) le[nt] && !we && (Ae += le[nt].swiperSlideSize, ke += 1, Ae > Oe && (we = !0))
                } else if ("current" === s) for (let Ae = je + 1; Ae < le.length; Ae += 1) (_ ? De[Ae] + He[Ae] - De[je] < Oe : De[Ae] - De[je] < Oe) && (ke += 1); else for (let Ae = je - 1; Ae >= 0; Ae -= 1) De[je] - De[Ae] < Oe && (ke += 1);
                return ke
            }

            update() {
                const s = this;
                if (!s || s.destroyed) return;
                const {snapGrid: _, params: T} = s;

                function fe() {
                    const He = Math.min(Math.max(s.rtlTranslate ? -1 * s.translate : s.translate, s.maxTranslate()), s.minTranslate());
                    s.setTranslate(He), s.updateActiveIndex(), s.updateSlidesClasses()
                }

                let le;
                T.breakpoints && s.setBreakpoint(), s.updateSize(), s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.params.freeMode && s.params.freeMode.enabled ? (fe(), s.params.autoHeight && s.updateAutoHeight()) : (le = s.slideTo(("auto" === s.params.slidesPerView || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides ? s.slides.length - 1 : s.activeIndex, 0, !1, !0), le || fe()), T.watchOverflow && _ !== s.snapGrid && s.checkOverflow(), s.emit("update")
            }

            changeDirection(s, _) {
                void 0 === _ && (_ = !0);
                const T = this, fe = T.params.direction;
                return s || (s = "horizontal" === fe ? "vertical" : "horizontal"), s === fe || "horizontal" !== s && "vertical" !== s || (T.$el.removeClass(`${T.params.containerModifierClass}${fe}`).addClass(`${T.params.containerModifierClass}${s}`), T.emitContainerClasses(), T.params.direction = s, T.slides.each(le => {
                    "vertical" === s ? le.style.width = "" : le.style.height = ""
                }), T.emit("changeDirection"), _ && T.update()), T
            }

            changeLanguageDirection(s) {
                const _ = this;
                _.rtl && "rtl" === s || !_.rtl && "ltr" === s || (_.rtl = "rtl" === s, _.rtlTranslate = "horizontal" === _.params.direction && _.rtl, _.rtl ? (_.$el.addClass(`${_.params.containerModifierClass}rtl`), _.el.dir = "rtl") : (_.$el.removeClass(`${_.params.containerModifierClass}rtl`), _.el.dir = "ltr"), _.update())
            }

            mount(s) {
                const _ = this;
                if (_.mounted) return !0;
                const T = an(s || _.params.el);
                if (!(s = T[0])) return !1;
                s.swiper = _;
                const fe = () => `.${(_.params.wrapperClass || "").trim().split(" ").join(".")}`;
                let De = (() => {
                    if (s && s.shadowRoot && s.shadowRoot.querySelector) {
                        const He = an(s.shadowRoot.querySelector(fe()));
                        return He.children = Oe => T.children(Oe), He
                    }
                    return T.children ? T.children(fe()) : an(T).children(fe())
                })();
                if (0 === De.length && _.params.createElements) {
                    const Oe = te().createElement("div");
                    De = an(Oe), Oe.className = _.params.wrapperClass, T.append(Oe), T.children(`.${_.params.slideClass}`).each(je => {
                        De.append(je)
                    })
                }
                return Object.assign(_, {
                    $el: T,
                    el: s,
                    $wrapperEl: De,
                    wrapperEl: De[0],
                    mounted: !0,
                    rtl: "rtl" === s.dir.toLowerCase() || "rtl" === T.css("direction"),
                    rtlTranslate: "horizontal" === _.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === T.css("direction")),
                    wrongRTL: "-webkit-box" === De.css("display")
                }), !0
            }

            init(s) {
                const _ = this;
                return _.initialized || !1 === _.mount(s) || (_.emit("beforeInit"), _.params.breakpoints && _.setBreakpoint(), _.addClasses(), _.params.loop && _.loopCreate(), _.updateSize(), _.updateSlides(), _.params.watchOverflow && _.checkOverflow(), _.params.grabCursor && _.enabled && _.setGrabCursor(), _.params.preloadImages && _.preloadImages(), _.slideTo(_.params.loop ? _.params.initialSlide + _.loopedSlides : _.params.initialSlide, 0, _.params.runCallbacksOnInit, !1, !0), _.attachEvents(), _.initialized = !0, _.emit("init"), _.emit("afterInit")), _
            }

            destroy(s, _) {
                void 0 === s && (s = !0), void 0 === _ && (_ = !0);
                const T = this, {params: fe, $el: le, $wrapperEl: De, slides: He} = T;
                return void 0 === T.params || T.destroyed || (T.emit("beforeDestroy"), T.initialized = !1, T.detachEvents(), fe.loop && T.loopDestroy(), _ && (T.removeClasses(), le.removeAttr("style"), De.removeAttr("style"), He && He.length && He.removeClass([fe.slideVisibleClass, fe.slideActiveClass, fe.slideNextClass, fe.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), T.emit("destroy"), Object.keys(T.eventsListeners).forEach(Oe => {
                    T.off(Oe)
                }), !1 !== s && (T.$el[0].swiper = null, function En(p) {
                    const s = p;
                    Object.keys(s).forEach(_ => {
                        try {
                            s[_] = null
                        } catch (T) {
                        }
                        try {
                            delete s[_]
                        } catch (T) {
                        }
                    })
                }(T)), T.destroyed = !0), null
            }

            static extendDefaults(s) {
                nr(Or, s)
            }

            static get extendedDefaults() {
                return Or
            }

            static get defaults() {
                return Tr
            }

            static installModule(s) {
                Pr.prototype.__modules__ || (Pr.prototype.__modules__ = []);
                const _ = Pr.prototype.__modules__;
                "function" == typeof s && _.indexOf(s) < 0 && _.push(s)
            }

            static use(s) {
                return Array.isArray(s) ? (s.forEach(_ => Pr.installModule(_)), Pr) : (Pr.installModule(s), Pr)
            }
        }

        Object.keys(Ar).forEach(p => {
            Object.keys(Ar[p]).forEach(s => {
                Pr.prototype[s] = Ar[p][s]
            })
        }), Pr.use([function Et(p) {
            let {swiper: s, on: _, emit: T} = p;
            const fe = W();
            let le = null, De = null;
            const He = () => {
                !s || s.destroyed || !s.initialized || (T("beforeResize"), T("resize"))
            }, ke = () => {
                !s || s.destroyed || !s.initialized || T("orientationchange")
            };
            _("init", () => {
                s.params.resizeObserver && void 0 !== fe.ResizeObserver ? !s || s.destroyed || !s.initialized || (le = new ResizeObserver(Ae => {
                    De = fe.requestAnimationFrame(() => {
                        const {width: we, height: nt} = s;
                        let pt = we, Tt = nt;
                        Ae.forEach(qe => {
                            let {contentBoxSize: ot, contentRect: Nt, target: bt} = qe;
                            bt && bt !== s.el || (pt = Nt ? Nt.width : (ot[0] || ot).inlineSize, Tt = Nt ? Nt.height : (ot[0] || ot).blockSize)
                        }), (pt !== we || Tt !== nt) && He()
                    })
                }), le.observe(s.el)) : (fe.addEventListener("resize", He), fe.addEventListener("orientationchange", ke))
            }), _("destroy", () => {
                De && fe.cancelAnimationFrame(De), le && le.unobserve && s.el && (le.unobserve(s.el), le = null), fe.removeEventListener("resize", He), fe.removeEventListener("orientationchange", ke)
            })
        }, function Ot(p) {
            let {swiper: s, extendParams: _, on: T, emit: fe} = p;
            const le = [], De = W(), He = function (ke, Ae) {
                void 0 === Ae && (Ae = {});
                const nt = new (De.MutationObserver || De.WebkitMutationObserver)(pt => {
                    if (1 === pt.length) return void fe("observerUpdate", pt[0]);
                    const Tt = function () {
                        fe("observerUpdate", pt[0])
                    };
                    De.requestAnimationFrame ? De.requestAnimationFrame(Tt) : De.setTimeout(Tt, 0)
                });
                nt.observe(ke, {
                    attributes: void 0 === Ae.attributes || Ae.attributes,
                    childList: void 0 === Ae.childList || Ae.childList,
                    characterData: void 0 === Ae.characterData || Ae.characterData
                }), le.push(nt)
            };
            _({observer: !1, observeParents: !1, observeSlideChildren: !1}), T("init", () => {
                if (s.params.observer) {
                    if (s.params.observeParents) {
                        const ke = s.$el.parents();
                        for (let Ae = 0; Ae < ke.length; Ae += 1) He(ke[Ae])
                    }
                    He(s.$el[0], {childList: s.params.observeSlideChildren}), He(s.$wrapperEl[0], {attributes: !1})
                }
            }), T("destroy", () => {
                le.forEach(ke => {
                    ke.disconnect()
                }), le.splice(0, le.length)
            })
        }]);
        const Gr = Pr;

        function jr(p) {
            let le, {swiper: s, extendParams: _, on: T, emit: fe} = p;

            function De(we, nt) {
                const pt = s.params.virtual;
                if (pt.cache && s.virtual.cache[nt]) return s.virtual.cache[nt];
                const Tt = an(pt.renderSlide ? pt.renderSlide.call(s, we, nt) : `<div class="${s.params.slideClass}" data-swiper-slide-index="${nt}">${we}</div>`);
                return Tt.attr("data-swiper-slide-index") || Tt.attr("data-swiper-slide-index", nt), pt.cache && (s.virtual.cache[nt] = Tt), Tt
            }

            function He(we) {
                const {slidesPerView: nt, slidesPerGroup: pt, centeredSlides: Tt} = s.params, {
                    addSlidesBefore: qe,
                    addSlidesAfter: ot
                } = s.params.virtual, {from: Nt, to: bt, slides: Rt, slidesGrid: An, offset: on} = s.virtual;
                s.params.cssMode || s.updateActiveIndex();
                const Cn = s.activeIndex || 0;
                let N, o, u;
                N = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", Tt ? (o = Math.floor(nt / 2) + pt + ot, u = Math.floor(nt / 2) + pt + qe) : (o = nt + (pt - 1) + ot, u = pt + qe);
                const d = Math.max((Cn || 0) - u, 0), C = Math.min((Cn || 0) + o, Rt.length - 1),
                    ee = (s.slidesGrid[d] || 0) - (s.slidesGrid[0] || 0);

                function se() {
                    s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.lazy && s.params.lazy.enabled && s.lazy.load(), fe("virtualUpdate")
                }

                if (Object.assign(s.virtual, {
                    from: d,
                    to: C,
                    offset: ee,
                    slidesGrid: s.slidesGrid
                }), Nt === d && bt === C && !we) return s.slidesGrid !== An && ee !== on && s.slides.css(N, `${ee}px`), s.updateProgress(), void fe("virtualUpdate");
                if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
                    offset: ee,
                    from: d,
                    to: C,
                    slides: function () {
                        const Vt = [];
                        for (let Wt = d; Wt <= C; Wt += 1) Vt.push(Rt[Wt]);
                        return Vt
                    }()
                }), void (s.params.virtual.renderExternalUpdate ? se() : fe("virtualUpdate"));
                const ct = [], xt = [];
                if (we) s.$wrapperEl.find(`.${s.params.slideClass}`).remove(); else for (let st = Nt; st <= bt; st += 1) (st < d || st > C) && s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index="${st}"]`).remove();
                for (let st = 0; st < Rt.length; st += 1) st >= d && st <= C && (void 0 === bt || we ? xt.push(st) : (st > bt && xt.push(st), st < Nt && ct.push(st)));
                xt.forEach(st => {
                    s.$wrapperEl.append(De(Rt[st], st))
                }), ct.sort((st, Vt) => Vt - st).forEach(st => {
                    s.$wrapperEl.prepend(De(Rt[st], st))
                }), s.$wrapperEl.children(".swiper-slide").css(N, `${ee}px`), se()
            }

            _({
                virtual: {
                    enabled: !1,
                    slides: [],
                    cache: !0,
                    renderSlide: null,
                    renderExternal: null,
                    renderExternalUpdate: !0,
                    addSlidesBefore: 0,
                    addSlidesAfter: 0
                }
            }), s.virtual = {
                cache: {},
                from: void 0,
                to: void 0,
                slides: [],
                offset: 0,
                slidesGrid: []
            }, T("beforeInit", () => {
                !s.params.virtual.enabled || (s.virtual.slides = s.params.virtual.slides, s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, s.params.initialSlide || He())
            }), T("setTranslate", () => {
                !s.params.virtual.enabled || (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(le), le = setTimeout(() => {
                    He()
                }, 100)) : He())
            }), T("init update resize", () => {
                !s.params.virtual.enabled || s.params.cssMode && Er(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
            }), Object.assign(s.virtual, {
                appendSlide: function Oe(we) {
                    if ("object" == typeof we && "length" in we) for (let nt = 0; nt < we.length; nt += 1) we[nt] && s.virtual.slides.push(we[nt]); else s.virtual.slides.push(we);
                    He(!0)
                }, prependSlide: function je(we) {
                    const nt = s.activeIndex;
                    let pt = nt + 1, Tt = 1;
                    if (Array.isArray(we)) {
                        for (let qe = 0; qe < we.length; qe += 1) we[qe] && s.virtual.slides.unshift(we[qe]);
                        pt = nt + we.length, Tt = we.length
                    } else s.virtual.slides.unshift(we);
                    if (s.params.virtual.cache) {
                        const qe = s.virtual.cache, ot = {};
                        Object.keys(qe).forEach(Nt => {
                            const bt = qe[Nt], Rt = bt.attr("data-swiper-slide-index");
                            Rt && bt.attr("data-swiper-slide-index", parseInt(Rt, 10) + Tt), ot[parseInt(Nt, 10) + Tt] = bt
                        }), s.virtual.cache = ot
                    }
                    He(!0), s.slideTo(pt, 0)
                }, removeSlide: function ke(we) {
                    if (null == we) return;
                    let nt = s.activeIndex;
                    if (Array.isArray(we)) for (let pt = we.length - 1; pt >= 0; pt -= 1) s.virtual.slides.splice(we[pt], 1), s.params.virtual.cache && delete s.virtual.cache[we[pt]], we[pt] < nt && (nt -= 1), nt = Math.max(nt, 0); else s.virtual.slides.splice(we, 1), s.params.virtual.cache && delete s.virtual.cache[we], we < nt && (nt -= 1), nt = Math.max(nt, 0);
                    He(!0), s.slideTo(nt, 0)
                }, removeAllSlides: function Ae() {
                    s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), He(!0), s.slideTo(0, 0)
                }, update: He
            })
        }
    }, 5861: (Jt, lt, R) => {
        "use strict";

        function r(ie, te, j, W, Q, Ne, ve) {
            try {
                var me = ie[Ne](ve), ae = me.value
            } catch (X) {
                return void j(X)
            }
            me.done ? te(ae) : Promise.resolve(ae).then(W, Q)
        }

        function D(ie) {
            return function () {
                var te = this, j = arguments;
                return new Promise(function (W, Q) {
                    var Ne = ie.apply(te, j);

                    function ve(ae) {
                        r(Ne, W, Q, ve, me, "next", ae)
                    }

                    function me(ae) {
                        r(Ne, W, Q, ve, me, "throw", ae)
                    }

                    ve(void 0)
                })
            }
        }

        R.d(lt, {Z: () => D})
    }
}, Jt => {
    Jt(Jt.s = 8362)
}]);